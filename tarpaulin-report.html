<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","julieta-murias","repos","seminario-rust","src","main.rs"],"content":"//mod tp02;\nmod tp03;\n//mod tp04;\nmod tp05;\n\n\nuse std::io::stdin;\nuse core::panic;\nconst NUMERO:i32 = 10; //ejercicio 7\nconst WORD: \u0026str = \"Abracadabra\"; //ejercicio 8\n\nfn main() { \n    //Práctica 1:\n    \n    //ejercicio 1--------------------------------\n    let fp_number  = 2.0;\n    println! (\"Write another number: \");\n    let mut number = String::new();\n    stdin().read_line(\u0026 mut number).expect(\"error\");\n    let number_okay:f64 = number.trim().parse().expect(\"error2\");\n\n    println! (\"first operation * , {}\" , fp_number * number_okay);\n    println! (\"second operation / , {}\" , number_okay / fp_number);\n    println! (\"third operation + , {}\" , fp_number + number_okay);\n    println! (\"fourth operation - , {}\" , number_okay - fp_number);\n\n\n    //ejercicio 2------------------------------------\n    let integer_number:u32 = 1234567890;\n    let hex_string = format!(\"{:X}\" , integer_number);\n    println!(\"{}\", hex_string);\n\n\n    //ejercicio 3---------------------------------\n    let t:bool = true; //defino variable booleana\n\n    let mut var_ingresada=String::new(); //el dato tiene que ser de tipo string para leerlo por teclado\n\n    println!(\"Ingresa un valor booleano (true or false\");\n\n\n   //leo el dato\n    stdin().read_line(\u0026mut var_ingresada)\n    .expect(\"error\"); \n\n    //convierto el dato a un booleano\n    let mut var_ingresada: bool = match var_ingresada.trim().parse(){\n        Ok(bool) =\u003e bool,\n        Err(_) =\u003e {\n            eprintln!(\"error\");\n            return;\n        }\n    };\n\n    let mut var_ingresada = var_ingresada \u0026\u0026 t;\n    println!(\"AND {} \", var_ingresada);\n\n    let mut var_ingresada = var_ingresada || t;\n    println!(\"OR {} \", var_ingresada);\n\n\n\n    //ejercicio4 ----------------------------------------\n    let tupla:(String , i32 , bool) = (\"let's get rusty\".to_string() , 10 , false);\n    println!(\"{} , {} , {}\" , tupla.0, tupla.1 , tupla.2);\n\n\n\n    //ejercicio 5 ----------------------------------------\n    let mut chain = String::from(\"Hello \");\n\n    let mut chain_ingresada = String::new();\n\n    println!(\"Ingresa una cadena\");\n\n    //leo el dato\n    stdin().read_line(\u0026mut chain_ingresada).expect(\"error\");\n\n    //concateno ambas cadenas\n    chain.push_str(\u0026*chain_ingresada);\n\n    let chain = chain.to_string();\n    let chain = chain.to_ascii_uppercase();\n\n    println!(\"{}\", chain);\n\n\n    //ejercicio 6 ------------------------------------------\n    let mut number :u32 = 2;\n    let mut number_ingresado = String::new();\n\n    println!(\"Ingresa un número\");\n\n    stdin().read_line(\u0026mut number_ingresado).\n    expect(\"error\");\n\n    let mut number_ingresado:u32 = match number_ingresado.trim().parse(){\n        Ok(u32) =\u003e u32,\n        Err(_) =\u003e {\n            eprintln!(\"error\");\n            return;\n        }\n    };\n\n    let mut number = number + number_ingresado;\n    println!(\"{}\", number.pow(2));\n\n\n    //ejercicio 7 ------------------------------------------\n    let mut arreglo:[i32 ; 6] = [10 , 4 , 77 , 6 , 8 , 0];\n    \n    for number in arreglo.iter_mut(){\n        *number = match number{\n        \u0026mut number =\u003e number * NUMERO,\n        }\n     }\n    \n    for index in 0..arreglo.len() {\n        println!(\"{}\", arreglo[index]);\n    }\n\n\n\n    //ejercicio 8 --------------------------------------\n    println!(\"Ingrese una letra para ver la cantidad de veces que ésta aparece en la constante definida\");\n\n    let mut caracter = String::from (\" \");\n\n\n    //leo el caracter\n    stdin().read_line(\u0026mut caracter)\n    .expect(\"error\");\n\n\n    //convierto el string que leí a caracter\n    let mut caracter: char = caracter.trim().parse()\n    .expect(\"error\");\n\n    let mut cantidad: u32 = 0;\n    for letra in WORD.chars(){\n        if caracter.to_ascii_lowercase() == letra.to_ascii_lowercase(){\n            cantidad = cantidad + 1;\n        }\n    }\n\n    println!( \"La cantidad de veces que aparece el caracter {} es : {}\", caracter , cantidad);\n\n\n\n    //ejercicio 9 -------------------------------------\n    let numeros : [i32 ; 5] = [0 , 300 , -100 , 10 , 9];\n\n    let mut suma_total:i32 = 0;\n\n    for numero in 0..numeros.len(){\n        suma_total += numeros[numero];\n    }\n\n    println!(\"La suma total de los números es {}\" , suma_total);\n\n\n\n    //ejercicio 10 ---------------------------------------------\n    let numeros1: [i32 ; 5] = [10 , 20 , 30 , 40 , 50];\n    let numeros2: [i32 ; 5] =  [1 , 2 , 3 , 4 , 5];\n\n    let mut numeros_suma: [i32 ; 5] = [0, 0, 0, 0, 0];\n\n    \n    for number in 0..5{\n        let mut suma_auxiliar: i32 = 0;\n        suma_auxiliar = numeros1[number] + numeros2[number];\n\n        numeros_suma[number] = suma_auxiliar;\n    }\n\n    for elemento in 0..numeros_suma.len(){\n        println!(\"{}\" , numeros_suma[elemento]);\n    }\n\n\n\n    //ejercicio 11 ---------------------------------------\n    let cadenas:[\u0026str ; 5] = [\"Hello\" , \"Bye\" , \"How are you?\" , \"Pepe\" , \"Good\"];\n\n    println!(\"Ingrese una cadena\");\n    let mut cadena_ingresada = String::new();\n\n\n    stdin().read_line(\u0026mut cadena_ingresada)\n    .expect(\"Error :/\");\n\n    let cadena_ingresada = cadena_ingresada.trim();\n\n    if cadenas.contains(\u0026cadena_ingresada){\n        println!(\"Está! :D\");\n    } else {\n        println!(\"No está :/\");\n    }\n\n\n\n    //ejercicio 12-----------------------------------\n    let numeros: [i32 ; 4] = [0 , -10 , -20 , 100];\n    let tupla: (String , [i32 ; 4]) = (\"Hello pepe\".to_string() , numeros);\n\n    println!(\"La cadena de la tupla dice: {}\" , tupla.0);\n\n    let mut suma_total: i32 = 0;\n    for number in 0..tupla.1.len(){\n        suma_total += tupla.1[number];\n\n    }\n\n    println!(\"{}\" , suma_total);\n    \n\n\n\n}","traces":[{"line":12,"address":[3226244,3219296,3227226],"length":1,"stats":{"Line":0}},{"line":16,"address":[3219324],"length":1,"stats":{"Line":0}},{"line":17,"address":[3219332],"length":1,"stats":{"Line":0}},{"line":18,"address":[3219389],"length":1,"stats":{"Line":0}},{"line":19,"address":[3219394,3219465],"length":1,"stats":{"Line":0}},{"line":20,"address":[3219566],"length":1,"stats":{"Line":0}},{"line":22,"address":[3219724],"length":1,"stats":{"Line":0}},{"line":23,"address":[3219850],"length":1,"stats":{"Line":0}},{"line":24,"address":[3219976],"length":1,"stats":{"Line":0}},{"line":25,"address":[3220102],"length":1,"stats":{"Line":0}},{"line":29,"address":[3220211],"length":1,"stats":{"Line":0}},{"line":30,"address":[3220238],"length":1,"stats":{"Line":0}},{"line":31,"address":[3220416,3220345],"length":1,"stats":{"Line":0}},{"line":35,"address":[3220485],"length":1,"stats":{"Line":0}},{"line":37,"address":[3220501],"length":1,"stats":{"Line":0}},{"line":39,"address":[3220578,3220508],"length":1,"stats":{"Line":0}},{"line":43,"address":[3220597],"length":1,"stats":{"Line":0}},{"line":47,"address":[3220725],"length":1,"stats":{"Line":0}},{"line":48,"address":[3220887],"length":1,"stats":{"Line":0}},{"line":50,"address":[3220858,3227167],"length":1,"stats":{"Line":0}},{"line":55,"address":[3220906],"length":1,"stats":{"Line":0}},{"line":56,"address":[3220928],"length":1,"stats":{"Line":0}},{"line":58,"address":[3221024],"length":1,"stats":{"Line":0}},{"line":59,"address":[3221052],"length":1,"stats":{"Line":0}},{"line":64,"address":[3221148],"length":1,"stats":{"Line":0}},{"line":65,"address":[3221226,3221293],"length":1,"stats":{"Line":0}},{"line":70,"address":[3221448],"length":1,"stats":{"Line":0}},{"line":72,"address":[3221483],"length":1,"stats":{"Line":0}},{"line":74,"address":[3221601,3221534],"length":1,"stats":{"Line":0}},{"line":77,"address":[3221620],"length":1,"stats":{"Line":0}},{"line":80,"address":[3221748],"length":1,"stats":{"Line":0}},{"line":82,"address":[3221818],"length":1,"stats":{"Line":0}},{"line":83,"address":[3221833,3221924],"length":1,"stats":{"Line":0}},{"line":85,"address":[3221931,3221999],"length":1,"stats":{"Line":0}},{"line":89,"address":[3219303],"length":1,"stats":{"Line":0}},{"line":90,"address":[3222076],"length":1,"stats":{"Line":0}},{"line":92,"address":[3222083,3222153],"length":1,"stats":{"Line":0}},{"line":94,"address":[3222172],"length":1,"stats":{"Line":0}},{"line":97,"address":[3222300],"length":1,"stats":{"Line":0}},{"line":98,"address":[3222474],"length":1,"stats":{"Line":0}},{"line":100,"address":[3222445,3227019],"length":1,"stats":{"Line":0}},{"line":105,"address":[3222488,3222536],"length":1,"stats":{"Line":0}},{"line":106,"address":[3222563,3222522],"length":1,"stats":{"Line":0}},{"line":110,"address":[3222666],"length":1,"stats":{"Line":0}},{"line":112,"address":[3222745,3226993],"length":1,"stats":{"Line":0}},{"line":113,"address":[3226991],"length":1,"stats":{"Line":0}},{"line":114,"address":[3226998,3222933],"length":1,"stats":{"Line":0}},{"line":118,"address":[3222971],"length":1,"stats":{"Line":0}},{"line":119,"address":[3223144,3226841],"length":1,"stats":{"Line":0}},{"line":125,"address":[3223159],"length":1,"stats":{"Line":0}},{"line":127,"address":[3223204],"length":1,"stats":{"Line":0}},{"line":131,"address":[3223302,3223231],"length":1,"stats":{"Line":0}},{"line":136,"address":[3223592,3223403],"length":1,"stats":{"Line":0}},{"line":139,"address":[3223599],"length":1,"stats":{"Line":0}},{"line":140,"address":[3223610],"length":1,"stats":{"Line":0}},{"line":141,"address":[3226807,3226747,3223804],"length":1,"stats":{"Line":0}},{"line":142,"address":[3226777,3226812],"length":1,"stats":{"Line":0}},{"line":146,"address":[3223821],"length":1,"stats":{"Line":0}},{"line":151,"address":[3223960],"length":1,"stats":{"Line":0}},{"line":153,"address":[3224015],"length":1,"stats":{"Line":0}},{"line":155,"address":[3224026,3226713],"length":1,"stats":{"Line":0}},{"line":156,"address":[3224199,3226643,3226718],"length":1,"stats":{"Line":0}},{"line":159,"address":[3224214],"length":1,"stats":{"Line":0}},{"line":164,"address":[3224310],"length":1,"stats":{"Line":0}},{"line":165,"address":[3224365],"length":1,"stats":{"Line":0}},{"line":167,"address":[3224420],"length":1,"stats":{"Line":0}},{"line":170,"address":[3226596,3224442],"length":1,"stats":{"Line":0}},{"line":171,"address":[3224615],"length":1,"stats":{"Line":0}},{"line":172,"address":[3226401,3226556,3224626],"length":1,"stats":{"Line":0}},{"line":174,"address":[3226609,3226537,3226589],"length":1,"stats":{"Line":0}},{"line":177,"address":[3224641],"length":1,"stats":{"Line":0}},{"line":178,"address":[3226258,3224814],"length":1,"stats":{"Line":0}},{"line":184,"address":[3224829],"length":1,"stats":{"Line":0}},{"line":186,"address":[3224964],"length":1,"stats":{"Line":0}},{"line":187,"address":[3225017],"length":1,"stats":{"Line":0}},{"line":190,"address":[3225095,3225024],"length":1,"stats":{"Line":0}},{"line":193,"address":[3225190],"length":1,"stats":{"Line":0}},{"line":195,"address":[3225260],"length":1,"stats":{"Line":0}},{"line":196,"address":[3225332,3225450],"length":1,"stats":{"Line":0}},{"line":198,"address":[3225358,3225306],"length":1,"stats":{"Line":0}},{"line":204,"address":[3225379],"length":1,"stats":{"Line":0}},{"line":205,"address":[3225423,3225471],"length":1,"stats":{"Line":0}},{"line":207,"address":[3225519,3225586],"length":1,"stats":{"Line":0}},{"line":209,"address":[3225655],"length":1,"stats":{"Line":0}},{"line":210,"address":[3225666,3226218],"length":1,"stats":{"Line":0}},{"line":211,"address":[3225812,3226223,3226151],"length":1,"stats":{"Line":0}},{"line":215,"address":[3225827],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":87},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej01.rs"],"content":"\n    pub fn es_par(numero: i32) -\u003e bool {\n        numero % 2 == 0\n    }\n\n    #[test]\n    //#[should_panic] \n    fn probar (){\n        let number:i32 = 2;\n        let par:bool = es_par(number);\n        assert_eq!(par, true);\n    }\n   \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej02.rs"],"content":"\n    \n    pub fn es_primo (numero : i32) -\u003e bool{\n\n        if numero \u003e 1 {\n\n            //check if primo\n            if (numero % numero == 0) \u0026 (numero % 1 == 0){ \n                if numero % (numero/2) != 0 {\n                    true\n                }\n\n                else{\n                    false\n                }\n            } else {\n                false\n            }\n        }\n\n        else{\n            false\n        }\n\n    }\n\n    #[test]\n    fn testear(){\n       let number:i32 = 1;\n        let primo:bool = es_primo(number);\n\n         assert_eq!(primo, false);\n    }\n    \n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej03.rs"],"content":"\n\n    \n    pub fn suma_pares(arreglo:[i32; 10]) -\u003e i32{\n        \n        let mut suma_p:i32 = 0;\n        for number in arreglo.iter(){\n            if number % 2 == 0 {\n                suma_p += number;\n            }\n        }\n\n        suma_p\n    }\n\n    //#[test] \n    fn testear (){\n        let numeros:[i32; 10] = [1,2,3,4,5,6,7,8,9,10];\n        let resultado = suma_pares(numeros);\n\n        assert_eq!(resultado, 30);\n\n    }\n    \n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej04.rs"],"content":"\n\n\n    pub fn cant_impar (numbers:[i32 ; 10]) -\u003e u32{\n\n        let mut impares = 0;\n        for number in numbers.iter(){\n            if number % 2 != 0{\n                impares += 1;\n            }\n        }\n\n        impares\n    }\n\n\n# [should_panic]\n# [test]\nfn helper (){\n    let numeros:[i32 ; 10] = [1,2,3,4,5,6,7,8,9,10];\n    let numeros_impares = cant_impar(numeros);\n\n    assert_eq!(numeros_impares , 9);\n\n}\n\n    \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej05.rs"],"content":"\n\n    fn duplicar_valores(numbers:[f64 ; 5]) -\u003e [f64 ; 5]{\n\n        let mut new_array :[f64 ; 5] = [0.0,0.0,0.0,0.0,0.0];\n\n        for n in 0 .. numbers.len(){\n            new_array[n] = numbers[n] * 2.0;\n\n        }\n\n        new_array\n\n    }\n\n\n //# [should_panic]\n # [test]\nfn helper(){\n    let numeros:[f64 ; 5] = [0.0 , 1.1 , 2.2 , 3.3 , 4.4];\n    let doble_numeros:[f64 ; 5] = duplicar_valores(numeros);\n\n    assert_eq!(doble_numeros[0] , 0.0)\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej06.rs"],"content":"\n\n\n\n    pub fn longitud_de_cadenas(strings:[String ; 3]) -\u003e [u32 ; 3]{\n\n        let mut longitudes:[u32 ; 3] = [0 , 0 , 0];\n        for n in 0..strings.len(){\n            longitudes[n] = strings[n].len() as u32;\n        }\n\n        longitudes\n\n    }\n      \n\n# [should_panic]\n# [test]\nfn tester (){\n    let arreglo_strings:[String ; 3] = [String::from(\"Hello\") , String::from(\"world\") , String::from(\"!\")]; \n    let output:[u32 ; 3] = longitud_de_cadenas (arreglo_strings);\n\n    assert_eq!(output[0] , 8); \n}\n   \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej07.rs"],"content":"\n\n\n    pub fn cant_mayores(numbers:[i32 ; 10] , limite:i32 ) -\u003e u32{\n\n        let mut cant_mayor = 0;\n        for number in numbers.iter(){\n            if number \u003e \u0026limite{ \n                cant_mayor += 1;\n            }\n        }\n\n        cant_mayor\n\n    }\n\n    # [should_panic]\n    # [test]\n    fn testear(){\n        let numeros:[i32 ; 10] = [-5 , 800 , -30, -2 , -1 , 0 , 244 , 9999 , 11 , 12];\n        let limite = 0;\n    \n        let cant_num_mayores = cant_mayores (numeros , limite);\n    \n        assert_eq!(cant_num_mayores , 9); \n    }\n    \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej08.rs"],"content":"\n\n\n\n\n    pub fn sumar_arreglos(array1:[f64 ; 2] , array2:[f64 ; 2]) -\u003e [f64 ; 2]{\n\n        let mut results:[f64 ; 2]= [0.0 , 0.0];\n\n        for n in 0..array1.len(){\n            results[n] = array1[n] + array2[n];\n        }\n\n        results\n    }\n\n//# [should_panic]\n# [test]\nfn testear(){\n    let numbers1:[f64 ; 2]= [0.0 , 25.2];\n    let numbers2:[f64 ; 2]= [-2.4 , 3.1];\n\n    let sums:[f64 ; 2]= sumar_arreglos(numbers1 , numbers2);\n\n    assert_eq!(sums[0] , -2.4);\n    assert_eq!(sums[1] , 28.3);\n}\n    \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej09.rs"],"content":"\n\n\n    pub fn cantidad_en_rango (array:[i32 ; 10] , inferior: i32 , superior: i32) -\u003e u32{\n        let mut cant_num:u32 = 0;\n\n        for number in array.iter(){\n            if \u0026inferior \u003c= number \u0026\u0026 number \u003c= \u0026superior{\n                cant_num += 1;\n            }\n        }\n\n        cant_num\n    }\n\n#[should_panic]\n#[test]\nfn testear(){\n    let numbers:[i32 ; 10]= [0,1,2,3,4,5,6,7,8,9];\n    let inferior = 1;\n    let superior = 5;\n\n    let cant_numeros_entre = cantidad_en_rango(numbers , inferior , superior);\n\n    assert_eq!(cant_numeros_entre , 9);\n}\n   \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej10.rs"],"content":"\n\n\n    pub fn cantidad_de_cadenas_mayor_a (array:[String ; 4] , limite: u32) -\u003e u32{\n        let mut cant_result:u32 = 0;\n\n        for element in array.iter(){\n            if element.len() as u32 \u003e limite{\n                cant_result += 1;\n            }\n        }\n\n        cant_result\n\n    }\n\n//#[should_panic]\n#[test]\nfn testear(){\n    let strings:[String ; 4] = [String::from(\"Hello\") , String::from(\"Abracadabra\") , String::from(\"Eye\") , String::from(\"Banana\")];\n    let limite:u32 = 4;\n\n    let cant_cumplen = cantidad_de_cadenas_mayor_a(strings , limite);\n\n    assert_eq!(cant_cumplen , 3);\n}\n\n    \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej11.rs"],"content":"\n\n\n\n    pub fn multiplicar_valores ( array: \u0026mut [i32 ; 5] , factor: i32){\n        \n        for number in array.iter_mut(){\n            *number = *number * factor; \n        }\n\n    }\n\n//#[should_panic]\n#[test]\nfn testear(){\n    let mut numbers:[i32 ; 5] = [1 , 2 , 3 , 4 , 5];\n    let factor: i32 = -1;\n\n    multiplicar_valores(\u0026mut numbers , factor); \n\n    assert_eq!(numbers[0] , -1);\n}\n\n    \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej12.rs"],"content":"\n\n\n    pub fn reemplazar_pares (array:\u0026mut[i32 ; 10]){\n\n        for number in array.iter_mut(){\n            if *number % 2 == 0 {\n                *number = -1;\n            }\n        }\n    }\n\n//# [should_panic]\n#[test]\nfn testear(){\n    let mut numbers:[i32 ; 10] = [1,2,3,4,5,6,7,8,9,10];\n    reemplazar_pares (\u0026mut numbers);\n\n    assert_eq!(numbers[1] , -1);\n}\n   \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej13.rs"],"content":"\n\n\n\n\n    pub fn ordenar_nombres (array: \u0026mut[String; 7]){ \n        array.sort();\n\n    }\n\n//#[should_panic]\n#[test]\nfn testear(){\n    let mut names:[String ; 7] = [String::from(\"Juli\") , String::from(\"Benja\") , String::from(\"Gonza\") , String::from(\"Fio\") , String::from(\"Angi\") , String::from(\"Emi\") , String::from(\"Angel\")];\n\n    ordenar_nombres (\u0026mut names);\n\n    assert_eq!(names[0] , \"Angel\");\n}\n   \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej14.rs"],"content":"//# [should_panic]\n//#[test]\n\n\n\n    pub fn incrementar (number: \u0026mut f64){\n        *number = *number + 1.0;\n    }\n\n//# [should_panic]\n#[test]\nfn testear(){\n    let mut number:f64 = 0.0;\n    incrementar (\u0026mut number);\n\n    assert_eq!(number , 1.0);\n}\n\n  ","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05; \npub mod ej06;\npub mod ej07;\npub mod ej08;\npub mod ej09;\npub mod ej10;\npub mod ej11;\npub mod ej12;\npub mod ej13;\npub mod ej14;","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej01.rs"],"content":"struct Persona {\n    edad: u32,\n    nombre: String,\n    direccion: Option\u003cString\u003e,\n}\n\nimpl Persona {\n    fn new (edad: u32, nombre: String, direccion: Option\u003cString\u003e) -\u003e Persona {\n        Persona {\n            edad,\n            nombre,\n            direccion,\n        }\n    }\n\n    fn to_string (\u0026self) -\u003e String {\n        let direction_str = if let Some(dir) = \u0026self.direccion{\n            dir.as_str()\n        } else {\n            \"None\"\n        };\n\n        format! (\"Name: {}, age: {}, direction: {}\", self.nombre, self.edad, direction_str)\n    }\n\n    fn obtener_edad (\u0026self) -\u003e u32 {\n        self.edad\n    }\n\n    fn actualizar_direccion (\u0026mut self, new_direction: Option\u003cString\u003e){\n        self.direccion = new_direction;\n    }\n\n}\n\n//# [should_panic]\n# [test]\nfn tester(){\n    let mut me_without_direction = Persona::new (19, String::from(\"Julieta\"), None);\n    let mut me_with_direction = Persona::new (19, String::from(\"Julieta\"), Some (String::from(\"Salto\")));\n\n    let message1 = me_with_direction.to_string();\n    //println!(\"{}\", message1); \n    println!(\"{}\", me_without_direction.to_string());\n\n    assert_eq!(me_with_direction.obtener_edad(), 19);\n\n    me_with_direction.actualizar_direccion(Some(String::from(\"La Plata/Salto\")));\n    println!(\"{}\", me_with_direction.to_string());\n}","traces":[{"line":8,"address":[3282048],"length":1,"stats":{"Line":1}},{"line":16,"address":[3282112],"length":1,"stats":{"Line":1}},{"line":17,"address":[3282141],"length":1,"stats":{"Line":1}},{"line":18,"address":[3282199],"length":1,"stats":{"Line":1}},{"line":20,"address":[3282216],"length":1,"stats":{"Line":1}},{"line":23,"address":[3282241],"length":1,"stats":{"Line":1}},{"line":26,"address":[3282464],"length":1,"stats":{"Line":1}},{"line":27,"address":[3282469],"length":1,"stats":{"Line":1}},{"line":30,"address":[3282480,3282545],"length":1,"stats":{"Line":1}},{"line":31,"address":[3282580,3282498],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej02.rs"],"content":"struct Rectangulo {\n    longitud: f64,\n    ancho: f64,\n}\n\nimpl Rectangulo {\n\n    fn new (ancho: f64, longitud: f64) -\u003e Rectangulo {\n        Rectangulo{\n            longitud,\n            ancho,\n        }\n    }\n\n    fn calcular_area (\u0026self) -\u003e f64 {\n        self.longitud * self.ancho\n    }\n\n    fn calcular_perimetro (\u0026self) -\u003e f64 {\n        2.0 * (self.longitud + self.ancho)\n    }\n\n    fn es_cuadrado (\u0026self) -\u003e bool {\n        self.longitud == self.ancho\n    }\n}\n\n//#[should_panic]\n#[test]\nfn tester() {\n    let rectangle = Rectangulo::new(2.0, 2.0);\n    assert_eq!(rectangle.calcular_area(), 4.0);\n    assert_eq!(rectangle.calcular_perimetro(), 8.0);\n    assert_eq!(rectangle.es_cuadrado(), true);\n}","traces":[{"line":8,"address":[3125888],"length":1,"stats":{"Line":1}},{"line":15,"address":[3125920],"length":1,"stats":{"Line":1}},{"line":16,"address":[3125925],"length":1,"stats":{"Line":1}},{"line":19,"address":[3125936],"length":1,"stats":{"Line":1}},{"line":20,"address":[3125941],"length":1,"stats":{"Line":1}},{"line":23,"address":[3125968],"length":1,"stats":{"Line":1}},{"line":24,"address":[3125973],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej03.rs"],"content":"use serde::{Serialize, Deserialize};\n#[derive(Clone, Serialize, Deserialize)]\npub struct Fecha {\n    pub dia: u32,\n    pub mes: u32,\n    pub año: u32,\n}\n\nimpl Fecha {\n    pub fn new (dia: u32, mes: u32, año: u32) -\u003e Fecha {\n        Fecha {\n            dia,\n            mes,\n            año,\n        }\n    }\n\n    fn es_bisiesto (\u0026self) -\u003e bool {\n        // A year is a leap year if:\n        // 1. It is divisible by 4, and\n        // 2. It is not divisible by 100, unless it is also divisible by 400.\n        self.año % 4 == 0 \u0026\u0026 self.año % 100 != 0 || self.año % 400 == 0\n    }\n\n    fn es_fecha_valida (\u0026self) -\u003e bool {\n        let days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n        if self.mes \u003c 1 || self.mes \u003e 12 { \n            return false;\n        }\n\n        let mut max_days = days_in_month[self.mes as usize];\n\n        if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n            max_days = 29;\n        }\n\n        self.dia \u003e= 1 \u0026\u0026 self.dia \u003c= max_days\n    }\n\n    pub fn sumar_dias (\u0026mut self, mut days: u32) {\n        let days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let mut days_in_current_month = days_in_month[self.mes as usize];\n\n        if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n            days_in_current_month = 29;\n        }\n\n        //Calculate the remaining days in the current month.\n        let mut remaining_days_in_month = days_in_current_month - self.dia;\n\n        while days \u003e remaining_days_in_month {\n            days -= remaining_days_in_month + 1; //+1 ensures that the current day is included when transitioning to the next month.\n\n            self.dia = 1; //Move to the next month.\n            self.mes += 1;\n\n            if self.mes \u003e 12 {\n                self.año += 1;\n                self.mes = 1;\n            }\n\n            //Recalculate the days in the current month.\n            days_in_current_month = days_in_month[self.mes as usize];\n            if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n                days_in_current_month = 29;\n            } \n\n            remaining_days_in_month = days_in_current_month - self.dia;\n        }\n        self.dia += days;  \n    }\n\n    fn restar_dias (\u0026mut self, mut days: u32) {\n        let days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let mut days_in_current_month = days_in_month[self.mes as usize];\n\n        if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n            days_in_current_month = 29;\n        }\n\n        while days \u003e= self.dia { // While the number of days to subtract is greater than or equal to the current day.\n            days -= self.dia; \n\n            self.mes -= 1;\n            if self.mes \u003c 1 {\n                self.año -= 1;\n                self.mes = 12;\n            }   \n\n            // Recalculate the days in the current month.\n            days_in_current_month = days_in_month[self.mes as usize];\n            if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n                days_in_current_month = 29;\n            } \n\n            self.dia = days_in_current_month; // Move to the end of the previous month.\n        }\n\n        self.dia -= days; // Subtract the remaining days.\n\n    }\n\n    pub fn es_mayor (\u0026self, other: \u0026Fecha) -\u003e bool { //Retorna true si la fecha que recibí es mayor.\n\n        //First check the year.\n        if other.año \u003c self.año {\n            return true;\n        } else if other.año \u003e self.año {\n            return false;\n        }\n\n        //Check month.\n        if other.mes \u003c self.mes {\n            return true;\n        } else if other.mes \u003e self.mes {\n            return false;\n        }\n\n        //If months are equal, compare day.\n        other.dia \u003c self.dia\n    }\n}\n\n\n\n#[cfg(test)]\nmod tests{\n    use super::*;\n\n    #[test]\n    fn test_es_fecha_valida() {\n        let mut date1 = Fecha {\n            dia: 12,\n            mes: 5,\n            año: 2006,\n        };\n        assert_eq!(date1.es_fecha_valida(), true);\n\n        let mut date2 = Fecha::new(21, 13, 2024);\n        assert_eq!(date2.es_fecha_valida(), false);\n    }\n\n    #[test]\n    fn test_es_bisiesto() {\n        let mut date1 = Fecha {\n            dia: 12,\n            mes: 5,\n            año: 2006,\n        };\n        assert_eq!(date1.es_bisiesto(), false);\n\n        let mut date2 = Fecha::new(21, 12, 2024);\n        assert_eq!(date2.es_bisiesto(), true);\n    }\n\n    #[test]\n    fn test_sumar_dias() {\n        let mut date1 = Fecha {\n            dia: 1,\n            mes: 5,\n            año: 2006,\n        };\n\n        date1.sumar_dias(0);\n        assert_eq!(date1.dia, 1);\n\n        date1.sumar_dias(31); //Se pasa de mes.\n        assert_eq!(date1.dia, 1);\n        assert_eq!(date1.mes, 6);\n\n        date1.sumar_dias(250); //se pasa de año. (Quedaría en Feb 6 2007).\n        assert_eq!(date1.dia, 6);\n        assert_eq!(date1.mes, 2);\n        assert_eq!(date1.año, 2007);\n    }\n\n    #[test]\n    fn test_restar_dias() {\n        let mut date1 = Fecha {\n            dia: 10,\n            mes: 5,\n            año: 2006,\n        };\n\n        date1.restar_dias(5); //Solo cambia el día.\n        assert_eq!(date1.dia, 5);\n\n        date1.restar_dias(10); //Quedaría en 25/04/2006\n        assert_eq!(date1.dia, 25);\n        assert_eq!(date1.mes, 4);\n        assert_eq!(date1.año, 2006);\n\n        date1.restar_dias(200); //07/10/2005\n        assert_eq!(date1.dia, 7);\n        assert_eq!(date1.mes, 10);\n        assert_eq!(date1.año, 2005);\n    }\n\n    #[test]\n    fn test_es_mayor() {\n        let date1= Fecha::new(12, 5, 2006);\n        let date2= Fecha::new(31, 12, 2006);\n        let date3= Fecha::new(1, 1, 2005);\n\n        assert_eq!(date1.es_mayor(\u0026date2), false);\n        assert_eq!(date1.es_mayor(\u0026date3), true);\n    }\n\n\n}\n","traces":[{"line":10,"address":[2737152],"length":1,"stats":{"Line":1}},{"line":18,"address":[2737184],"length":1,"stats":{"Line":1}},{"line":22,"address":[2737194],"length":1,"stats":{"Line":1}},{"line":25,"address":[2737280],"length":1,"stats":{"Line":1}},{"line":26,"address":[2737294],"length":1,"stats":{"Line":1}},{"line":28,"address":[2737398],"length":1,"stats":{"Line":1}},{"line":29,"address":[2737415],"length":1,"stats":{"Line":1}},{"line":32,"address":[2737430,2737472],"length":1,"stats":{"Line":1}},{"line":34,"address":[2737460,2737495,2737524],"length":1,"stats":{"Line":1}},{"line":35,"address":[2737516],"length":1,"stats":{"Line":0}},{"line":38,"address":[2737526,2737509],"length":1,"stats":{"Line":1}},{"line":41,"address":[2737568],"length":1,"stats":{"Line":1}},{"line":42,"address":[2737592],"length":1,"stats":{"Line":1}},{"line":43,"address":[2737696,2737741],"length":1,"stats":{"Line":1}},{"line":45,"address":[2737806,2737728,2737764],"length":1,"stats":{"Line":1}},{"line":46,"address":[2737798],"length":1,"stats":{"Line":0}},{"line":50,"address":[2737778,2737812,2737818],"length":1,"stats":{"Line":2}},{"line":52,"address":[2737816,2737831,2738211],"length":1,"stats":{"Line":3}},{"line":53,"address":[2737984,2737917,2737863],"length":1,"stats":{"Line":2}},{"line":55,"address":[2737961],"length":1,"stats":{"Line":1}},{"line":56,"address":[2737967,2738006,2738017],"length":1,"stats":{"Line":2}},{"line":58,"address":[2738009,2738090],"length":1,"stats":{"Line":2}},{"line":59,"address":[2738092,2738056],"length":1,"stats":{"Line":1}},{"line":60,"address":[2738083],"length":1,"stats":{"Line":1}},{"line":64,"address":[2738136,2738035,2738115],"length":1,"stats":{"Line":2}},{"line":65,"address":[2738159,2738201,2738123],"length":1,"stats":{"Line":2}},{"line":66,"address":[2738193],"length":1,"stats":{"Line":0}},{"line":69,"address":[2738173,2738207,2738216],"length":1,"stats":{"Line":2}},{"line":71,"address":[2737900,2737846,2737890],"length":1,"stats":{"Line":2}},{"line":74,"address":[2738240],"length":1,"stats":{"Line":1}},{"line":75,"address":[2738258],"length":1,"stats":{"Line":1}},{"line":76,"address":[2738362,2738407],"length":1,"stats":{"Line":1}},{"line":78,"address":[2738394,2738462,2738430],"length":1,"stats":{"Line":1}},{"line":79,"address":[2738454],"length":1,"stats":{"Line":0}},{"line":82,"address":[2738772,2738444],"length":1,"stats":{"Line":2}},{"line":83,"address":[2738575,2738552,2738494],"length":1,"stats":{"Line":2}},{"line":85,"address":[2738608,2738556,2738597],"length":1,"stats":{"Line":2}},{"line":86,"address":[2738600,2738683],"length":1,"stats":{"Line":2}},{"line":87,"address":[2738647,2738685],"length":1,"stats":{"Line":1}},{"line":88,"address":[2738676],"length":1,"stats":{"Line":1}},{"line":92,"address":[2738729,2738626,2738708],"length":1,"stats":{"Line":2}},{"line":93,"address":[2738785,2738716,2738752],"length":1,"stats":{"Line":2}},{"line":94,"address":[2738777],"length":1,"stats":{"Line":0}},{"line":97,"address":[2738766],"length":1,"stats":{"Line":1}},{"line":100,"address":[2738469,2738530,2738523],"length":1,"stats":{"Line":2}},{"line":104,"address":[2738800],"length":1,"stats":{"Line":1}},{"line":107,"address":[2738820],"length":1,"stats":{"Line":1}},{"line":108,"address":[2738848],"length":1,"stats":{"Line":1}},{"line":109,"address":[2738838],"length":1,"stats":{"Line":1}},{"line":110,"address":[2738875],"length":1,"stats":{"Line":0}},{"line":114,"address":[2738865],"length":1,"stats":{"Line":1}},{"line":115,"address":[2738902],"length":1,"stats":{"Line":0}},{"line":116,"address":[2738892],"length":1,"stats":{"Line":1}},{"line":117,"address":[2738934],"length":1,"stats":{"Line":1}},{"line":121,"address":[2738919],"length":1,"stats":{"Line":2}}],"covered":48,"coverable":55},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej04.rs"],"content":"struct Triangulo {\n    lado1: f64,\n    lado2: f64,\n    lado3: f64,\n}\n\nimpl Triangulo {\n    fn new (lado1: f64, lado2: f64, lado3: f64) -\u003e Triangulo {\n        Triangulo { \n            lado1,\n            lado2,\n            lado3,\n        }\n    }\n\n    fn determinar_tipo (\u0026self) -\u003e String {\n        if self.lado1 == self.lado2 \u0026\u0026 self.lado2 == self.lado3 {\n            String::from(\"Equilateral\")\n        } else {\n            if (self.lado1 == self.lado2 \u0026\u0026 self.lado2 != self.lado3) || (self.lado1 == self.lado3 \u0026\u0026 self.lado3 != self.lado2) || (self.lado2 == self.lado3 \u0026\u0026 self.lado2 != self.lado1){\n                String::from(\"Isosceles\")\n            } else {\n                String::from(\"Scalene\")\n            }\n        }\n    }\n\n    fn calcular_area (\u0026self) -\u003e f64 {\n        let s = (self.lado1 + self.lado2 + self.lado3) / 2.0; // Semi-perimeter\n        let area = (s * (s - self.lado1) * (s - self.lado2) * (s - self.lado3)).sqrt(); // Heron's formula\n        area\n    }\n\n    fn calcular_perimetro (\u0026self) -\u003e f64 {\n        self.lado1 + self.lado2 + self.lado3\n    }\n}\n\n//#[should_panic]\n#[test]\nfn tester() {\n    let triangle = Triangulo::new(2.0, 2.0, 2.0);\n    assert_eq!(triangle.determinar_tipo(), String::from(\"Equilateral\"));\n    assert_eq!(triangle.calcular_perimetro(), 6.0);\n\n}","traces":[{"line":8,"address":[2844304],"length":1,"stats":{"Line":1}},{"line":16,"address":[2844352],"length":1,"stats":{"Line":1}},{"line":17,"address":[2844376,2844416],"length":1,"stats":{"Line":2}},{"line":18,"address":[2844435],"length":1,"stats":{"Line":1}},{"line":20,"address":[2844462,2844593,2844396,2844527],"length":1,"stats":{"Line":0}},{"line":21,"address":[2844503],"length":1,"stats":{"Line":0}},{"line":23,"address":[2844569],"length":1,"stats":{"Line":0}},{"line":28,"address":[2844624],"length":1,"stats":{"Line":0}},{"line":29,"address":[2844632],"length":1,"stats":{"Line":0}},{"line":30,"address":[2844664],"length":1,"stats":{"Line":0}},{"line":34,"address":[2844720],"length":1,"stats":{"Line":1}},{"line":35,"address":[2844725],"length":1,"stats":{"Line":1}}],"covered":6,"coverable":12},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej05.rs"],"content":"struct Producto {\n    nombre: String,\n    precio_bruto: f64,\n    id: u32,\n}\n\nimpl Producto {\n    fn new(nombre: String, precio_bruto: f64, id: u32) -\u003e Producto {\n        Producto {\n            nombre,\n            precio_bruto,\n            id,\n        }\n    }\n\n    fn calcular_impuestos(\u0026self, tax_percentage: f64) -\u003e f64 {\n        (tax_percentage/100.0)/self.precio_bruto\n    }\n\n    fn aplicar_descuento(\u0026self, discount_percentage: f64) -\u003e f64 {\n        (discount_percentage/100.0)/self.precio_bruto\n    }\n\n    fn calcular_precio_total(\u0026self, tax_percentage: Option\u003cf64\u003e, discount_percentage: Option\u003cf64\u003e) -\u003e f64 {\n        let tax = tax_percentage.map(|t| t/100.0).unwrap_or(0.0); \n        let discount= discount_percentage.map(|d| d/100.0).unwrap_or(0.0);\n        self.precio_bruto+tax-discount\n    }\n}\n\n#[cfg(test)]\nmod tests{\n    use super::*;\n\n    #[test]\n    fn test_calculate_taxes() {\n        let product= Producto::new(String::from(\"Agua.\"), 500.0, 123);\n        assert_eq!(product.calcular_impuestos(100.0), 0.002);\n    }\n\n    #[test]\n    fn test_apply_discount() {\n        let product= Producto::new(String::from(\"Agua.\"), 500.0, 123);\n        assert_eq!(product.aplicar_descuento(0.0), 0.0);\n    }\n\n    #[test]\n    fn test_total_price() {\n        let product= Producto::new(String::from(\"Agua.\"), 500.0, 123);\n        assert_eq!(product.calcular_precio_total(None, None), 500.0);\n        assert_eq!(product.calcular_precio_total(Some(500.0), Some(250.0)),502.5);\n    }\n\n}\n\n\n\n","traces":[{"line":8,"address":[3015088],"length":1,"stats":{"Line":3}},{"line":16,"address":[3015136],"length":1,"stats":{"Line":1}},{"line":17,"address":[3015147],"length":1,"stats":{"Line":1}},{"line":20,"address":[3015168],"length":1,"stats":{"Line":1}},{"line":21,"address":[3015179],"length":1,"stats":{"Line":1}},{"line":24,"address":[3015200],"length":1,"stats":{"Line":1}},{"line":25,"address":[3002886,3002880],"length":1,"stats":{"Line":3}},{"line":26,"address":[3002918,3002912],"length":1,"stats":{"Line":3}},{"line":27,"address":[3015338],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej07.rs"],"content":"#[derive(Clone)]\n\nenum Color {\n    ROJO,\n    VERDE, \n    AZUL,\n    AMARILLO,\n    BLANCO,\n    NEGRO,\n}\n#[derive(Clone)]\nstruct Auto {\n    color: Color,\n    marca: String,\n    modelo: String,\n    precio_bruto: f64,\n    año: u32,\n}\n\nstruct ConsecionarioAuto {\n    nombre: String,\n    direccion: String,\n    x: u32,\n    autos: Vec\u003cAuto\u003e,\n}\n\n\n\npub fn compare_colors(color1: \u0026Color, color2: \u0026Color) -\u003e bool {\n    match(color1, color2) {\n        (Color::AMARILLO, Color::AMARILLO) =\u003e true,\n        (Color::AZUL, Color::AZUL) =\u003e true,\n        (Color::VERDE, Color::VERDE) =\u003e true,\n        (Color::ROJO, Color::ROJO) =\u003e true,\n        (Color::NEGRO, Color::NEGRO) =\u003e true,\n        (Color::BLANCO, Color::BLANCO) =\u003e true,\n        _ =\u003e false, //If the variants are different, they are not equal\n    }\n}\n\npub fn compare (auto1: \u0026Auto, auto2: \u0026Auto) -\u003e bool {\n    auto1.año == auto2.año \u0026\u0026\n    auto1.marca == auto2.marca \u0026\u0026\n    auto1.modelo == auto2.modelo \u0026\u0026\n    auto1.precio_bruto == auto2.precio_bruto \u0026\u0026\n    compare_colors(\u0026auto1.color, \u0026auto2.color)\n\n}\n\nimpl ConsecionarioAuto {\n    fn new(nombre: String, direccion: String, x: u32) -\u003e ConsecionarioAuto {\n        ConsecionarioAuto {\n            nombre,\n            direccion,\n            x,\n            autos: Vec::new(),\n        }\n    }\n\n    fn agregar_auto(\u0026mut self, auto: \u0026Auto) -\u003e bool {\n        if self.autos.len()+1 \u003c= self.x.try_into().unwrap() {\n            self.autos.push(auto.clone());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    fn eliminar_auto(\u0026mut self, auto: \u0026Auto) {\n        //Find the car I want to delete in the vec.\n        let mut index_car_delete= -1;\n        for i in 0.. self.autos.len() {\n            if compare(\u0026self.autos[i], \u0026auto) {\n                index_car_delete= i as i32;\n                break;\n            }  \n        }\n        //Delete the car.\n        if index_car_delete != -1 { //If I found the car to delete.\n            self.autos.remove(index_car_delete as usize);\n        }\n    }\n\n    fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\n        for car in self.autos.iter() {\n            if compare(\u0026car, \u0026auto) {\n                return Some(car);\n            }\n        }\n        None //If I didn't find it, return nothing (None).\n    }\n}\n\nimpl Auto {\n    fn new(marca: String, modelo: String, precio_bruto: f64, año: u32, color: Color ) -\u003e Auto {\n        Auto {\n            marca,\n            modelo,\n            precio_bruto,\n            año,\n            color,\n        }\n    }\n\n    fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut precio_final= self.precio_bruto;\n\n        //Check first condition (color).\n        let es_primario = match self.color {\n            Color::AMARILLO | Color::AZUL | Color::ROJO =\u003e true,\n            _ =\u003e false,\n        };\n\n        if es_primario {\n            precio_final += (self.precio_bruto * 25.0)/100.0; //+25%.\n        } else {\n            precio_final -= (10.0*self.precio_bruto)/100.0; //-10%.\n        }\n\n        //Check second condition (brand).\n        if self.marca == \"BMW\" {\n            precio_final += (self.precio_bruto * 15.0)/100.0; //+15%.\n        }\n\n        //Check third condition (year).\n        if self.año \u003c 2000 {\n            precio_final -= (self.precio_bruto * 5.0)/100.0; //-5%.\n        }\n\n        precio_final\n    }\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_auto() {\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3);\n\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n        let auto4= Auto::new(String::from(\"Ferrari\"), String::from(\"modelo R\"), 1000.0, 2015, Color::ROJO);\n\n        concesionario.agregar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 1); //Added only 1 element.\n\n        //Fill all available space.\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.agregar_auto(\u0026auto3);\n        assert_eq!(concesionario.autos.len(), 3);\n\n        //Try to add one more.\n        assert_eq!(concesionario.agregar_auto(\u0026auto4), false);\n    }\n\n    #[test]\n    fn testear_eliminar_auto() {\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3);\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n\n        //First I try to delete a car from an empty list.\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //Passed. Nothing changed.\n\n        //Add cars to delete.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //yes.\n\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 1);\n    }\n    \n    #[test]\n    fn testear_buscar_auto() {\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3);\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n\n\n        //Try to find a car in an empty list.\n        assert!(concesionario.buscar_auto(\u0026auto1).is_none());\n\n        //Find a car that exists.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        assert!(concesionario.buscar_auto(\u0026auto2).is_some());\n\n        //Find a car that doesn't exist.\n        assert!(concesionario.buscar_auto(\u0026auto3).is_none());\n    }\n\n    #[test]\n    fn testear_calcular_precio() {\n        //Test brand (and not primary color).\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n        let auto2= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n\n        assert_eq!(auto1.calcular_precio(), 1050.0); \n        assert_eq!(auto2.calcular_precio(), 900.0);\n\n        //Test if primary color.\n        let auto3= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::AMARILLO);\n        assert_eq!(auto3.calcular_precio(), 1250.0);\n        \n        //Test year (withouth primary color).\n        let auto4= Auto::new(String::from(\"Cronos\"), String::from(\"modelo 1\"), 1000.0, 1999, Color::BLANCO);\n        assert_eq!(auto4.calcular_precio(), 850.0);\n    }\n\n}","traces":[{"line":29,"address":[3073798,3073744],"length":1,"stats":{"Line":1}},{"line":30,"address":[3073800,3073754],"length":1,"stats":{"Line":1}},{"line":41,"address":[3073952],"length":1,"stats":{"Line":1}},{"line":42,"address":[3073983,3073975],"length":1,"stats":{"Line":2}},{"line":43,"address":[3073999],"length":1,"stats":{"Line":1}},{"line":44,"address":[3074019],"length":1,"stats":{"Line":1}},{"line":45,"address":[3074047],"length":1,"stats":{"Line":1}},{"line":46,"address":[3074070],"length":1,"stats":{"Line":1}},{"line":51,"address":[3074326,3074112,3074348],"length":1,"stats":{"Line":1}},{"line":56,"address":[3074176],"length":1,"stats":{"Line":1}},{"line":60,"address":[3074368],"length":1,"stats":{"Line":1}},{"line":61,"address":[3074392],"length":1,"stats":{"Line":1}},{"line":62,"address":[3074491],"length":1,"stats":{"Line":1}},{"line":63,"address":[3074530],"length":1,"stats":{"Line":1}},{"line":65,"address":[3074474],"length":1,"stats":{"Line":1}},{"line":69,"address":[3074560],"length":1,"stats":{"Line":1}},{"line":71,"address":[3074585],"length":1,"stats":{"Line":1}},{"line":72,"address":[3074625,3074593],"length":1,"stats":{"Line":2}},{"line":73,"address":[3074680],"length":1,"stats":{"Line":1}},{"line":74,"address":[3074729],"length":1,"stats":{"Line":1}},{"line":79,"address":[3074715],"length":1,"stats":{"Line":1}},{"line":80,"address":[3074748],"length":1,"stats":{"Line":1}},{"line":84,"address":[3074800],"length":1,"stats":{"Line":1}},{"line":85,"address":[3074813,3074854],"length":1,"stats":{"Line":2}},{"line":86,"address":[3074907],"length":1,"stats":{"Line":1}},{"line":87,"address":[3074946],"length":1,"stats":{"Line":1}},{"line":90,"address":[3074927],"length":1,"stats":{"Line":1}},{"line":95,"address":[3074960],"length":1,"stats":{"Line":1}},{"line":105,"address":[3075040],"length":1,"stats":{"Line":1}},{"line":106,"address":[3075053],"length":1,"stats":{"Line":1}},{"line":109,"address":[3075064],"length":1,"stats":{"Line":1}},{"line":110,"address":[3075104],"length":1,"stats":{"Line":1}},{"line":111,"address":[3075097],"length":1,"stats":{"Line":1}},{"line":114,"address":[3075161,3075109],"length":1,"stats":{"Line":2}},{"line":115,"address":[3075167],"length":1,"stats":{"Line":1}},{"line":117,"address":[3075120],"length":1,"stats":{"Line":1}},{"line":121,"address":[3075280,3075208],"length":1,"stats":{"Line":2}},{"line":122,"address":[3075243],"length":1,"stats":{"Line":1}},{"line":126,"address":[3075338,3075228],"length":1,"stats":{"Line":2}},{"line":127,"address":[3075297],"length":1,"stats":{"Line":1}},{"line":130,"address":[3075282],"length":1,"stats":{"Line":1}}],"covered":41,"coverable":41},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej08.rs"],"content":"#[derive(Clone)]\nenum Genero {\n    ROCK,\n    POP,\n    JAZZ,\n    RAP,\n    OTROS,\n}\n\n#[derive(Clone)]\nstruct Cancion {\n    titulo: String,\n    artista: String,\n    genero: Genero,\n}\n\nstruct PlayList {\n    nombre: String,\n    canciones: Vec\u003cCancion\u003e,\n}\n\nimpl Cancion {\n    fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\n        Cancion {\n            titulo,\n            artista,\n            genero,\n        }\n    }\n}\n\npub fn compare_genre(genero1: \u0026Genero, genero2: \u0026Genero) -\u003e bool {\n    match (genero1, genero2) {\n        (Genero::JAZZ, Genero::JAZZ) =\u003e true,\n        (Genero::ROCK, Genero::ROCK) =\u003e true,\n        (Genero::RAP, Genero::RAP) =\u003e true,\n        (Genero::POP, Genero::POP) =\u003e true,\n        (Genero::OTROS, Genero::OTROS) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare (cancion1: \u0026Cancion, cancion2: \u0026Cancion) -\u003e bool {\n    cancion1.artista == cancion2.artista \u0026\u0026\n    cancion1.titulo == cancion2.titulo \u0026\u0026\n    compare_genre(\u0026cancion1.genero, \u0026cancion2.genero)\n\n}\n\nimpl PlayList {\n    fn new(nombre: String) -\u003e PlayList {\n        PlayList {\n            nombre,\n            canciones: Vec::new(),\n        }\n    }\n\n    fn agregar_cancion(\u0026mut self, cancion: \u0026Cancion) {\n        self.canciones.push(cancion.clone());\n    }\n\n    fn eliminar_cancion(\u0026mut self, cancion: \u0026Cancion) {\n        //Find the song I want to delete in the vec.\n        let mut index_song_delete= -1;\n        for i in 0.. self.canciones.len() {\n            if compare(\u0026self.canciones[i], \u0026cancion) {\n                index_song_delete= i as i32;\n                break;\n            }  \n        }\n        //Delete the car.\n        if index_song_delete != -1 { //If I found the car to delete.\n            self.canciones.remove(index_song_delete as usize);\n        }\n    }\n\n    fn mover_cancion(\u0026mut self, cancion: \u0026Cancion, posicion_nueva: u32){\n        if posicion_nueva \u003c self.canciones.len() as u32 {\n\n            //Search song in the playlist.\n            let mut song_index:i32= -1;\n            for i in 0..self.canciones.len() {\n                if compare(\u0026self.canciones[i], \u0026cancion) {\n                    song_index= i as i32;\n                    break;\n                }\n            }\n\n            if song_index != -1 { //If I found the song.\n                //Move the song to the new position.\n                let song = self.canciones.remove(song_index as usize);\n                self.canciones.insert(posicion_nueva as usize, song);\n            }\n        }\n    }\n\n    fn buscar_cancion_por_nombre(\u0026self, nombre: String) -\u003e Option\u003cCancion\u003e {\n        for song in self.canciones.iter() {\n            if (song.titulo == nombre) {\n                return Some(song.clone());\n            }\n        }\n        None\n    }\n\n    fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_genero= Vec::new();\n\n        for song in self.canciones.iter() {\n            if compare_genre(\u0026song.genero, \u0026genero) {\n                canciones_genero.push(song.clone());\n            }\n        }\n        canciones_genero\n    }\n\n    fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_artista= Vec::new();\n\n        for song in self.canciones.iter() {\n            if song.artista == artista {\n                canciones_artista.push(song.clone());\n            }\n        }\n\n        canciones_artista\n    }\n\n    fn modificar_titulo_playlist(\u0026mut self, titulo_nuevo: String) {\n        self.nombre= titulo_nuevo;\n    }\n\n    fn eliminar_todas_las_canciones(\u0026mut self) {\n        self.canciones.clear();\n    }\n }\n\n\n #[cfg(test)]\n\n mod test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        assert_eq!(playlist.canciones.len(), 3);\n    }\n\n    #[test]\n    fn testear_eliminar_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        \n        playlist.eliminar_cancion(\u0026cancion1); //Delete just 1 song.\n        assert_eq!(playlist.canciones.len(), 1);\n\n        //Try to delete a song that is not in the playlist.\n        playlist.eliminar_cancion(\u0026cancion3);\n        assert_eq!(playlist.canciones.len(), 1); //lenght shouldn't change.\n    }\n\n    #[test]\n    fn testear_buscar_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n\n        playlist.agregar_cancion(\u0026cancion1);\n\n        //Search for a song that is in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion1\")).is_some());\n\n        //Search for a song that is not in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion10\")).is_none());\n    }\n\n    #[test]\n    fn testear_eliminar_canciones() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        playlist.eliminar_todas_las_canciones();\n        assert_eq!(playlist.canciones.len(), 0);\n    }\n\n    #[test]\n    fn testear_mover_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); //Originally in pos 0 (in playlist).\n        playlist.agregar_cancion(\u0026cancion2); //Originally in pos 1 (in playlist).\n        playlist.agregar_cancion(\u0026cancion3); //Originally in pos 2 (in playlist).\n\n        //Check that.\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\"));\n\n        //Move a song that is in the playlist.\n        playlist.mover_cancion(\u0026cancion2, 2);\n        assert_eq!(playlist.canciones[2].titulo, String::from(\"Cancion2\"));\n\n        //Move a song that is not in the playlist.\n        playlist.mover_cancion(\u0026cancion4, 0);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n\n        //Move a song that is in the playlist to a non existing position.\n        playlist.mover_cancion(\u0026cancion1, 3);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n    }\n\n    #[test]\n    fn testear_cambiar_nombre_playlist() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        //Check that.\n        assert_eq!(playlist.nombre, String::from(\"Chill music\"));\n        \n        //Change the name.\n        playlist.modificar_titulo_playlist(String::from(\"Nombre nuevo\"));\n        assert_eq!(playlist.nombre, String::from(\"Nombre nuevo\"));\n    }\n\n    #[test]\n    fn testear_canciones_mismo_genero() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 jazz songs.\n        let mut jazz_songs: Vec\u003cCancion\u003e;\n        jazz_songs= playlist.obtener_canciones_por_genero(Genero::JAZZ);\n        assert_eq!(jazz_songs.len(), 2);\n\n        //Try with a genre that is not in the playlist.\n        let mut pop_songs= playlist.obtener_canciones_por_genero(Genero::POP);\n        assert_eq!(pop_songs.len(), 0);\n    }\n\n    #[test]\n    fn testear_canciones_mismo_artista() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 pepa songs.\n        let mut pepa_songs: Vec\u003cCancion\u003e;\n        pepa_songs= playlist.obtener_canciones_por_artista(String::from(\"pepa\"));\n        assert_eq!(pepa_songs.len(), 2);\n\n        //Try with an artist that is not in the playlist.\n        let mut titi_songs= playlist.obtener_canciones_por_artista(String::from(\"titi\"));\n        assert_eq!(titi_songs.len(), 0);\n    }\n }","traces":[{"line":23,"address":[2866800],"length":1,"stats":{"Line":2}},{"line":32,"address":[2866918,2866864],"length":1,"stats":{"Line":1}},{"line":33,"address":[2866874,2866920],"length":1,"stats":{"Line":2}},{"line":43,"address":[2867040],"length":1,"stats":{"Line":1}},{"line":44,"address":[2867063,2867080],"length":1,"stats":{"Line":2}},{"line":45,"address":[2867096],"length":1,"stats":{"Line":1}},{"line":46,"address":[2867116],"length":1,"stats":{"Line":1}},{"line":51,"address":[2867293,2867152],"length":1,"stats":{"Line":1}},{"line":54,"address":[2867187],"length":1,"stats":{"Line":1}},{"line":58,"address":[2867312],"length":1,"stats":{"Line":2}},{"line":59,"address":[2867326],"length":1,"stats":{"Line":3}},{"line":62,"address":[2867376],"length":1,"stats":{"Line":1}},{"line":64,"address":[2867398],"length":1,"stats":{"Line":1}},{"line":65,"address":[2867406,2867438],"length":1,"stats":{"Line":2}},{"line":66,"address":[2867492],"length":1,"stats":{"Line":1}},{"line":67,"address":[2867540],"length":1,"stats":{"Line":1}},{"line":72,"address":[2867527],"length":1,"stats":{"Line":1}},{"line":73,"address":[2867559],"length":1,"stats":{"Line":1}},{"line":77,"address":[2867600],"length":1,"stats":{"Line":1}},{"line":78,"address":[2867636],"length":1,"stats":{"Line":1}},{"line":81,"address":[2867666],"length":1,"stats":{"Line":1}},{"line":82,"address":[2867706,2867674],"length":1,"stats":{"Line":2}},{"line":83,"address":[2867760],"length":1,"stats":{"Line":1}},{"line":84,"address":[2867812],"length":1,"stats":{"Line":1}},{"line":89,"address":[2867795],"length":1,"stats":{"Line":1}},{"line":91,"address":[2867823],"length":1,"stats":{"Line":1}},{"line":92,"address":[2867858],"length":1,"stats":{"Line":1}},{"line":97,"address":[2868265,2867888],"length":1,"stats":{"Line":1}},{"line":98,"address":[2867931,2868003],"length":1,"stats":{"Line":2}},{"line":99,"address":[2868144,2868201],"length":1,"stats":{"Line":2}},{"line":100,"address":[2868222],"length":1,"stats":{"Line":1}},{"line":103,"address":[2868165],"length":1,"stats":{"Line":1}},{"line":106,"address":[2868288,2868700,2868694],"length":1,"stats":{"Line":1}},{"line":107,"address":[2868329],"length":1,"stats":{"Line":1}},{"line":109,"address":[2868339,2868407],"length":1,"stats":{"Line":2}},{"line":110,"address":[2868562,2868633],"length":1,"stats":{"Line":2}},{"line":111,"address":[2868655],"length":1,"stats":{"Line":1}},{"line":114,"address":[2868592],"length":1,"stats":{"Line":1}},{"line":117,"address":[2868720,2869176],"length":1,"stats":{"Line":1}},{"line":118,"address":[2868760],"length":1,"stats":{"Line":1}},{"line":120,"address":[2868813,2868878],"length":1,"stats":{"Line":2}},{"line":121,"address":[2869115,2869038],"length":1,"stats":{"Line":2}},{"line":122,"address":[2869137],"length":1,"stats":{"Line":1}},{"line":126,"address":[2869063],"length":1,"stats":{"Line":1}},{"line":129,"address":[2869260,2869200],"length":1,"stats":{"Line":1}},{"line":130,"address":[2869218,2869295],"length":1,"stats":{"Line":2}},{"line":133,"address":[2869328],"length":1,"stats":{"Line":1}},{"line":134,"address":[2869333],"length":1,"stats":{"Line":1}}],"covered":48,"coverable":48},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej09.rs"],"content":"use std::collections::VecDeque;\nuse crate::tp03::ej03::Fecha;\n\n\n\n#[derive(Clone)]\nenum TipoAnimal {\n    PERRO,\n    GATO,\n    CABALLO,\n    OTROS,\n}\n\nstruct Veterinaria {\n    nombre: String,\n    direccion: String,\n    id: i32,\n    atenciones: VecDeque\u003cAtencion\u003e,\n    atenciones_realizadas: Vec\u003cAtencion\u003e,\n}\n\n#[derive(Clone)]\nstruct Atencion {\n    mascota: Mascota,\n    diagnostico_final: String,\n    tratamiento: String,\n    fecha: Option\u003cFecha\u003e,\n}\n\n#[derive(Clone)]\nstruct Mascota {\n    nombre: String,\n    edad: String,\n    tipo: TipoAnimal,\n    dueño: Dueño,\n}\n\n#[derive(Clone)]\nstruct Dueño {\n    nombre: String,\n    direccion: String,\n    telefono: u32,\n}\n\npub fn compare_owners(owner1: \u0026Dueño, owner2: \u0026Dueño) -\u003e bool {\n    owner1.direccion == owner2.direccion \u0026\u0026\n    owner1.nombre == owner2.nombre \u0026\u0026\n    owner1.telefono == owner2.telefono\n}\n\npub fn compare_type(type1: \u0026TipoAnimal, type2: \u0026TipoAnimal)  -\u003e bool{\n    match (type1, type2) {\n        (TipoAnimal::CABALLO, TipoAnimal::CABALLO) =\u003e true,\n        (TipoAnimal::PERRO, TipoAnimal::PERRO) =\u003e true,\n        (TipoAnimal::GATO, TipoAnimal::GATO) =\u003e true,\n        (TipoAnimal::OTROS, TipoAnimal::OTROS) =\u003e true,\n        _ =\u003e false, \n    }\n}\n\npub fn compare_pets (mascota1: \u0026Mascota, mascota2: \u0026Mascota) -\u003e bool {\n    compare_owners(\u0026mascota1.dueño, \u0026mascota2.dueño) \u0026\u0026\n    mascota1.edad == mascota2.edad \u0026\u0026\n    mascota1.nombre == mascota2.nombre \u0026\u0026\n    compare_type(\u0026mascota1.tipo, \u0026mascota2.tipo)\n}\n\nfn compare_fecha(fecha1: \u0026Option\u003cFecha\u003e, fecha2: \u0026Option\u003cFecha\u003e) -\u003e bool {\n    match (fecha1, fecha2) {\n        (Some(f1), Some(f2)) =\u003e f1.dia == f2.dia \u0026\u0026 f1.mes == f2.mes \u0026\u0026 f1.año == f2.año,\n        (None, None) =\u003e true, // Ambas son None → consideradas iguales\n        _ =\u003e false,           // Una tiene valor y la otra no → distintas\n    }\n}\n\n\n\npub fn compare_atencion(atencion1: \u0026Atencion, atencion2: \u0026Atencion) -\u003e bool {\n    atencion1.diagnostico_final == atencion2.diagnostico_final \u0026\u0026\n    compare_fecha(\u0026atencion1.fecha, \u0026atencion2.fecha) \u0026\u0026\n    atencion1.tratamiento == atencion2.tratamiento \u0026\u0026\n    compare_pets(\u0026atencion1.mascota, \u0026atencion2.mascota)\n}\n\nimpl Veterinaria {\n    fn new(nombre: String, direccion: String, id: i32) -\u003e Veterinaria {\n        Veterinaria {\n            nombre,\n            direccion,\n            id,\n            atenciones: VecDeque::new(),\n            atenciones_realizadas: Vec::new(),\n        }\n    }\n\n    fn agregar_nueva_mascota(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion = Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_back(nueva_atencion);\n    }\n\n    fn agregar_mascota_maxima_prioridad(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion= Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_front(nueva_atencion);\n    }\n\n    fn atender_mascota(\u0026mut self) -\u003e Option\u003cMascota\u003e{\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            return Some(mascota_atendida.mascota);\n        } \n        None\n    }\n\n    fn eliminar_mascota(\u0026mut self, mascota: Mascota) {\n        //Find pet.\n        let mut indice_mascota_retirada:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_pets(\u0026self.atenciones[i].mascota,\u0026 mascota) {\n                indice_mascota_retirada= i as i32;\n                break;\n            }\n        }\n        //Delete pet.\n        if indice_mascota_retirada != -1 { //If I found the pet.\n            self.atenciones.remove(indice_mascota_retirada as usize);\n        }\n    }\n\n    fn registrar_atencion(\u0026mut self, tratamiento: String, diagnostico: String, fecha: Option\u003cFecha\u003e) {\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            let atencion_hecha= Atencion {\n                mascota: mascota_atendida.mascota,\n                diagnostico_final: diagnostico,\n                tratamiento: tratamiento,\n                fecha,\n            };\n\n            self.atenciones_realizadas.push(atencion_hecha);\n        };\n    }\n\n    fn buscar_atencion(\u0026self, nombre_mascota: String, nombre_dueño: String, telefono: u32) -\u003e Option\u003cAtencion\u003e {\n        for atencion in self.atenciones.iter() {\n            if atencion.mascota.nombre == nombre_mascota \u0026\u0026 atencion.mascota.dueño.nombre == nombre_dueño \u0026\u0026 atencion.mascota.dueño.telefono == telefono {\n                return Some(atencion.clone());\n            }\n        }\n        None\n    }\n\n    fn modificar_diagnostico(\u0026mut self, diagnostico_nuevo: String, atencion: \u0026Atencion) {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n        //Modify diagnostic.\n        if indice_atencion!= -1 { //If I found the attention.\n            self.atenciones[indice_atencion as usize].diagnostico_final = diagnostico_nuevo;\n        }\n    }\n\n    fn modificar_fecha(\u0026mut self, fecha_nueva: Option\u003cFecha\u003e, atencion: \u0026Atencion) {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 { \n            self.atenciones[indice_atencion as usize].fecha = fecha_nueva;\n        }\n    }\n\n    fn eliminar_atencion (\u0026mut self, atencion: \u0026Atencion) {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 {\n            self.atenciones.remove(indice_atencion as usize);\n        }\n    }\n}\n\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tp03::ej03::Fecha;\n\n    fn crear_dueño() -\u003e Dueño {\n        Dueño {\n            nombre: String::from(\"Juan Perez\"),\n            direccion: String::from(\"Calle Falsa 123\"),\n            telefono: 12345678,\n        }\n    }\n\n    fn crear_mascota(nombre: \u0026str, tipo: TipoAnimal) -\u003e Mascota {\n        Mascota {\n            nombre: String::from(nombre),\n            edad: String::from(\"5\"),\n            tipo,\n            dueño: crear_dueño(),\n        }\n    }\n\n    fn crear_fecha() -\u003e Option\u003cFecha\u003e {\n        Some(Fecha { dia: 1, mes: 1, año: 2024 })\n    }\n\n    #[test]\n    fn test_agregar_nueva_mascota() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 1\"), String::from(\"Arg\"), 1);\n        let mascota = crear_mascota(\"Firulais\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        assert_eq!(vet.atenciones.len(), 1);\n    }\n\n    #[test]\n    fn test_agregar_mascota_maxima_prioridad() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 2\"), String::from(\"Arg \"), 2);\n        let m1 = crear_mascota(\"Gato\", TipoAnimal::GATO);\n        let m2 = crear_mascota(\"Caballo\", TipoAnimal::CABALLO);\n\n        vet.agregar_nueva_mascota(m1.clone(), crear_fecha());\n        vet.agregar_mascota_maxima_prioridad(m2.clone(), crear_fecha());\n\n        assert_eq!(vet.atenciones.front().unwrap().mascota.nombre, \"Caballo\");\n    }\n\n    #[test]\n    fn test_atender_mascota() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 3\"), String::from(\"Arg\"), 3);\n        let mascota = crear_mascota(\"Toby\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        let atendido = vet.atender_mascota();\n\n        assert!(atendido.is_some());\n        assert_eq!(atendido.unwrap().nombre, \"Toby\");\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_registrar_atencion() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 4\"), String::from(\"Arg\"), 4);\n        let mascota = crear_mascota(\"Rex\", TipoAnimal::PERRO);\n        let fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        vet.registrar_atencion(String::from(\"Antibióticos\"), String::from(\"Infección\"), fecha.clone());\n\n        assert_eq!(vet.atenciones.len(), 0);\n        assert_eq!(vet.atenciones_realizadas.len(), 1);\n        let atendida = \u0026vet.atenciones_realizadas[0];\n        assert_eq!(atendida.mascota.nombre, \"Rex\");\n        assert_eq!(atendida.tratamiento, \"Antibióticos\");\n        assert_eq!(atendida.diagnostico_final, \"Infección\");\n        assert!(compare_fecha(\u0026atendida.fecha, \u0026fecha));\n    }\n\n    #[test]\n    fn test_eliminar_mascota() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 5\"), String::from(\"Zoológico\"), 5);\n        let mascota = crear_mascota(\"Milo\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        assert_eq!(vet.atenciones.len(), 1);\n\n        vet.eliminar_mascota(mascota);\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_buscar_atencion() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6);\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        let resultado = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert!(resultado.is_some());\n        assert_eq!(resultado.unwrap().mascota.nombre, \"Rocky\");\n    }\n}\n\n\n","traces":[{"line":45,"address":[3080832],"length":1,"stats":{"Line":1}},{"line":46,"address":[3080872,3080855],"length":1,"stats":{"Line":1}},{"line":47,"address":[3080888],"length":1,"stats":{"Line":1}},{"line":48,"address":[3080908],"length":1,"stats":{"Line":1}},{"line":51,"address":[3080944,3080998],"length":1,"stats":{"Line":1}},{"line":52,"address":[3081000,3080954],"length":1,"stats":{"Line":1}},{"line":61,"address":[3081104],"length":1,"stats":{"Line":1}},{"line":62,"address":[3081127,3081144],"length":1,"stats":{"Line":1}},{"line":63,"address":[3081160],"length":1,"stats":{"Line":1}},{"line":64,"address":[3081188],"length":1,"stats":{"Line":1}},{"line":65,"address":[3081208],"length":1,"stats":{"Line":1}},{"line":68,"address":[3081248],"length":1,"stats":{"Line":1}},{"line":69,"address":[3081258],"length":1,"stats":{"Line":1}},{"line":70,"address":[3081388,3081327],"length":1,"stats":{"Line":1}},{"line":72,"address":[3081381],"length":1,"stats":{"Line":0}},{"line":78,"address":[3081440],"length":1,"stats":{"Line":0}},{"line":79,"address":[3081463,3081480],"length":1,"stats":{"Line":0}},{"line":80,"address":[3081496],"length":1,"stats":{"Line":0}},{"line":81,"address":[3081530],"length":1,"stats":{"Line":0}},{"line":82,"address":[3081564],"length":1,"stats":{"Line":0}},{"line":86,"address":[3081600,3081908,3081930],"length":1,"stats":{"Line":3}},{"line":91,"address":[3081667],"length":1,"stats":{"Line":3}},{"line":92,"address":[3081720],"length":1,"stats":{"Line":3}},{"line":96,"address":[3081952,3082350],"length":1,"stats":{"Line":4}},{"line":99,"address":[3082067],"length":1,"stats":{"Line":5}},{"line":100,"address":[3082122],"length":1,"stats":{"Line":5}},{"line":104,"address":[3082321],"length":1,"stats":{"Line":6}},{"line":107,"address":[3082782,3082384],"length":1,"stats":{"Line":1}},{"line":110,"address":[3082499],"length":1,"stats":{"Line":1}},{"line":111,"address":[3082554],"length":1,"stats":{"Line":1}},{"line":115,"address":[3082753],"length":1,"stats":{"Line":1}},{"line":118,"address":[3082816,3083241,3083247],"length":1,"stats":{"Line":1}},{"line":119,"address":[3082840],"length":1,"stats":{"Line":1}},{"line":120,"address":[3082923],"length":1,"stats":{"Line":1}},{"line":122,"address":[3083151],"length":1,"stats":{"Line":0}},{"line":125,"address":[3083264,3083613],"length":1,"stats":{"Line":1}},{"line":127,"address":[3083289],"length":1,"stats":{"Line":1}},{"line":128,"address":[3083297,3083355],"length":1,"stats":{"Line":2}},{"line":129,"address":[3083480,3083522],"length":1,"stats":{"Line":2}},{"line":130,"address":[3083551],"length":1,"stats":{"Line":1}},{"line":135,"address":[3083503],"length":1,"stats":{"Line":1}},{"line":136,"address":[3083580],"length":1,"stats":{"Line":1}},{"line":140,"address":[3083632,3084379,3084506],"length":1,"stats":{"Line":1}},{"line":141,"address":[3083761,3083672],"length":1,"stats":{"Line":2}},{"line":143,"address":[3083845],"length":1,"stats":{"Line":1}},{"line":149,"address":[3084206],"length":1,"stats":{"Line":1}},{"line":153,"address":[3084544,3085066],"length":1,"stats":{"Line":1}},{"line":154,"address":[3084592,3084659],"length":1,"stats":{"Line":2}},{"line":155,"address":[3084808,3084922],"length":1,"stats":{"Line":2}},{"line":156,"address":[3085000],"length":1,"stats":{"Line":1}},{"line":159,"address":[3084839],"length":1,"stats":{"Line":0}},{"line":162,"address":[3085767,3085088],"length":1,"stats":{"Line":0}},{"line":164,"address":[3085118],"length":1,"stats":{"Line":0}},{"line":165,"address":[3085212,3085150],"length":1,"stats":{"Line":0}},{"line":166,"address":[3085349,3085386],"length":1,"stats":{"Line":0}},{"line":167,"address":[3085420],"length":1,"stats":{"Line":0}},{"line":172,"address":[3085719,3085372],"length":1,"stats":{"Line":0}},{"line":173,"address":[3085455,3085745],"length":1,"stats":{"Line":0}},{"line":177,"address":[3085808],"length":1,"stats":{"Line":0}},{"line":179,"address":[3085832],"length":1,"stats":{"Line":0}},{"line":180,"address":[3085840],"length":1,"stats":{"Line":0}},{"line":181,"address":[3085923],"length":1,"stats":{"Line":0}},{"line":182,"address":[3085971],"length":1,"stats":{"Line":0}},{"line":187,"address":[3086034,3085958],"length":1,"stats":{"Line":0}},{"line":188,"address":[3085987],"length":1,"stats":{"Line":0}},{"line":192,"address":[3086048],"length":1,"stats":{"Line":0}},{"line":194,"address":[3086073],"length":1,"stats":{"Line":0}},{"line":195,"address":[3086113,3086081],"length":1,"stats":{"Line":0}},{"line":196,"address":[3086168],"length":1,"stats":{"Line":0}},{"line":197,"address":[3086217],"length":1,"stats":{"Line":0}},{"line":202,"address":[3086203],"length":1,"stats":{"Line":0}},{"line":203,"address":[3086236],"length":1,"stats":{"Line":0}}],"covered":43,"coverable":72},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej10.rs"],"content":"use std::collections::HashMap;\nuse crate::tp03::ej03::Fecha;\n\n#[derive(Clone)]\nenum Genero {\n    Novela,\n    Infantil,\n    Tecnico,\n    Otros\n}\n\n#[derive(Clone)]\nenum EstadoPrestamo {\n    Devuelto,\n    EnPrestamo,\n}\n\n#[derive(Clone)]\nstruct Biblioteca {\n    nombre: String,\n    direccion: String,\n    libros: HashMap\u003cu32, Libro\u003e, //Key: ISBN.\n    prestamos: Vec\u003cPrestamo\u003e,\n}\n\n#[derive(Clone)]\nstruct Libro {\n    isbn: u32,\n    titulo: String,\n    copias_disponiles: u32,\n    autor: String,\n    numero_paginas: u32,\n    genero: Genero,\n}\n\n#[derive(Clone)]\nstruct Prestamo {\n    isbn_libro: u32,\n    cliente: Cliente,\n    fecha_vencimiento: Fecha,\n    fecha_devolucion: Fecha, \n    estado: EstadoPrestamo,\n}\n\n#[derive(Clone)]\nstruct Cliente {\n    nombre: String,\n    telefono: u32,\n    correo: String,\n}\n\npub fn no_devolvio (estado: \u0026EstadoPrestamo) -\u003e bool {\n    match estado {\n        (EstadoPrestamo::EnPrestamo) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare_clientes (cliente1: \u0026Cliente, cliente2: \u0026Cliente) -\u003e bool {\n    cliente1.nombre == cliente2.nombre \u0026\u0026\n    cliente1.correo == cliente2.correo \u0026\u0026\n    cliente1.telefono == cliente2.telefono\n}\n\nimpl Biblioteca {\n    fn obtener_cantidad_copias (\u0026self, libro: \u0026Libro) -\u003e u32 {\n        if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            return book.copias_disponiles;\n        } else {\n            return 0;\n        } \n    }\n\n    fn decrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) {\n        if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n            book.copias_disponiles -= 1;\n        }\n    }\n\n    fn incrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) {\n        if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n            book.copias_disponiles += 1;            \n        }\n    }\n\n    fn contar_prestamos_cliente (\u0026self, cliente: \u0026Cliente) -\u003e u32 {\n        let mut cant_prestamos= 0;\n\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) {\n                cant_prestamos += 1;\n            }\n        }\n        cant_prestamos\n    }\n\n    fn realizar_prestamo (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e bool {\n        //Check if the book exists and has available copies.\n        let okay_prestamo = if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            book.copias_disponiles \u003e= 1\n        } else {\n            false\n        };\n\n        //Check if the client has fewer than 5 loans.\n        if okay_prestamo \u0026\u0026 self.contar_prestamos_cliente(cliente) \u003c 5 {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles -= 1;\n                return true;\n            }\n        }\n        false\n    }\n\n\n    fn prestamos_vencer(\u0026self, cant_dias: u32, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut fecha_limite = fecha_actual.clone();\n        fecha_limite.sumar_dias(cant_dias);\n\n        let mut lista_prestamos_vencer = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            let fecha_igual = prestamo.fecha_vencimiento.dia == fecha_actual.dia \u0026\u0026\n                          prestamo.fecha_vencimiento.mes == fecha_actual.mes \u0026\u0026\n                          prestamo.fecha_vencimiento.año == fecha_actual.año;\n\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_limite) \u0026\u0026  // fecha_vencimiento \u003c= fecha_limite\n            (prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual) || fecha_igual)  // fecha_vencimiento \u003e= fecha_actual\n            {\n                lista_prestamos_vencer.push(prestamo.clone());\n            }\n        }\n         lista_prestamos_vencer    \n    }\n\n    fn prestamos_vencidos(\u0026self, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut lista_prestamos_vencidos = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual)\n            {\n                lista_prestamos_vencidos.push(prestamo.clone());\n            }\n        }\n        lista_prestamos_vencidos \n    }\n\n    fn buscar_prestamo (\u0026self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Option\u003cPrestamo\u003e {\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                return Some(prestamo.clone());\n            }\n        }\n        None\n    }\n\n    fn devolver_libro (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) {\n        for prestamo in self.prestamos.iter_mut() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                prestamo.estado= EstadoPrestamo::Devuelto;\n                if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                    book.copias_disponiles += 1;                    \n                }\n                break;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_obtener_cant_copias_libro() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n    \n        //Insertar libro.\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        let copias = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias, 7);\n    \n        //Libro no existente debe devolver 0\n        let libro_inexistente = Libro {\n            isbn: 999,\n            titulo: \"No existe\".to_string(),\n            copias_disponiles: 0,\n            autor: \"\".to_string(),\n            numero_paginas: 0,\n            genero: Genero::Otros,\n        };\n        let copias_inexistente = biblioteca.obtener_cantidad_copias(\u0026libro_inexistente);\n        assert_eq!(copias_inexistente, 0);\n    }\n\n    #[test]\n    fn test_decrementar_copias() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.decrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 6);\n        \n    }\n\n    #[test]\n    fn test_incrementar_copias() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.incrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 8);\n        \n    }\n\n    #[test]\n    fn test_contar_prestamos_cliente() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n        let prestamo2 = Prestamo {\n            isbn_libro: libro2.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n    \n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1, prestamo2],\n        };\n    \n        let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\n        assert_eq!(cantidad, 2);\n    }\n\n    #[test]\n    fn test_realizar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            correo: \"juan@mail.com\".to_string(),\n        };\n    \n        let libro = Libro {\n            isbn: 101,\n            titulo: \"Libro Test\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor Test\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Test\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n    \n        biblioteca.libros.insert(libro.isbn, libro.clone());\n    \n        // Cliente sin préstamos previos, debería poder tomar prestado\n        let exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(exito);\n    \n        // Copias deberían reducirse en 1\n        let copias_restantes = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_restantes, libro.copias_disponiles - 1);\n    \n        // Simulamos que el cliente ya tiene 5 préstamos\n        for _ in 0..5 {\n            biblioteca.prestamos.push(Prestamo {\n                isbn_libro: 999, // libro cualquiera\n                cliente: cliente.clone(),\n                fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n                fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n                estado: EstadoPrestamo::EnPrestamo,\n            });\n        }\n    \n        // Ahora no debería permitir más préstamos\n        let no_exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(!no_exito);\n    \n        // Copias no deberían cambiar porque no se hizo el préstamo\n        let copias_final = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_final, libro.copias_disponiles - 1);\n    }\n\n    #[test]\n    fn test_prestamos_a_vencer () {\n        let fecha_actual = Fecha { dia: 10, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n            nombre: \"Luis\".to_string(),\n            telefono: 5551234,\n            correo: \"luis@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"Libro de prueba\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n\n         // Préstamo que vence dentro de 5 días (día 14)\n        let prestamo_proximo = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 14, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo que vence después de 10 días (día 22)\n        let prestamo_lejano = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 22, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo ya devuelto, no debería aparecer\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 12, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 11, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo_proximo.clone(), prestamo_lejano, prestamo_devuelto],\n        };\n\n        let prestamos_vencer = biblioteca.prestamos_vencer(5, \u0026fecha_actual);\n\n        // Sólo debería contener el préstamo que vence dentro de 5 días y está activo\n        assert_eq!(prestamos_vencer.len(), 1);\n\n    }\n\n    #[test]\n    fn test_prestamos_vencidos() {\n        let fecha_actual = Fecha { dia: 15, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n          nombre: \"Carlos\".to_string(),\n          telefono: 123456,\n          correo: \"carlos@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 1,\n            titulo: \"Libro X\".to_string(),\n            copias_disponiles: 1,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n\n        let prestamo_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_no_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 20, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 5, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 6, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblio Test\".to_string(),\n            direccion: \"Dirección\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![\n                prestamo_vencido.clone(),\n                prestamo_no_vencido,\n                prestamo_devuelto,\n            ],\n        };\n\n        let vencidos = biblioteca.prestamos_vencidos(\u0026fecha_actual);\n\n        assert_eq!(vencidos.len(), 1);\n    }\n\n    #[test]\n    fn test_buscar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1],\n        };\n    \n        assert!(biblioteca.buscar_prestamo(\u0026libro1, \u0026cliente).is_some());\n\n        //Busco uno que no exista;\n        assert!(biblioteca.buscar_prestamo(\u0026libro2, \u0026cliente).is_none())\n    }\n\n    #[test]\n    fn test_devolver_libro() {\n        let cliente = Cliente {\n            nombre: \"Roberto\".to_string(),\n            telefono: 555123789,\n            correo: \"roberto@mail.com\".to_string(),\n        };\n    \n        \n        let mut libro = Libro {\n            isbn: 42,\n            titulo: \"pepe\".to_string(),\n            copias_disponiles: 5,  // Inicialmente hay 5 copias\n            autor: \"Autor\".to_string(),\n            numero_paginas: 300,\n            genero: Genero::Novela,\n        };\n    \n        \n        let prestamo = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 15, mes: 6, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },  // Aún no devuelto\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n        \n        let mut biblioteca = Biblioteca {\n            nombre: \"biblioteca\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo],\n        };\n\n        biblioteca.libros.insert(libro.isbn.clone(), libro.clone());\n        biblioteca.devolver_libro(\u0026libro, \u0026cliente);//Lo devuelvo.\n        let libro_devuelto = biblioteca.buscar_prestamo(\u0026libro, \u0026cliente);\n        let esta_devuelto = {\n            match libro_devuelto.unwrap().estado {\n                (EstadoPrestamo::Devuelto) =\u003e true,\n                _ =\u003e false,\n                \n            }\n        };\n\n        //println!(\"{}\", biblioteca.libros.len());\n        let updated_book = biblioteca.libros.get(\u0026libro.isbn.clone());\n        libro = updated_book.unwrap().clone();\n        assert_eq!(libro.copias_disponiles, 6); //Ok.\n\n        \n    }\n}","traces":[{"line":52,"address":[3153584],"length":1,"stats":{"Line":1}},{"line":53,"address":[3153589],"length":1,"stats":{"Line":1}},{"line":59,"address":[3153616],"length":1,"stats":{"Line":1}},{"line":60,"address":[3153639,3153648],"length":1,"stats":{"Line":1}},{"line":61,"address":[3153664],"length":1,"stats":{"Line":1}},{"line":62,"address":[3153692],"length":1,"stats":{"Line":1}},{"line":66,"address":[3153728],"length":1,"stats":{"Line":1}},{"line":67,"address":[3153742],"length":1,"stats":{"Line":2}},{"line":68,"address":[3153798],"length":1,"stats":{"Line":2}},{"line":70,"address":[3153807],"length":1,"stats":{"Line":1}},{"line":74,"address":[3153824],"length":1,"stats":{"Line":1}},{"line":75,"address":[3153935,3153838],"length":1,"stats":{"Line":2}},{"line":76,"address":[3153932,3153937,3153899],"length":1,"stats":{"Line":2}},{"line":80,"address":[3153952],"length":1,"stats":{"Line":1}},{"line":81,"address":[3153966,3154061],"length":1,"stats":{"Line":2}},{"line":82,"address":[3154058,3154063,3154027],"length":1,"stats":{"Line":2}},{"line":86,"address":[3154080],"length":1,"stats":{"Line":1}},{"line":87,"address":[3154094],"length":1,"stats":{"Line":1}},{"line":89,"address":[3154143,3154102],"length":1,"stats":{"Line":2}},{"line":90,"address":[3154196,3154245],"length":1,"stats":{"Line":2}},{"line":91,"address":[3154221,3154247],"length":1,"stats":{"Line":1}},{"line":94,"address":[3154212],"length":1,"stats":{"Line":1}},{"line":97,"address":[3154272],"length":1,"stats":{"Line":1}},{"line":99,"address":[3154375,3154306],"length":1,"stats":{"Line":2}},{"line":100,"address":[3154362],"length":1,"stats":{"Line":1}},{"line":102,"address":[3154377],"length":1,"stats":{"Line":0}},{"line":106,"address":[3154409,3154382],"length":1,"stats":{"Line":2}},{"line":107,"address":[3154429],"length":1,"stats":{"Line":1}},{"line":108,"address":[3154524,3154489],"length":1,"stats":{"Line":1}},{"line":109,"address":[3154517],"length":1,"stats":{"Line":1}},{"line":112,"address":[3154389],"length":1,"stats":{"Line":1}},{"line":116,"address":[3154560,3155189,3155195],"length":1,"stats":{"Line":1}},{"line":117,"address":[3154606],"length":1,"stats":{"Line":1}},{"line":118,"address":[3154638],"length":1,"stats":{"Line":1}},{"line":120,"address":[3154651],"length":1,"stats":{"Line":1}},{"line":122,"address":[3154732,3154661],"length":1,"stats":{"Line":2}},{"line":123,"address":[3154887,3154954],"length":1,"stats":{"Line":2}},{"line":124,"address":[3154969],"length":1,"stats":{"Line":0}},{"line":125,"address":[3154987],"length":1,"stats":{"Line":0}},{"line":127,"address":[3155015],"length":1,"stats":{"Line":1}},{"line":128,"address":[3155048],"length":1,"stats":{"Line":1}},{"line":129,"address":[3155090],"length":1,"stats":{"Line":1}},{"line":131,"address":[3155147],"length":1,"stats":{"Line":1}},{"line":134,"address":[3154911],"length":1,"stats":{"Line":1}},{"line":137,"address":[3155661,3155216,3155655],"length":1,"stats":{"Line":1}},{"line":138,"address":[3155256],"length":1,"stats":{"Line":1}},{"line":140,"address":[3155334,3155266],"length":1,"stats":{"Line":2}},{"line":141,"address":[3155555,3155489],"length":1,"stats":{"Line":2}},{"line":142,"address":[3155569],"length":1,"stats":{"Line":1}},{"line":144,"address":[3155616],"length":1,"stats":{"Line":1}},{"line":147,"address":[3155514],"length":1,"stats":{"Line":1}},{"line":150,"address":[3155680],"length":1,"stats":{"Line":1}},{"line":151,"address":[3155736,3155777],"length":1,"stats":{"Line":2}},{"line":152,"address":[3155893,3155837],"length":1,"stats":{"Line":2}},{"line":153,"address":[3155905],"length":1,"stats":{"Line":1}},{"line":156,"address":[3155858],"length":1,"stats":{"Line":1}},{"line":159,"address":[3155952],"length":1,"stats":{"Line":1}},{"line":160,"address":[3155981,3156022],"length":1,"stats":{"Line":2}},{"line":161,"address":[3156080,3156111],"length":1,"stats":{"Line":2}},{"line":162,"address":[3156134],"length":1,"stats":{"Line":1}},{"line":163,"address":[3156149,3156235],"length":1,"stats":{"Line":2}},{"line":164,"address":[3156209,3156240],"length":1,"stats":{"Line":1}}],"covered":59,"coverable":62},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","julieta_murias_v1.rs"],"content":"struct Examen {\n    nombre_materia: String,\n    nota: f64,\n}\n\nstruct Estudiante {\n    nombre: String,\n    id: i32,\n    examenes: Vec\u003cExamen\u003e,\n\n}\n\nstruct Informe {\n    nombre: String,\n    id: i32,\n    cant_examenes_rendidos: u32,\n    promedio: f64,\n    nota_baja: f64,\n    materia_baja: String,\n    nota_alta: f64,\n    materia_alta: String,\n}\n\npub fn obtener_materia_calificacion_alta(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más alta y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay.\");\n    }\n\n    let mut nota_mas_alta = f64::MIN;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() {\n        if examen.nota \u003e nota_mas_alta {\n            nota_mas_alta= examen.nota;\n            materia= examen.nombre_materia.clone();\n\n        }\n    }\n\n    materia\n}\n\npub fn obtener_materia_calificacion_baja(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más baja y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay\");\n    }\n\n    let mut nota_mas_baja = f64::MAX;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() { //Busco el examen con menor nota.\n        if examen.nota \u003c nota_mas_baja {\n            nota_mas_baja= examen.nota; //Actualizo.\n            materia= examen.nombre_materia.clone();\n        }\n    }\n\n    materia\n}\n\n\n\nimpl Examen {\n    fn new(nombre_materia: String, nota: f64) -\u003e Examen {\n        Examen {\n            nombre_materia,\n            nota,\n        }\n    }\n}\n\nimpl Estudiante {\n    fn new(nombre: String, id: i32) -\u003e Estudiante {\n        Estudiante {\n            nombre,\n            id,\n            examenes: Vec::new(),\n        }\n    }\n\n    fn obtener_promedio(\u0026self) -\u003e f64 {\n        let total_notas= self.examenes.len();\n        \n        if total_notas \u003e 0 {\n            let mut suma_notas= 0.0;\n            for examen in self.examenes.iter(){\n                suma_notas+= examen.nota;\n            }\n            return suma_notas/total_notas as f64;\n        }\n\n        0.0\n         \n     }\n\n     fn obtener_calificacion_mas_alta(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_alta = f64::MIN;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003e nota_mas_alta {\n                nota_mas_alta= examen.nota;\n            }\n        }\n\n        nota_mas_alta\n     }\n\n     fn obtener_calificacion_mas_baja(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_baja = f64::MAX;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003c nota_mas_baja {\n                nota_mas_baja= examen.nota;\n            }\n        }\n\n        nota_mas_baja\n     }\n\n     fn generar_informe (\u0026self) -\u003e Option\u003cInforme\u003e {\n        if self.examenes.len() == 0 {\n            return None; //Si no tiene notas devuelvo nada.\n        } else {\n            let informe = Informe { //Creo el informe y le aigno los campos.\n                nombre : self.nombre.clone(), \n                id: self.id,\n                cant_examenes_rendidos: self.examenes.len() as u32 -1,\n                promedio: self.obtener_promedio(),\n                nota_alta: self.obtener_calificacion_mas_alta(),\n                nota_baja: self.obtener_calificacion_mas_baja(),\n                materia_baja: obtener_materia_calificacion_baja(\u0026self.examenes),\n                materia_alta: obtener_materia_calificacion_alta(\u0026self.examenes),\n            };\n\n            return Some(informe); //Returno el Option con el informe.\n        }\n\n     }\n\n     \n\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n\n    #[test]\n    fn test_materias_asociadas_a_notas() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let materia1= obtener_materia_calificacion_alta(\u0026student.examenes);\n        assert_eq!(materia1, String::from(\"inglés\"));\n\n        let materia2 = obtener_materia_calificacion_baja(\u0026student.examenes);\n        assert_eq!(materia2, String::from(\"cadp\"));\n\n    }\n\n    #[test]\n    fn test_entregable1() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let informe1 = student.generar_informe();\n        assert!(informe1.is_some()); //pruebo con un estudiante que sí tenga informe.\n\n\n        let mut student= Estudiante::new(String::from(\"Pepe\"), 123);\n        let informe2 = student.generar_informe();\n        assert!(informe2.is_none()); //Pruebo con un estudiante que no tenga informe.\n\n    }\n\n\n    #[test]\n    fn test_promedio() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_promedio(), 9.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_promedio(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_alta() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_alta(), 10.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_alta(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_baja() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_baja(), 8.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_baja(), 0.0);\n    }\n}\n\n","traces":[{"line":24,"address":[3112224,3112785,3112779],"length":1,"stats":{"Line":1}},{"line":26,"address":[3112262],"length":1,"stats":{"Line":1}},{"line":27,"address":[3112278],"length":1,"stats":{"Line":0}},{"line":30,"address":[3112307],"length":1,"stats":{"Line":1}},{"line":31,"address":[3112312],"length":1,"stats":{"Line":1}},{"line":33,"address":[3112420,3112339],"length":1,"stats":{"Line":2}},{"line":34,"address":[3112568,3112774],"length":1,"stats":{"Line":2}},{"line":35,"address":[3112623],"length":1,"stats":{"Line":1}},{"line":36,"address":[3112634,3112669],"length":1,"stats":{"Line":1}},{"line":41,"address":[3112588],"length":1,"stats":{"Line":1}},{"line":44,"address":[3113365,3112800,3113359],"length":1,"stats":{"Line":1}},{"line":46,"address":[3112838],"length":1,"stats":{"Line":1}},{"line":47,"address":[3112854],"length":1,"stats":{"Line":0}},{"line":50,"address":[3112883],"length":1,"stats":{"Line":1}},{"line":51,"address":[3112888],"length":1,"stats":{"Line":1}},{"line":53,"address":[3112915,3112996],"length":1,"stats":{"Line":2}},{"line":54,"address":[3113144,3113354],"length":1,"stats":{"Line":2}},{"line":55,"address":[3113203],"length":1,"stats":{"Line":1}},{"line":56,"address":[3113214,3113249],"length":1,"stats":{"Line":1}},{"line":60,"address":[3113168],"length":1,"stats":{"Line":1}},{"line":66,"address":[3113392],"length":1,"stats":{"Line":3}},{"line":75,"address":[3113598,3113440],"length":1,"stats":{"Line":1}},{"line":79,"address":[3113484],"length":1,"stats":{"Line":1}},{"line":83,"address":[3113616],"length":1,"stats":{"Line":1}},{"line":84,"address":[3113630],"length":1,"stats":{"Line":1}},{"line":86,"address":[3113649],"length":1,"stats":{"Line":1}},{"line":87,"address":[3113671],"length":1,"stats":{"Line":1}},{"line":88,"address":[3113734,3113804,3113680],"length":1,"stats":{"Line":3}},{"line":89,"address":[3113787],"length":1,"stats":{"Line":1}},{"line":91,"address":[3113811],"length":1,"stats":{"Line":1}},{"line":94,"address":[3113655],"length":1,"stats":{"Line":1}},{"line":98,"address":[3113872],"length":1,"stats":{"Line":1}},{"line":99,"address":[3113886],"length":1,"stats":{"Line":1}},{"line":100,"address":[3113901],"length":1,"stats":{"Line":1}},{"line":103,"address":[3113917],"length":1,"stats":{"Line":1}},{"line":105,"address":[3113985,3113931],"length":1,"stats":{"Line":2}},{"line":106,"address":[3114042,3114086],"length":1,"stats":{"Line":2}},{"line":107,"address":[3114075],"length":1,"stats":{"Line":1}},{"line":111,"address":[3114057],"length":1,"stats":{"Line":1}},{"line":114,"address":[3114096],"length":1,"stats":{"Line":1}},{"line":115,"address":[3114110],"length":1,"stats":{"Line":1}},{"line":116,"address":[3114125],"length":1,"stats":{"Line":1}},{"line":119,"address":[3114141],"length":1,"stats":{"Line":1}},{"line":121,"address":[3114155,3114209],"length":1,"stats":{"Line":2}},{"line":122,"address":[3114266,3114314],"length":1,"stats":{"Line":2}},{"line":123,"address":[3114303],"length":1,"stats":{"Line":1}},{"line":127,"address":[3114285],"length":1,"stats":{"Line":1}},{"line":130,"address":[3114320,3114895,3114901],"length":1,"stats":{"Line":1}},{"line":131,"address":[3114358],"length":1,"stats":{"Line":1}},{"line":132,"address":[3114378],"length":1,"stats":{"Line":1}},{"line":135,"address":[3114398],"length":1,"stats":{"Line":1}},{"line":136,"address":[3114420],"length":1,"stats":{"Line":1}},{"line":137,"address":[3114427,3114505,3114537],"length":1,"stats":{"Line":2}},{"line":138,"address":[3114524],"length":1,"stats":{"Line":1}},{"line":139,"address":[3114562],"length":1,"stats":{"Line":1}},{"line":140,"address":[3114580],"length":1,"stats":{"Line":1}},{"line":141,"address":[3114597],"length":1,"stats":{"Line":1}},{"line":142,"address":[3114621],"length":1,"stats":{"Line":1}},{"line":145,"address":[3114875],"length":1,"stats":{"Line":1}}],"covered":57,"coverable":59},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","julieta_murias_v2.rs"],"content":"struct Examen {\n    nombre_materia: String,\n    nota: f64,\n}\n\nstruct Estudiante {\n    nombre: String,\n    id: i32,\n    examenes: Vec\u003cExamen\u003e,\n\n}\n\nstruct Informe {\n    nombre: String,\n    id: i32,\n    cant_examenes_rendidos: u32,\n    promedio: f64,\n    nota_baja: f64,\n    materia_baja: String,\n    nota_alta: f64,\n    materia_alta: String,\n}\n\npub fn obtener_materia_calificacion_alta(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más alta y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay.\");\n    }\n\n    let mut nota_mas_alta = f64::MIN;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() {\n        if examen.nota \u003e nota_mas_alta {\n            nota_mas_alta= examen.nota;\n            materia= examen.nombre_materia.clone();\n\n        }\n    }\n\n    materia\n}\n\npub fn obtener_materia_calificacion_baja(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más baja y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay\");\n    }\n\n    let mut nota_mas_baja = f64::MAX;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() { //Busco el examen con menor nota.\n        if examen.nota \u003c nota_mas_baja {\n            nota_mas_baja= examen.nota; //Actualizo.\n            materia= examen.nombre_materia.clone();\n        }\n    }\n\n    materia\n}\n\n\n\nimpl Examen {\n    fn new(nombre_materia: String, nota: f64) -\u003e Examen {\n        Examen {\n            nombre_materia,\n            nota,\n        }\n    }\n}\n\nimpl Estudiante {\n    fn new(nombre: String, id: i32) -\u003e Estudiante {\n        Estudiante {\n            nombre,\n            id,\n            examenes: Vec::new(),\n        }\n    }\n\n    fn obtener_promedio(\u0026self) -\u003e f64 {\n        let total_notas= self.examenes.len();\n        \n        if total_notas \u003e 0 {\n            let mut suma_notas= 0.0;\n            for examen in self.examenes.iter(){\n                suma_notas+= examen.nota;\n            }\n            return suma_notas/total_notas as f64;\n        }\n\n        0.0\n         \n     }\n\n     fn obtener_calificacion_mas_alta(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_alta = f64::MIN;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003e nota_mas_alta {\n                nota_mas_alta= examen.nota;\n            }\n        }\n\n        nota_mas_alta\n     }\n\n     fn obtener_calificacion_mas_baja(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_baja = f64::MAX;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003c nota_mas_baja {\n                nota_mas_baja= examen.nota;\n            }\n        }\n\n        nota_mas_baja\n     }\n\n     fn generar_informe (\u0026self) -\u003e Option\u003cInforme\u003e {\n        if self.examenes.len() == 0 {\n            return None; //Si no tiene notas devuelvo nada.\n        } else {\n            let informe = Informe { //Creo el informe y le aigno los campos.\n                nombre : self.nombre.clone(), \n                id: self.id,\n                cant_examenes_rendidos: self.examenes.len() as u32, //Modificación respecto a la versión anterior: le saqué el -1. Ahora devuelve la cantidad correcta de exámenes\n                promedio: self.obtener_promedio(),\n                nota_alta: self.obtener_calificacion_mas_alta(),\n                nota_baja: self.obtener_calificacion_mas_baja(),\n                materia_baja: obtener_materia_calificacion_baja(\u0026self.examenes),\n                materia_alta: obtener_materia_calificacion_alta(\u0026self.examenes),\n            };\n\n            return Some(informe); //Returno el Option con el informe.\n        }\n\n     }\n\n     \n\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n\n    #[test]\n    fn test_materias_asociadas_a_notas() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let materia1= obtener_materia_calificacion_alta(\u0026student.examenes);\n        assert_eq!(materia1, String::from(\"inglés\"));\n\n        let materia2 = obtener_materia_calificacion_baja(\u0026student.examenes);\n        assert_eq!(materia2, String::from(\"cadp\"));\n\n    }\n\n    #[test]\n    fn test_entregable1() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let informe1 = student.generar_informe();\n        assert!(informe1.is_some()); //pruebo con un estudiante que sí tenga informe.\n\n\n        let mut student= Estudiante::new(String::from(\"Pepe\"), 123);\n        let informe2 = student.generar_informe();\n        assert!(informe2.is_none()); //Pruebo con un estudiante que no tenga informe.\n\n    }\n\n\n    #[test]\n    fn test_promedio() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_promedio(), 9.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_promedio(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_alta() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_alta(), 10.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_alta(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_baja() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_baja(), 8.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_baja(), 0.0);\n    }\n}\n\n","traces":[{"line":24,"address":[3004939,3004945,3004384],"length":1,"stats":{"Line":1}},{"line":26,"address":[3004422],"length":1,"stats":{"Line":1}},{"line":27,"address":[3004438],"length":1,"stats":{"Line":0}},{"line":30,"address":[3004467],"length":1,"stats":{"Line":1}},{"line":31,"address":[3004472],"length":1,"stats":{"Line":1}},{"line":33,"address":[3004580,3004499],"length":1,"stats":{"Line":2}},{"line":34,"address":[3004728,3004934],"length":1,"stats":{"Line":2}},{"line":35,"address":[3004783],"length":1,"stats":{"Line":1}},{"line":36,"address":[3004829,3004794],"length":1,"stats":{"Line":1}},{"line":41,"address":[3004748],"length":1,"stats":{"Line":1}},{"line":44,"address":[3004960,3005525,3005519],"length":1,"stats":{"Line":1}},{"line":46,"address":[3004998],"length":1,"stats":{"Line":1}},{"line":47,"address":[3005014],"length":1,"stats":{"Line":0}},{"line":50,"address":[3005043],"length":1,"stats":{"Line":1}},{"line":51,"address":[3005048],"length":1,"stats":{"Line":1}},{"line":53,"address":[3005156,3005075],"length":1,"stats":{"Line":2}},{"line":54,"address":[3005304,3005514],"length":1,"stats":{"Line":2}},{"line":55,"address":[3005363],"length":1,"stats":{"Line":1}},{"line":56,"address":[3005409,3005374],"length":1,"stats":{"Line":1}},{"line":60,"address":[3005328],"length":1,"stats":{"Line":1}},{"line":66,"address":[3005552],"length":1,"stats":{"Line":1}},{"line":75,"address":[3005600,3005758],"length":1,"stats":{"Line":1}},{"line":79,"address":[3005644],"length":1,"stats":{"Line":1}},{"line":83,"address":[3005776],"length":1,"stats":{"Line":1}},{"line":84,"address":[3005790],"length":1,"stats":{"Line":1}},{"line":86,"address":[3005809],"length":1,"stats":{"Line":1}},{"line":87,"address":[3005831],"length":1,"stats":{"Line":1}},{"line":88,"address":[3005964,3005840,3005894],"length":1,"stats":{"Line":3}},{"line":89,"address":[3005947],"length":1,"stats":{"Line":1}},{"line":91,"address":[3005971],"length":1,"stats":{"Line":1}},{"line":94,"address":[3005815],"length":1,"stats":{"Line":1}},{"line":98,"address":[3006032],"length":1,"stats":{"Line":1}},{"line":99,"address":[3006046],"length":1,"stats":{"Line":1}},{"line":100,"address":[3006061],"length":1,"stats":{"Line":1}},{"line":103,"address":[3006077],"length":1,"stats":{"Line":1}},{"line":105,"address":[3006091,3006145],"length":1,"stats":{"Line":2}},{"line":106,"address":[3006246,3006202],"length":1,"stats":{"Line":2}},{"line":107,"address":[3006235],"length":1,"stats":{"Line":1}},{"line":111,"address":[3006217],"length":1,"stats":{"Line":2}},{"line":114,"address":[3006256],"length":1,"stats":{"Line":1}},{"line":115,"address":[3006270],"length":1,"stats":{"Line":1}},{"line":116,"address":[3006285],"length":1,"stats":{"Line":1}},{"line":119,"address":[3006301],"length":1,"stats":{"Line":1}},{"line":121,"address":[3006369,3006315],"length":1,"stats":{"Line":2}},{"line":122,"address":[3006426,3006474],"length":1,"stats":{"Line":2}},{"line":123,"address":[3006463],"length":1,"stats":{"Line":1}},{"line":127,"address":[3006445],"length":1,"stats":{"Line":1}},{"line":130,"address":[3007039,3006480,3007033],"length":1,"stats":{"Line":1}},{"line":131,"address":[3006518],"length":1,"stats":{"Line":1}},{"line":132,"address":[3006538],"length":1,"stats":{"Line":1}},{"line":135,"address":[3006558],"length":1,"stats":{"Line":1}},{"line":136,"address":[3006580],"length":1,"stats":{"Line":1}},{"line":137,"address":[3006587],"length":1,"stats":{"Line":1}},{"line":138,"address":[3006674],"length":1,"stats":{"Line":1}},{"line":139,"address":[3006692],"length":1,"stats":{"Line":1}},{"line":140,"address":[3006710],"length":1,"stats":{"Line":1}},{"line":141,"address":[3006728],"length":1,"stats":{"Line":1}},{"line":142,"address":[3006752],"length":1,"stats":{"Line":1}},{"line":145,"address":[3007013],"length":1,"stats":{"Line":1}}],"covered":57,"coverable":59},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05;\npub mod julieta_murias_v1;\npub mod ej07;\npub mod ej08;\npub mod ej09;\npub mod ej10;\n\npub mod julieta_murias_v2;","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej01.rs"],"content":"pub trait Primo {\n    fn soy_primo (\u0026self) -\u003e bool;\n}\n\nimpl Primo for i32 {\n\n    fn soy_primo(\u0026self) -\u003e bool {\n        if *self \u003c 2 {\n            return false;\n        }\n        for number in 2..=(*self as f64).sqrt() as i32 {\n            if self % number == 0 {\n                return false;\n            }\n        }\n        true\n    }\n\n}\n\npub fn contar_primos(numeros: \u0026Vec\u003ci32\u003e) -\u003e u32 {    \n    //\u0026\u0026i32 ????\n    numeros.iter().filter(|x| x.soy_primo()).count() as u32\n}\n\n\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn testar_contar_primos() {\n        let numbers:Vec\u003ci32\u003e = vec![1,2,3,4,5,6,7,8,9,10];\n\n        assert_eq!(contar_primos(\u0026numbers), 4);\n    }\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej02.rs"],"content":"#[derive(Clone)]\nstruct Persona \u003c'a\u003e{\n    nombre: \u0026'a str,\n    apellido: \u0026'a str,\n    direccion: \u0026'a str,\n    ciudad: \u0026'a str,\n    salario: f64,\n    edad: u8,\n}\n\n\n//Preg si está bien el uso del trait persona???\ntrait PersonaOps \u003c'a\u003e {\n    fn filtrar_por_salario(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, salario: f64) -\u003e Option\u003cVec\u003cPersona\u003c'a\u003e\u003e\u003e;\n    fn filtrar_por_edad_ciudad(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, edad: u8, ciudad: String) -\u003e Option\u003cVec\u003cPersona\u003c'a\u003e\u003e\u003e;\n    fn todos_viven_en(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool;\n    fn alguno_vive_en(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, ciudad:  \u0026str) -\u003e bool;\n    fn persona_existe(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, persona: \u0026Persona\u003c'a\u003e) -\u003e bool;\n    fn recolectar_edades(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003cVec\u003cu8\u003e\u003e;\n    fn salario_mayor_menor(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e  Option\u003c(\u0026Persona\u003c'a\u003e, \u0026Persona\u003c'a\u003e)\u003e;\n}\n\n\n\nimpl \u003c'a\u003e PersonaOps \u003c'a\u003e for Persona \u003c'a\u003e {\n\n    //Está bien??? Me da muchas dudas la parte de self pq no lo uso nunca \n    \n    fn filtrar_por_salario\u003c'b\u003e (\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'b\u003e\u003e, salario: f64) -\u003e Option\u003cVec\u003cPersona\u003c'b\u003e\u003e\u003e {\n        let people:Vec\u003cPersona\u003e = personas.iter().filter(|p| p.salario \u003e salario).cloned().collect();\n\n        if people.len() == 0 {\n            return None;\n        } else {\n            return Some(people);\n        }\n    }\n\n    fn filtrar_por_edad_ciudad\u003c'c\u003e (\u0026self, personas: \u0026'c Vec\u003cPersona\u003c'c\u003e\u003e, edad: u8, ciudad: String) -\u003e Option\u003cVec\u003cPersona\u003c'c\u003e\u003e\u003e {\n        let people:Vec\u003cPersona\u003e = personas.iter().filter(|p| p.edad \u003e edad \u0026\u0026 p.ciudad == ciudad).cloned().collect();\n\n        if people.len() == 0 {\n            return None;\n        } else {\n            return Some(people);\n        }\n    }\n\n    fn todos_viven_en\u003c'd\u003e (\u0026self, personas: \u0026'd Vec\u003cPersona\u003c'd\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n        if personas.is_empty() {\n            return false;\n        }\n        personas.iter().all(|p| p.ciudad.eq_ignore_ascii_case(\u0026ciudad))\n    }\n\n    fn alguno_vive_en (\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n        if personas.is_empty() {\n            return false;\n        }\n        personas.iter().any(|p| p.ciudad.eq_ignore_ascii_case(\u0026ciudad))\n    }\n\n    fn persona_existe\u003c'e\u003e(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, persona: \u0026Persona\u003c'e\u003e) -\u003e bool {\n        if personas.is_empty() {\n            return false;\n        }\n        personas.iter().any(|p| compare(p.clone(), persona.clone()))\n    }\n\n    fn recolectar_edades(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        if personas.is_empty() {\n            return None;\n        } else {\n            let edades: Vec\u003cu8\u003e = personas.iter().map(|p| p.edad).collect();\n            return Some(edades);\n        }\n    } \n\n    fn salario_mayor_menor(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003c(\u0026Persona\u003c'a\u003e, \u0026Persona\u003c'a\u003e)\u003e{ //Return a tuple with both people.\n        if personas.is_empty() {\n            return None;\n        } else {\n            let min = personas.iter().min_by(|a, b| {  //a and b are references to the items in the vector.\n                a.salario \n                    .partial_cmp(\u0026b.salario) //Primary comparison.\n                    .unwrap() //Unwrap because .partial_cmp() returns an Option, and I'm sure that there are no Nan values in the data.\n                    .then(b.edad.cmp(\u0026a.edad))  //Tie break. (Second condition; older wins!).\n            });\n            \n            //Same but for max.\n            let max = personas.iter().max_by(|a, b| {\n                a.salario \n                    .partial_cmp(\u0026b.salario)\n                    .unwrap()\n                    .then(b.edad.cmp(\u0026a.edad)) \n            });\n\n            if let (Some(min), Some(max)) = (min, max) {\n                Some((min, max))\n            } else { //Esto está de más????\n                None\n            }\n        }\n    }\n\n    \n}\n\npub fn compare (person1: Persona, person2: Persona) -\u003e bool {\n    person1.nombre == person2.nombre \u0026\u0026\n    person1.apellido == person2.apellido \u0026\u0026\n    person1.direccion.eq_ignore_ascii_case(person2.direccion) \u0026\u0026\n    person1.ciudad.eq_ignore_ascii_case(person2.ciudad) \u0026\u0026\n    person1.edad == person2.edad \u0026\u0026\n    person1.salario == person2.salario\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    fn crear_vector_con_personas\u003c'a\u003e() -\u003e Vec\u003cPersona\u003c'a\u003e\u003e {\n        vec![\n            Persona {\n                nombre: \"Juli\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 19,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Pepe\",\n                apellido: \"P\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 20,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Nombre\",\n                apellido: \"N\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 60,\n                salario: 50000.0,\n            },\n            Persona {\n                nombre: \"Jorgito\",\n                apellido: \"J\",\n                direccion: \"Arg\",\n                ciudad: \"Bs As\",\n                edad: 35,\n                salario: 45000.0,\n            },\n            Persona {\n                nombre: \"Benja\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 25,\n                salario: 60000.0,\n            },\n        ]\n    }\n\n\n    #[test]\n    fn test_filtrar_por_salario() {\n        let personas= crear_vector_con_personas();\n        let personas_inexistentes:Vec\u003cPersona\u003e = vec![];\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n        let filtrados = persona.filtrar_por_salario(\u0026personas, 10000.0);\n        //There should be 3 people in filtrados.\n        \n        assert!(filtrados.is_some());\n        assert_eq!(filtrados.as_ref().unwrap().len(), 3);\n        assert_ne!(filtrados.as_ref().unwrap().len(), 5);\n\n\n        //Test with the empty vec.\n        let filtrados_vacios = persona.filtrar_por_salario(\u0026personas_inexistentes, 10000.0);\n        assert!(filtrados_vacios.is_none());\n    }\n\n    #[test]\n    fn test_filtrar_por_edad_ciudad() {\n        let personas= crear_vector_con_personas();\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n        let filtrados = persona.filtrar_por_edad_ciudad(\u0026personas, 20, \"La plata\".to_string());\n\n        //In filtrados there should be 2 people.\n        assert!(filtrados.is_some());\n        assert_eq!(filtrados.as_ref().unwrap().len(), 2);\n    }\n\n    #[test]\n    fn test_todos_viven_en() {\n        let personas_no_cumplen = crear_vector_con_personas(); //Not everyone lives in La Plata.\n        let personas_cumplen = vec![\n            Persona {\n                nombre: \"Juli\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 19,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Pepe\",\n                apellido: \"P\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 20,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Nombre\",\n                apellido: \"N\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 60,\n                salario: 50000.0,\n            },\n            Persona {\n                nombre: \"Jorgito\",\n                apellido: \"J\",\n                direccion: \"Arg\",\n                ciudad: \"La Plata\",\n                edad: 35,\n                salario: 45000.0,\n            },\n            Persona {\n                nombre: \"Benja\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La PLATA\",\n                edad: 25,\n                salario: 60000.0,\n            },\n        ];\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        assert_eq!(persona.todos_viven_en(\u0026personas_no_cumplen, \"La plata\"), false);\n        assert_eq!(persona.todos_viven_en(\u0026personas_cumplen, \"La plata\"), true);\n\n    }\n\n    #[test]\n    fn test_alguno_vive_en() {\n        let personas_cumplen = crear_vector_con_personas(); //There's one person that lives in Bs As (the city I'm using to check).\n        let personas_no_cumplen = vec![ //Nobody lives in Bs As.s\n            Persona {\n                nombre: \"Juli\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 19,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Pepe\",\n                apellido: \"P\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 20,\n                salario: 10000.0,\n            },\n        ];\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        assert_eq!(persona.alguno_vive_en(\u0026personas_cumplen, \"bs as\"), true);\n        assert_eq!(persona.alguno_vive_en(\u0026personas_no_cumplen, \"bs as\"), false);\n\n        assert_ne!(persona.alguno_vive_en(\u0026personas_no_cumplen, \"bs as\"), true);\n\n    }\n\n    #[test]\n    fn test_persona_existe() {\n        let personas = crear_vector_con_personas();\n        let persona_existente = Persona {nombre: \"Juli\", apellido: \"M\", ciudad: \"la plata\", direccion: \"arg\", edad: 19, salario: 10000.0};\n        let persona_inexistente = Persona {nombre: \"zzz\", apellido: \"M\", ciudad: \"la plata\", direccion: \"arg\", edad: 99, salario: 20000.0};\n\n        let persona_tester = Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        assert_eq!(persona_tester.persona_existe(\u0026personas, \u0026persona_existente), true);\n        assert_eq!(persona_tester.persona_existe(\u0026personas, \u0026persona_inexistente), false);\n    }\n\n    #[test]\n    fn test_recolectar_edades() {\n        let personas = crear_vector_con_personas();\n        let persona_tester = Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n    \n        let edades =  persona_tester.recolectar_edades(\u0026personas);\n        assert!(edades.is_some());\n        assert_eq!(*edades.as_ref().unwrap(), vec![19,20,60,35,25]);\n\n\n        let edades = persona_tester.recolectar_edades(\u0026vec![]);\n        assert!(edades.is_none());\n    }\n\n    #[test]\n    fn test_salario_mayor_menor() {\n        let personas = crear_vector_con_personas();\n        let persona_tester = Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        let result = persona_tester.salario_mayor_menor(\u0026personas);\n        assert!(result.is_some());\n\n        let (persona_menor_salario, persona_mayor_salario) = result.unwrap();\n\n        assert_eq!(persona_menor_salario.nombre, \"Pepe\");\n        assert_eq!(persona_mayor_salario.nombre, \"Benja\");\n\n\n        let personas2: Vec\u003cPersona\u003c'_\u003e\u003e = vec![];\n        let result2 = persona_tester.salario_mayor_menor(\u0026personas2);\n        assert!(result2.is_none());\n    }\n}","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej03.rs"],"content":"use std::ptr::eq;\n\n#[derive(Clone, Debug)]\nenum TipoSuscripcion {\n    Basic,\n    Clasic,\n    Super,\n}\n\nimpl PartialEq for TipoSuscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoSuscripcion::Basic, TipoSuscripcion::Basic) =\u003e true,\n            (TipoSuscripcion::Clasic, TipoSuscripcion::Clasic) =\u003e true,\n            (TipoSuscripcion::Super, TipoSuscripcion::Super) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n\nimpl TipoSuscripcion {\n    fn costo_mensual(\u0026self) -\u003e f64 {\n        match self {\n            TipoSuscripcion::Basic =\u003e 5.0,\n            TipoSuscripcion::Clasic =\u003e 9.5,\n            TipoSuscripcion::Super =\u003e 15.0,\n        }\n    }\n\n    fn upgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e{\n        match self {\n            TipoSuscripcion::Basic =\u003e Some(TipoSuscripcion::Clasic),\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Super),\n            TipoSuscripcion::Super =\u003e None,\n        }\n    }\n\n    fn downgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\n        match  self {\n            TipoSuscripcion::Basic =\u003e None,\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Basic),\n            TipoSuscripcion::Super =\u003e Some(TipoSuscripcion::Clasic),\n            \n        }\n    }\n\n    fn soy_basic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Basic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_clasic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Clasic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_super(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Super =\u003e true,\n            _ =\u003e false, \n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Suscripcion {\n    tipo: TipoSuscripcion,\n    duracion_meses: u8,\n    fecha_inicio: String,\n    activa: bool,\n}\n\nimpl Suscripcion {\n    fn new(tipo: TipoSuscripcion, duracion_meses: u8, fecha_inicio: String) -\u003e Suscripcion {\n        Suscripcion {\n            tipo,\n            duracion_meses,\n            fecha_inicio,\n            activa: true,\n        }\n    }\n\n    fn activar_suscripcion(\u0026mut self) {\n        self.activa = true\n    }\n\n    fn desactivar_suscripcion(\u0026mut self) {\n        self.activa = false\n    }\n\n    fn upgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.upgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede ascender de Super.\".to_string()) //Is it okay to make it an err? \n        }\n    }\n\n    fn downgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.downgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e {\n                self.desactivar_suscripcion();\n                Err(\"Se ha canclado su suscripción.\".to_string())\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum MedioPago {\n    Efectivo,\n    MercadoPago {\n        cbu: u32,\n    },\n    TransferenciaBancaria {\n        cuenta_destino: String,\n        cuenta_origen: String,    },\n    TarjetaCredito {\n        numero_tarjeta: u32,\n    },\n    Cripto {\n        tipo_cripto: String,\n    },\n}\n\nimpl MedioPago {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            MedioPago::Efectivo =\u003e String::from(\"Efectivo\"),\n            MedioPago::TarjetaCredito { numero_tarjeta } =\u003e String::from(\"TarjetaCredito\"),\n            MedioPago::MercadoPago { cbu } =\u003e String::from(\"MercadoPago\"),\n            MedioPago::TransferenciaBancaria { cuenta_destino, cuenta_origen } =\u003e String::from(\"TransferenciaBancaria\"),\n            MedioPago::Cripto { tipo_cripto } =\u003e String::from(\"Cripto\"),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Usuario {\n    suscripciones: Vec\u003cSuscripcion\u003e,\n    medio_pago: MedioPago,\n    id: u32,\n    username: String,\n    nombre: String,\n    apellido: String,\n    email: String,\n}\n\nimpl Usuario {\n    fn agregar_suscripcion(\u0026mut self, suscripcion: Suscripcion) {\n        self.suscripciones.iter_mut().for_each(|s| s.desactivar_suscripcion()); //Deactivate all previous subscriptons.\n        self.suscripciones.push(suscripcion); //Add the new subscription.\n    }\n\n    fn obtener_suscripcion_activa(\u0026self) -\u003e Option\u003c\u0026Suscripcion\u003e {\n        self.suscripciones.iter().find(|s| s.activa)\n    }\n\n    fn obtener_suscripcion_activa_mutable(\u0026mut self) -\u003e Option\u003c\u0026mut Suscripcion\u003e {\n        self.suscripciones.iter_mut().find(|s| s.activa)\n    }\n\n    fn cancelar_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion_a_cancelar) =\u003e {\n                suscripcion_a_cancelar.desactivar_suscripcion();\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede cancelar esa suscripción. Ya sea porque no existe o porque ya está desactivada.\".to_string())\n        }\n    }\n\n    fn tiene_suscripcion_activa(\u0026self) -\u003e bool {\n        self.suscripciones.iter().any(|s| s.activa)\n    }\n\n    fn upgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.upgrade();\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para mejorar.\".to_string())\n        }\n    }\n\n    fn downgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.downgrade();\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para degradar.\".to_string())\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct StreamingRust {\n    usuarios: Vec\u003cUsuario\u003e, \n}\n\nimpl StreamingRust {\n\n    pub fn crear_plataforma() -\u003e StreamingRust {\n        StreamingRust {\n            usuarios: Vec::new(),\n        }\n    }\n\n    pub fn crear_usuario(\u0026mut self, suscripcion: \u0026Suscripcion, medio_pago: \u0026MedioPago, id: u32, username: String, nombre: String, apellido: String, email: String) {\n        let usuario = Usuario {\n            id: id,\n            suscripciones: vec![suscripcion.clone()],\n            medio_pago: medio_pago.clone(),\n            username: username,\n            nombre: nombre,\n            apellido: apellido,\n            email: email,\n        };\n\n        self.usuarios.push(usuario);\n    }\n\n    pub fn upgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        //Given an user upgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.upgrade_suscripcion(); //Update subscription.\n        }\n    }\n\n    pub fn downgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        //Given an user downgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.downgrade_suscripcion(); //Downgrade subscription.\n        }\n    }\n\n    pub fn cancelar_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.cancelar_suscripcion(); //Downgrade subscription.\n        }\n    }\n\n    //Estadísticas.\n    pub fn suscripcion_mas_contratada_activos(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones activas de los usuarios.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro usuarios con suscripción activa.\n            .for_each(|u| { //Para cada una de ellas.\n                //Obtener el tipo de suscripción activa.\n                if let Some(suscripcion) = u.obtener_suscripcion_activa() {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {  //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n\n                    }\n                }\n               \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn suscripcion_mas_contratada(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        //No me importan solo las suscripciones activas, tengo que chequear todas.\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario.\n                //Recorrer sus suscripciones (todas).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n                    }\n                });                     \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn medio_pago_mas_usado_activos(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n        \n        //Si no coincide con ninguna, creo la posición con el medio de pago y la cantidad inicializada en 1.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro los usuarios con suscripciones activas.\n            .for_each(|u| {\n                //Busco si su medio de pago coincide con alguna entrada en el vector -\u003e aumento en 1 la cantidad.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                    entry.1 += 1;\n                } else {\n                    auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                }\n            });\n\n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.\n    }\n\n    pub fn medio_pago_mas_usado(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario. (No filter).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                    }\n                });                     \n            });\n        \n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.    \n    }\n\n}\n\n\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_upgrade_downgrade() {\n        let mut suscripcion0 = Suscripcion::new(TipoSuscripcion::Basic, 3, \"12/9/2020\".to_string());\n        let mut suscripcion1 = Suscripcion::new(TipoSuscripcion::Super, 3, \"4/9/2019\".to_string());\n\n        //Test upgrade. Ok.\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.upgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_clasic(), true);\n\n        assert!(suscripcion1.upgrade().is_err());\n\n        //Test downgrade. Ok.\n        assert!(suscripcion0.downgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.downgrade().is_err());\n        assert_eq!(suscripcion0.activa, false);\n    }\n\n    #[test]\n    fn test_upgrade_subscription() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut usuarios = vec![user0.clone()];\n        let mut plataforma = StreamingRust {usuarios};\n\n        plataforma.upgrade_suscripcion(\u0026mut user0);\n\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n\n        assert!(user0.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Clasic)); //Ok.\n\n\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 124 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Super,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        plataforma.usuarios.push(user1.clone());\n        plataforma.upgrade_suscripcion(\u0026mut user1);\n        assert!(user1.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Super)); //Ok.\n\n\n        plataforma.cancelar_suscripcion(\u0026mut user0);\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n        assert_eq!(user0.suscripciones.iter().any(|s| s.activa), false); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        //Creo los usuarios para agregarlos a mi plataforma después.\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user2 = Usuario {\n            username: \"sus2\".to_string(),\n            email: \"sus2@email\".to_string(),\n            apellido: \"2\".to_string(),\n            id: 3,\n            nombre: \"sus2\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 123 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user3 = Usuario {\n            username: \"sus3\".to_string(),\n            email: \"sus3@email\".to_string(),\n            apellido: \"3\".to_string(),\n            id: 4,\n            nombre: \"sus3\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: false,\n            }],\n        };\n\n        //En resumen: \n        //Medios de pago: Activos: 2 de efectivo, 1 de mercado pago. Inactivos: 1 Efectivo.\n        //Suscripciones: Activos: 2 Basic, 1 Clasic. Inactivos: 1 Clasic.\n\n        let mut usuarios = vec![user0.clone(), user1.clone(), user2.clone(), user3.clone()];\n        let mut plataforma = StreamingRust {usuarios};\n\n        assert_eq!(plataforma.medio_pago_mas_usado_activos(), Some((\"Efectivo\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.medio_pago_mas_usado(), Some((\"Efectivo\".to_string(), 3))); //Ok.\n\n        assert_eq!(plataforma.suscripcion_mas_contratada(), Some((TipoSuscripcion::Clasic, 2))); //Ok. (Se queda con el último valor que encontró (el clasic en este caso) si hay un empate).\n        assert_eq!(plataforma.suscripcion_mas_contratada_activos(), Some((TipoSuscripcion::Basic, 2))); //Ok.\n    }\n  \n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej04.rs"],"content":"use std::{collections::HashMap, vec};\nuse std::hash::{Hash, Hasher};\n\n#[derive(Clone, Debug)]\nstruct Producto {\n    nombre: String,\n    categoria: Categoria,\n    precio_base: f64,\n}\n\n#[derive(Clone, Debug)]\n#[derive(Eq, Hash, PartialEq)]\nenum Categoria {\n    Hogar,\n    Limpieza,\n    Comida,\n    Tecnologia,\n}\n\n/*impl PartialEq for Categoria {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Categoria::Comida, Categoria::Comida) =\u003e true,\n            (Categoria::Hogar, Categoria::Hogar) =\u003e true,\n            (Categoria::Limpieza, Categoria::Limpieza) =\u003e true,\n            (Categoria::Tecnologia, Categoria::Tecnologia) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}*/\n\n#[derive(Clone, Debug)]\n#[derive(Eq, Hash, PartialEq)]\nstruct DatosPersona {\n    nombre: String, \n    apellido: String,\n    direccion: String,\n    dni: u32,\n}\n\n#[derive(Clone, Debug, PartialEq)]\nstruct F64Wrapper(f64); //F64Wrapper is a simple struct that contains a single field of type f64.\n\nimpl Eq for F64Wrapper {} //The Eq trait is implemented manually. This is safe because PartialEq is already derived, and the wrapper ensures consistent equality checks.\n\nimpl Hash for F64Wrapper { //The Hash trait is implemented by converting the f64 value to its bit representation using to_bits(). This ensures that equivalent floating-point values produce the same hash.\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        // Convert the f64 to its bit representation for consistent hashing\n        self.0.to_bits().hash(state);\n    }\n}\n\n#[derive(Clone, Debug)]\n#[derive(Eq, Hash, PartialEq)]\nstruct Vendedor {\n    datos: DatosPersona,\n    legajo: u32,\n    antiguedad: u32,\n    salario: F64Wrapper, //Now, the Vendedor struct can safely derive Eq and Hash. \n}\n\n#[derive(Clone, Debug)]\nstruct Cliente {\n    datos: DatosPersona,\n    suscripcion_newsletter: bool,\n    email_suscripcion: Option\u003cString\u003e, \n}\n\n#[derive(Clone, Debug)]\nstruct VentaProducto {\n    producto: Producto,\n    cantidad: u32,\n}\n\n#[derive(Clone, Debug)]\nstruct Venta {\n    fecha: String,\n    cliente: Cliente,\n    vendedor: Vendedor,\n    productos: Vec\u003cVentaProducto\u003e,\n    medio_pago: MedioPago,\n}\n\n#[derive(Clone, Debug)]\nenum MedioPago {\n    TarjetaCredito,\n    TarjetaDebito,\n    TransferenciaBancaria,\n    Efectivo,\n}\n\n#[derive(Clone, Debug)]\nstruct SistemaVentas {\n    ventas: Vec\u003cVenta\u003e,\n    categorias_descuento: Vec\u003cCategoria\u003e,\n    porcentajes_descuento: Vec\u003c(Categoria, f64)\u003e,\n}\n\nstruct ReportePorCategoria {\n    ventas_categoria: HashMap\u003cCategoria, Vec\u003cVenta\u003e\u003e,\n}\n\nstruct ReportePorVendedor {\n    ventas_vendedor: HashMap\u003cVendedor, Vec\u003cVenta\u003e\u003e,\n}\n\nimpl SistemaVentas {\n    pub fn new() -\u003e SistemaVentas {\n        SistemaVentas {\n            ventas: Vec::new(),\n            categorias_descuento: vec![Categoria::Hogar, Categoria::Tecnologia],\n            porcentajes_descuento: vec![(Categoria::Hogar, 15.0), (Categoria::Tecnologia, 20.0)],\n        }\n    }\n\n    pub fn crear_venta(\u0026mut self, fecha: String, cliente: \u0026Cliente, vendedor: \u0026Vendedor, productos: Vec\u003cVentaProducto\u003e, medio_pago: MedioPago) -\u003e Venta {\n        let venta = Venta{\n            cliente: cliente.clone(),\n            fecha: fecha,\n            vendedor: vendedor.clone(),\n            productos: productos,\n            medio_pago: medio_pago,\n        };\n\n        self.ventas.push(venta.clone());\n        venta\n    }\n\n    pub fn obtener_porcentaje_descuento(\u0026self, categoria: \u0026Categoria) -\u003e f64 {\n        //Buscar la categoria en el vector de descuentos y retornar lo que esté en la posición 1 de la tupla.\n        if let Some(entry) = self.porcentajes_descuento.iter().find(|(desc, _)| *desc == *categoria) {\n            return entry.1;\n        } else { //Si no está la ctegoría\n            return 0.0;\n        }\n    }\n\n    pub fn obtener_descuento_suscripcion(\u0026self) -\u003e f64 {\n        5.0\n    }\n\n    pub fn precio_final_venta(\u0026self, venta: \u0026Venta) -\u003e f64 {\n        if venta.productos.is_empty() {\n            return 0.0;\n        }\n\n        let mut precio = 0.0;\n\n        venta.productos.iter()\n            .for_each(|p| { //Para cada producto:\n                let mut precio_producto = p.producto.precio_base; //Inicializo el precio del producto con su precio base.\n                //Tengo que ver si encuentro la categoría del producto en el vector de categorías con descuento del sistema de ventas.\n                if self.categorias_descuento.iter().any(|c| *c == p.producto.categoria) {\n                    //Si el producto es de una categoría con descuento se lo aplico:\n                    precio_producto = (self.obtener_porcentaje_descuento(\u0026p.producto.categoria)/100.0) * p.producto.precio_base;\n                }\n                precio_producto = precio_producto * p.cantidad as f64; //Multiplico el precio (con el descuento aplicado o no) por la cantidad del producto.\n                precio += precio_producto; //Lo sumo en mi acumulador total.\n            });\n        \n        if venta.cliente.suscripcion_newsletter {\n            precio -= (self.obtener_descuento_suscripcion()/100.0) * precio;\n        }\n\n        precio\n    }\n\n    //Reportes.\n    fn reporte_por_vendedor(\u0026self) -\u003e ReportePorVendedor {\n        //Recorrer mi vector de ventas.\n        /*Por cada vendedor nuevo que no esté registrado en mi HM creo una entrada {\n            (vendedor, vec con esa venta.)}\n\n        Por cada vendedor que sí esté registrado en el HM  {\n            pusheo la venta al valor de esa entrada.}\n        */\n\n        let mut hm_auxiliar:HashMap\u003cVendedor, Vec\u003cVenta\u003e\u003e = HashMap::new();\n\n        for venta in self.ventas.iter() {\n            let vendedor = venta.vendedor.clone();\n            \n            if let Some(ventas_vendedor) = hm_auxiliar.get_mut(\u0026vendedor) {\n                ventas_vendedor.push(venta.clone());\n            } else {\n                hm_auxiliar.insert(vendedor, vec![venta.clone()]);\n            }\n        }\n\n        let reporte = ReportePorVendedor {\n           ventas_vendedor: hm_auxiliar,\n        };\n        \n        reporte\n    }\n\n    fn reporte_por_categoria(\u0026self) -\u003e ReportePorCategoria {\n        //Recorrer mi vector de ventas.\n        /*\n        Por cada venta :\n            Recorrer el listado de productos. \n            (Asumo que una misma venta se puede encontrar en más de una entrada del hm, porque sus productos pueden ser de más de una categoría.)\n                Por cada producto cuya categoría no esté registrada en mi HM -\u003e creo una entrada (categoria, vec con esa venta.)\n                Por cada categoría que sí esté registrada ern el hm -\u003e pusheo la venta al valor de esa entrada.\n         */\n\n        let mut hm_auxiliar:HashMap\u003cCategoria, Vec\u003cVenta\u003e\u003e = HashMap::new();\n\n        for venta in self.ventas.iter() { //Para cada venta.\n            let productos_venta = venta.productos.clone();\n            for producto_venta in productos_venta.iter() { //Para cada producto de la lista de productos.\n                let producto = producto_venta.producto.clone(); //Me guardo a ese producto.\n\n                if let Some(ventas_categoria) = hm_auxiliar.get_mut(\u0026producto.categoria) {\n                    ventas_categoria.push(venta.clone());\n                } else {\n                    hm_auxiliar.insert(producto.categoria.clone(), vec![venta.clone()]);\n                }\n\n            }\n        }\n\n        let reporte = ReportePorCategoria {\n            ventas_categoria: hm_auxiliar,\n         };\n         \n         reporte\n    }\n\n\n        \n}\n\n#[cfg(test)]\nmod test {\n\n    use super::*;\n\n    #[test]\n    fn test_crear_venta() {\n        let persona1 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 123,\n         };\n         \n         let persona2 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 234,\n         };\n\n        let cliente = Cliente {datos: persona1, suscripcion_newsletter: true, email_suscripcion: Some(String::from(\"pepe@email\")) };\n        let vendedor = Vendedor { datos: persona2, legajo: 0000, antiguedad: 3, salario: F64Wrapper(50000.0) };\n\n        let producto1 = Producto {\n            nombre: \"Agua\".to_string(),\n            categoria: Categoria::Comida,\n            precio_base: 600.0,\n        };\n\n        let producto2 = Producto {\n            nombre: \"Lampara\".to_string(),\n            categoria: Categoria::Hogar,\n            precio_base: 2000.0,\n        };\n\n        let prodCant1 = VentaProducto {\n            producto: producto1,\n            cantidad: 1,\n        };\n\n        let prodCant2 = VentaProducto {\n            producto: producto2,\n            cantidad: 1,\n        };\n\n        let productos = vec![prodCant1.clone(), prodCant2.clone()];\n\n        let mut sistema_ventas:SistemaVentas;\n\n        let mut sistema_ventas = SistemaVentas::new();\n        assert_eq!(sistema_ventas.ventas.len(), 0); //Ok.\n\n        sistema_ventas.crear_venta(\"1/1/2025\".to_string(), \u0026cliente, \u0026vendedor, productos, MedioPago::TransferenciaBancaria);\n\n        assert_eq!(sistema_ventas.ventas.len(), 1); //Ok.\n    }\n\n    #[test]\n    fn test_precio_final_venta() {\n\n        let persona1 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 123,\n         };\n         \n         let persona2 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 234,\n         };\n\n        let cliente = Cliente {datos: persona1, suscripcion_newsletter: true, email_suscripcion: Some(String::from(\"pepe@email\")) };\n        let vendedor = Vendedor { datos: persona2, legajo: 0000, antiguedad: 3, salario: F64Wrapper(50000.0) };\n\n        let producto1 = Producto {\n            nombre: \"Agua\".to_string(),\n            categoria: Categoria::Comida,\n            precio_base: 600.0,\n        };\n\n        let producto2 = Producto {\n            nombre: \"Lampara\".to_string(),\n            categoria: Categoria::Hogar,\n            precio_base: 2000.0,\n        };\n\n        let prodCant1 = VentaProducto {\n            producto: producto1,\n            cantidad: 1,\n        };\n\n        let prodCant2 = VentaProducto {\n            producto: producto2,\n            cantidad: 1,\n        };\n\n        let productos = vec![prodCant1.clone(), prodCant2.clone()];\n        let mut sistema_ventas = SistemaVentas::new();\n        let venta = sistema_ventas.crear_venta(\"1/1/2025\".to_string(), \u0026cliente, \u0026vendedor, productos, MedioPago::TransferenciaBancaria);\n\n        //El precio total tendría que ser de 855.0\n        assert_eq!(sistema_ventas.precio_final_venta(\u0026venta), 855.0); //Ok.\n    }\n\n    #[test]\n    fn test_reportes() {\n        let persona1 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 123,\n         };\n         \n         let persona2 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 234,\n         };\n\n        let cliente = Cliente {datos: persona1, suscripcion_newsletter: true, email_suscripcion: Some(String::from(\"pepe@email\")) };\n        let vendedor = Vendedor { datos: persona2, legajo: 0000, antiguedad: 3, salario: F64Wrapper(50000.0) };\n\n        let producto1 = Producto {\n            nombre: \"Agua\".to_string(),\n            categoria: Categoria::Comida,\n            precio_base: 600.0,\n        };\n\n        let producto2 = Producto {\n            nombre: \"Lampara\".to_string(),\n            categoria: Categoria::Hogar,\n            precio_base: 2000.0,\n        };\n\n        let prodCant1 = VentaProducto {\n            producto: producto1,\n            cantidad: 1,\n        };\n\n        let prodCant2 = VentaProducto {\n            producto: producto2,\n            cantidad: 1,\n        };\n\n        let productos = vec![prodCant1.clone(), prodCant2.clone()];\n        let mut sistema_ventas = SistemaVentas::new();\n        let venta = sistema_ventas.crear_venta(\"1/1/2025\".to_string(), \u0026cliente, \u0026vendedor, productos.clone(), MedioPago::TransferenciaBancaria);\n        \n\n        let reporte_por_vendedor = sistema_ventas.reporte_por_vendedor();\n\n        assert_eq!(reporte_por_vendedor.ventas_vendedor.len(), 1); //Ok.\n\n\n        sistema_ventas.crear_venta(\"2/2/2025\".to_string(), \u0026cliente, \u0026vendedor, productos.clone(), MedioPago::Efectivo);\n        let reporte_por_vendedor2 = sistema_ventas.reporte_por_vendedor();\n\n        assert_eq!(reporte_por_vendedor2.ventas_vendedor.len(), 1); //Ok.\n        assert_eq!(reporte_por_vendedor2.ventas_vendedor.get(\u0026vendedor).unwrap().len(), 2); //Ok.\n\n        //REPORTE POR CATEGORÍA AHEAD:\n\n        let reporte_por_categoria = sistema_ventas.reporte_por_categoria();\n        assert_eq!(reporte_por_categoria.ventas_categoria.len(), 2); //Ok.\n    }\n\n}","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej05.rs"],"content":"use std::collections::HashMap;\nuse chrono::{DateTime, Utc};\nuse rand::Rng;\nuse std::ptr::eq;\n\n#[derive(Clone, Debug)]\nstruct Usuario {\n    nombre: String,\n    apellido: String,\n    email: String,\n    dni: u32,\n    identidad_validada: bool,\n    balance_fiat: f64,\n    balance_criptomoneda: HashMap\u003cString, f64\u003e, //Nombre_cripto -\u003e cantidad.\n}\n\n#[derive(Clone, Debug)]\nstruct Blockchain {\n    nombre: String,\n    prefijo: String,\n}\n\n#[derive(Clone, Debug)]\nstruct Criptomoneda { \n    nombre: String,\n    prefijo: String,\n    listado_blockchains: Vec\u003cBlockchain\u003e,\n}\n\n#[derive(Clone, Debug)]\npub enum TipoTransaccion {\n    IngresoFiat,\n    CompraCripto,\n    VentaCripto,\n    RetiroCripto,\n    RecepcionCripto,\n    RetiroFiat,\n}\n\nimpl PartialEq for TipoTransaccion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoTransaccion::CompraCripto, TipoTransaccion::CompraCripto) =\u003e true,\n            (TipoTransaccion::IngresoFiat, TipoTransaccion::IngresoFiat) =\u003e true,\n            (TipoTransaccion::RecepcionCripto, TipoTransaccion::RecepcionCripto) =\u003e true,\n            (TipoTransaccion::RetiroCripto, TipoTransaccion::RetiroCripto) =\u003e true,\n            (TipoTransaccion::RetiroFiat, TipoTransaccion::RetiroFiat) =\u003e true,\n            (TipoTransaccion::VentaCripto, TipoTransaccion::VentaCripto) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum Medio {\n    MercadoPago,\n    TransferenciaBancaria,\n}\n\n#[derive(Clone, Debug)]\nstruct Transaccion {\n    fecha: DateTime\u003cUtc\u003e,\n    tipo: TipoTransaccion,\n    usuario: Usuario,\n    monto_fiat: Option\u003cf64\u003e,\n    criptomoneda: Option\u003cCriptomoneda\u003e,\n    monto_criptomoneda: Option\u003cf64\u003e,\n    cotizacion: Option\u003cf64\u003e,\n    blockchain: Option\u003cBlockchain\u003e,\n    hash: Option\u003cString\u003e,\n    medio: Option\u003cMedio\u003e,\n}\n\n#[derive(Clone, Debug)]\nstruct PlataformaXYZ {\n    usuarios: HashMap\u003cString, Usuario\u003e, //Email -\u003e usuario.\n    criptomonedas: HashMap\u003cString, Criptomoneda\u003e, //Nombre_cripto -\u003e cripto.\n    transacciones: Vec\u003cTransaccion\u003e,\n}\n\n//Custom errors.\n#[derive(Clone, Debug)]\nenum ErrorIntercambio { \n    UsuarioNoValido,\n    BalanceInsuficiente,\n    CriptoNoEncontrada,\n    BlockchainNoDisponible,\n    UsuarioNoEncontrado,\n}\n\n//Obtener cotizacion.\npub fn obtener_cotizacion(cripto_nombre: \u0026str) -\u003e f64  { //Datos en dólares del 28/05/2025.\n    match cripto_nombre {\n        \"Bitcoin\" =\u003e 107281.20,\n        \"Ethereum\" =\u003e 18.10,\n        \"Litecoin\" =\u003e 94.42,\n        _ =\u003e 50.0,\n    }\n}\n\nimpl PlataformaXYZ {\n    fn new() -\u003e Self {\n        PlataformaXYZ { usuarios: HashMap::new(), criptomonedas: HashMap::new(), transacciones:Vec::new() }\n    }\n\n    //Registrar usuario.\n    pub fn registrar_usuario(\u0026mut self, usuario: Usuario) { \n        self.usuarios.insert(usuario.email.clone(), usuario);\n    }\n\n    pub fn registrar_criptomoneda(\u0026mut self, criptomoneda: Criptomoneda) {\n        self.criptomonedas.insert(criptomoneda.nombre.clone(), criptomoneda);\n    }\n\n    pub fn ingresar_dinero(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Verify that the user exists and it is valided.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        match usuario.identidad_validada {\n            true =\u003e {\n                //Acredito el monto fiat.\n                usuario.balance_fiat += monto_fiat;\n                //println!(\"{}\", usuario.balance_fiat); Just to checked it worked (Ok.)\n                //Creo la transaccion.\n                let transaccion = Transaccion {\n                    fecha: Utc::now(),\n                    tipo: TipoTransaccion::IngresoFiat,\n                    usuario: usuario.clone(),\n                    monto_fiat: Some(monto_fiat),\n                    criptomoneda: None,\n                    monto_criptomoneda: None,\n                    cotizacion: None,\n                    blockchain: None,\n                    hash: None,\n                    medio: None,\n                };\n\n                //Agrego la transaccion a mi registro de transacciones.\n                self.transacciones.push(transaccion);\n                Ok(())\n            }\n            false =\u003e Err(ErrorIntercambio::UsuarioNoValido),\n        }\n    }\n\n    pub fn comprar_determinada_criptomoneda(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        if usuario.balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Check if the cripto exists.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //If we've come this far it is because the purchase can be made.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre); \n        usuario.balance_fiat -= monto_fiat; //Descuento el monto_fiat del balance_fiat del usuario.\n\n        //Acredito la cantidad acorde de criptos.\n        let cantidad_cripto = monto_fiat/cotizacion;\n\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) += cantidad_cripto;\n\n\n        /* EXPLICACIÓN:\n\n        entry() = busca si existe la clave, me da acceso para leer/crear la entrada. Retorna un entry enum (occupied, vacant).\n        or_insert() = \n            match entry {\n                Occupied(entrada) =\u003e entrada.get_mut(), // Si existe, devuelve \u0026mut al valor\n                Vacant(entrada) =\u003e entrada.insert(0.0), // Si no existe, inserta 0.0 y devuelve \u0026mut\n            }\n\n        Si \"pepe\" existe: retorna \u0026mut f64 apuntando al valor actual\n        Si \"pepe\" no existe: crea la entrada con valor 0.0 y retorna \u0026mut f64\n        */\n\n\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            usuario: usuario.clone(),\n            tipo: TipoTransaccion::CompraCripto,\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(cantidad_cripto),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n\n    pub fn vender_determinada_criptomoneda(\u0026mut self, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda, monto_criptomoneda: f64) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the cripto exixts.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //Check if the user has enough of that cripto to sell.\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        let monto_fiat = cotizacion * monto_criptomoneda;\n\n        //Actualizar datos del usuario.\n        usuario.balance_fiat += monto_fiat;\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) -= monto_criptomoneda; \n\n        //Creo la transaccion. \n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::VentaCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n\n    pub fn retirar_criptomoneda_a_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, blockchain: \u0026Blockchain, usuario: \u0026mut Usuario) -\u003e Result\u003cString, ErrorIntercambio\u003e {\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Verificar que la blockchain es soportada por la cripto.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?;\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n         //Generar hash simulado\n         let mut rng = rand::rng();\n         let hash = format!(\"{}{}\", blockchain.nombre, rng.random::\u003cu32\u003e());\n         \n         let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n\n         *usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre).unwrap() -= monto_criptomoneda; //Descuento la cantidad acorde de esa cripto.\n\n         //Generar transaccion.\n         let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: Some(hash.clone()),\n            medio: None,\n         };\n\n         self.transacciones.push(transaccion);\n         Ok(hash)\n    }\n\n    pub fn recibir_criptomoneda_de_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, usuario: \u0026mut Usuario, blockchain: \u0026Blockchain) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user data.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check cripto and blockchain.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?; //Si no existe se propaga el error y termina la función.\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n        //Acredito la cripto en el balance del usuario.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        if let Some(balance) = usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre) { //Busco si ya está la cripto en los balances del usuario.\n            *balance += monto_criptomoneda / cotizacion; \n        } else {\n            // Si la criptomoneda no existe en el balance, la inicializo con el monto dado.\n            usuario.balance_criptomoneda.insert(criptomoneda.nombre.clone(), monto_criptomoneda / cotizacion);\n        }\n\n        //Genero la transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RecepcionCripto,\n            usuario: usuario.clone(),\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_fiat: None,\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n    \n    pub fn retirar_fiat_por_determinado_medio(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, medio: \u0026Medio) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        let balance_fiat = usuario.balance_fiat;\n        if balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Descontar el monto fiat del monto del usuario.\n        usuario.balance_fiat -= monto_fiat;\n\n        //Generar transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroFiat,\n            usuario: usuario.clone(),\n            monto_fiat: Some(monto_fiat),\n            criptomoneda: None,\n            monto_criptomoneda: None,\n            cotizacion: None,\n            blockchain: None,\n            hash: None,\n            medio: Some(medio.clone()),\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n\n\n\n\n    //Estadísticas.\n    pub fn criptomoneda_mas_vendida(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea VentaCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de ventas asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más ventas).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n\n        /*EXPLANATION: \n        Inside the map closure:\n\n        (nombre, cantidad) destructures the reference: nombre is \u0026String, cantidad is \u0026u32\n        nombre.clone() creates an owned String from the \u0026String\n        *cantidad dereferences the \u0026u32 to get an owned u32\n         */\n    }\n\n    pub fn criptomoneda_mas_comprada(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea CompraCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::CompraCripto)\n            .for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de compras asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más compras).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n    }\n\n    pub fn crpitomoneda_mas_volumen_venta (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción VentaCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de venta).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    }\n\n\n    pub fn crpitomoneda_mas_volumen_compra (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t|t.tipo == TipoTransaccion::CompraCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción CompraCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de compra).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    } \n}\n\n\n#[cfg(test)]\nmod test {\n    use core::hash;\n\n    use super::*;\n\n    fn crear_plataforma() -\u003e PlataformaXYZ {\n        let mut plataforma = PlataformaXYZ::new();\n\n        //Crear usuarios.\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user2 = Usuario {\n            nombre: \"Rosita\".to_string(),\n            apellido: \"R\".to_string(),\n            email: \"emailRosita\".to_string(),\n            dni: 345,\n            identidad_validada: true,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        plataforma.registrar_usuario(user0);\n        plataforma.registrar_usuario(user1);\n        plataforma.registrar_usuario(user2);\n        plataforma.registrar_usuario(user3);\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        let litecoin_chain = Blockchain {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        let litecoin = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![litecoin_chain],\n        };\n\n        plataforma.registrar_criptomoneda(bitcoin);\n        plataforma.registrar_criptomoneda(ethereum);\n        plataforma.registrar_criptomoneda(litecoin);\n\n        plataforma\n    }\n\n\n    #[test]\n    fn test_ingresar_dinero() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Test with an user that is valid.\n        \n        //println!(\"Balance before: {}\", \u0026user0.balance_fiat);\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user0).is_ok());\n\n        //let usuario = plataforma.usuarios.get(\u0026user0.email);\n        //println!(\"From platform {}\", usuario.unwrap().balance_fiat); //Se modifica.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0.balance_fiat = updated_user.balance_fiat; // Synchronize user0 with the updated user\n\n        //println!(\"Balance after: {}\", user0.balance_fiat);\n        assert_eq!(user0.balance_fiat, 12000.0);\n\n\n        //Test with an user that is not valid.\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user3).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_comprar_determinada_moneda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { //Esta cripto sí está.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let pepecripto = Criptomoneda { //Esta cripto no.\n            nombre: \"PepeCripto\".to_string(),\n            prefijo: \"PC\".to_string(),\n            listado_blockchains: vec![],\n        };\n\n        //Compra de una cripto que existe desde un usario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Tiene la cripto.\n\n        //Compra de una cripto que no existe desde un usuario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026pepecripto).is_err()); //Ok.\n\n        //Compra de una cripto que sí existe desde un usuario que NO puede(user1, por el balance).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user1, \u0026bitcoin).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_vender_determinada_criptomeda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.01).is_ok());\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone();\n        assert_eq!(user0.balance_fiat, 8072.812); //Ok. Se le acreditó el balance fiat de su venta.\n    }\n\n    #[test]\n    fn test_retirar_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { //Blockchain válida.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let bitcoin_unvalid_chain = Blockchain { //Blockchain NO válida.\n            nombre: \"bit\".to_string(),\n            prefijo: \"b\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0).is_ok());\n\n        //let hash = plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0);\n        //println!(\"{}\", hash.unwrap()); \n\n\n        //Probar con una blockchain que no existe.\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_unvalid_chain, \u0026mut user0).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_recibir_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n        //Arranca user0 sin criptos. (HM len == 0).\n        //println!(\"Error: {:?}\",plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain) ); \n        assert!(plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain).is_ok()); //Ok.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Ok.\n    }\n\n    #[test]\n    fn test_retirar_fiat() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let medio = \u0026Medio::MercadoPago;\n\n        assert!(plataforma.retirar_fiat_por_determinado_medio(5000.0,\u0026mut user0, medio).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_fiat, 5000.0); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 100000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Voy a usar a user0 para haga todas las transacciones.\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n        \n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026ethereum);\n        \n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n\n        //assert_eq!(user0.balance_criptomoneda.len(), 2);\n        //println!(\"{}\", plataforma.transacciones.len());\n        assert_eq!(plataforma.criptomoneda_mas_comprada(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_compra(), Some((\"Ethereum\".to_string(), 55.24861878453038))); //Ok.\n\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026ethereum, 0.0001);\n\n        assert_eq!(plataforma.criptomoneda_mas_vendida(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_venta(), Some((\"Bitcoin\".to_string(), 0.0002))); //Ok.\n    }\n}\n \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05;","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej01.rs"],"content":"use serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\nenum Color {\n    ROJO,\n    VERDE, \n    AZUL,\n    AMARILLO,\n    BLANCO,\n    NEGRO,\n}\n#[derive(Clone)]\n#[derive(Serialize, Deserialize, Debug)]\nstruct Auto {\n    color: Color,\n    marca: String,\n    modelo: String,\n    precio_bruto: f64,\n    año: u32,\n}\n\n\nstruct ConsecionarioAuto {\n    nombre: String,\n    direccion: String,\n    x: u32,\n    autos: Vec\u003cAuto\u003e,\n    archivo_autos: PathBuf, //ruta del archivo JSON.\n}\n\n#[derive(Clone, Debug)]\nenum ErroresPersonalizados {\n    CapacidadExcedida(String),\n    ErrorArchivo(String),\n    AutoNoEncontrado(String),\n}\n\n\npub fn compare_colors(color1: \u0026Color, color2: \u0026Color) -\u003e bool {\n    match(color1, color2) {\n        (Color::AMARILLO, Color::AMARILLO) =\u003e true,\n        (Color::AZUL, Color::AZUL) =\u003e true,\n        (Color::VERDE, Color::VERDE) =\u003e true,\n        (Color::ROJO, Color::ROJO) =\u003e true,\n        (Color::NEGRO, Color::NEGRO) =\u003e true,\n        (Color::BLANCO, Color::BLANCO) =\u003e true,\n        _ =\u003e false, //If the variants are different, they are not equal\n    }\n}\n\npub fn compare (auto1: \u0026Auto, auto2: \u0026Auto) -\u003e bool {\n    auto1.año == auto2.año \u0026\u0026\n    auto1.marca == auto2.marca \u0026\u0026\n    auto1.modelo == auto2.modelo \u0026\u0026\n    auto1.precio_bruto == auto2.precio_bruto \u0026\u0026\n    compare_colors(\u0026auto1.color, \u0026auto2.color)\n\n}\n\nimpl ConsecionarioAuto {\n    fn new(nombre: String, direccion: String, x: u32, archivo_autos: String) -\u003e ConsecionarioAuto {\n        let path = PathBuf::from(archivo_autos);\n        let mut concesionario =  ConsecionarioAuto {\n            nombre: nombre,\n            direccion: direccion,\n            x: x,\n            autos: Vec::new(),\n            archivo_autos: path,\n        };\n\n        concesionario\n    }\n\n    pub fn cargar_al_archivo(\u0026mut self, auto: \u0026Auto) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Abrir el archivo en modo escritura.\n        let mut archivo = match File::create(self.archivo_autos.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo en modo escritura.\")))?,\n            Ok(arch) =\u003e arch,            \n        };\n\n        let auto_serializado = serde_json::to_string(\u0026auto).unwrap();\n        match archivo.write(\u0026auto_serializado.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo.\")))?,\n            Ok(_) =\u003e Ok(()),  \n        }\n    }\n\n    fn agregar_auto(\u0026mut self, auto: \u0026Auto) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        if self.autos.len()+1 \u003c= self.x.try_into().unwrap() {\n            self.autos.push(auto.clone());\n\n            //Lo agrego a mi archivo JSON.\n            self.cargar_al_archivo(\u0026auto)?; //Está bien dejar que el error se propague acá?\n            \n\n            \n            Ok(())\n        } else {\n            Err(ErroresPersonalizados::CapacidadExcedida(format!(\"No se pueden agrgar más autos. Concesionario lleno :/\")))\n        }\n    }\n\n    fn eliminar_auto(\u0026mut self, auto: \u0026Auto) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Find the car I want to delete in the vec.\n        let mut index_car_delete= -1;\n        for i in 0.. self.autos.len() {\n            if compare(\u0026self.autos[i], \u0026auto) {\n                index_car_delete= i as i32;\n                break;\n            }  \n        }\n\n        //Delete the car.\n        if index_car_delete != -1 {  //If I found the car to delete.\n            // Delete the car from the JSON file.\n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_autos)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n            self.autos.remove(index_car_delete as usize);\n\n            //Write the updated vector back to the file.\n            let writer = std::io::BufWriter::new(\u0026file); //Crea un nuevo BufWriter.\n\n            serde_json::to_writer(writer, \u0026self.autos)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo: {}\", e)))?;\n            Ok(())\n        } else {\n            Err(ErroresPersonalizados::AutoNoEncontrado(format!(\"El auto que desea eliminar no fue encontrado.\")))\n        }\n    }\n\n    fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\n        for car in self.autos.iter() {\n            if compare(\u0026car, \u0026auto) {\n                return Some(car);\n            }\n        }\n        None //If I didn't find it, return nothing (None).\n    }\n}\n\nimpl Auto {\n    fn new(marca: String, modelo: String, precio_bruto: f64, año: u32, color: Color ) -\u003e Auto {\n        Auto {\n            marca,\n            modelo,\n            precio_bruto,\n            año,\n            color,\n        }\n    }\n\n    fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut precio_final= self.precio_bruto;\n\n        //Check first condition (color).\n        let es_primario = match self.color {\n            Color::AMARILLO | Color::AZUL | Color::ROJO =\u003e true,\n            _ =\u003e false,\n        };\n\n        if es_primario {\n            precio_final += (self.precio_bruto * 25.0)/100.0; //+25%.\n        } else {\n            precio_final -= (10.0*self.precio_bruto)/100.0; //-10%.\n        }\n\n        //Check second condition (brand).\n        if self.marca == \"BMW\" {\n            precio_final += (self.precio_bruto * 15.0)/100.0; //+15%.\n        }\n\n        //Check third condition (year).\n        if self.año \u003c 2000 {\n            precio_final -= (self.precio_bruto * 5.0)/100.0; //-5%.\n        }\n\n        precio_final\n    }\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_auto() {\n        let path = \"src/tp05/archivo_autos.txt\";\n\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3, String::from(path));\n\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n        let auto4= Auto::new(String::from(\"Ferrari\"), String::from(\"modelo R\"), 1000.0, 2015, Color::ROJO);\n\n        \n        assert!(concesionario.agregar_auto(\u0026auto1).is_ok());\n        assert_eq!(concesionario.autos.len(), 1); //Added only 1 element.\n\n        //Fill all available space.\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.agregar_auto(\u0026auto3);\n        assert_eq!(concesionario.autos.len(), 3);\n\n        //Try to add one more.\n        match concesionario.agregar_auto(\u0026auto4) {\n            Ok(_) =\u003e println!(\"Auto agregado exitosamente.\"),\n            Err(ErroresPersonalizados::CapacidadExcedida(msg)) =\u003e println!(\"Error: {}\", msg),\n            Err(_) =\u003e println!(\"Error desconocido.\"),\n        }\n    }\n\n    #[test]\n    fn testear_eliminar_auto() {\n        let path = \"src/tp05/archivo_autos.txt\";\n\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3,  String::from(path));\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n\n        //First I try to delete a car from an empty list.\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //Passed. Nothing changed.\n\n        //Add cars to delete.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //yes.\n\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 1);\n    }\n    \n    #[test]\n    fn testear_buscar_auto() {\n        let path = \"src/tp05/archivo_autos.txt\";\n\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3, String::from(path));\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n\n\n        //Try to find a car in an empty list.\n        assert!(concesionario.buscar_auto(\u0026auto1).is_none());\n\n        //Find a car that exists.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        assert!(concesionario.buscar_auto(\u0026auto2).is_some());\n\n        //Find a car that doesn't exist.\n        assert!(concesionario.buscar_auto(\u0026auto3).is_none());\n    }\n\n    #[test]\n    fn testear_calcular_precio() {\n        //Test brand (and not primary color).\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n        let auto2= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n\n        assert_eq!(auto1.calcular_precio(), 1050.0); \n        assert_eq!(auto2.calcular_precio(), 900.0);\n\n        //Test if primary color.\n        let auto3= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::AMARILLO);\n        assert_eq!(auto3.calcular_precio(), 1250.0);\n        \n        //Test year (withouth primary color).\n        let auto4= Auto::new(String::from(\"Cronos\"), String::from(\"modelo 1\"), 1000.0, 1999, Color::BLANCO);\n        assert_eq!(auto4.calcular_precio(), 850.0);\n    }\n\n}","traces":[{"line":45,"address":[2990294,2990240],"length":1,"stats":{"Line":2}},{"line":46,"address":[2990296,2990250],"length":1,"stats":{"Line":2}},{"line":57,"address":[2990448],"length":1,"stats":{"Line":1}},{"line":58,"address":[2990471,2990479],"length":1,"stats":{"Line":3}},{"line":59,"address":[2990495],"length":1,"stats":{"Line":2}},{"line":60,"address":[2990515],"length":1,"stats":{"Line":1}},{"line":61,"address":[2990543],"length":1,"stats":{"Line":2}},{"line":62,"address":[2990566],"length":1,"stats":{"Line":2}},{"line":67,"address":[2990608,2991124,2991055],"length":1,"stats":{"Line":1}},{"line":68,"address":[2990659],"length":1,"stats":{"Line":1}},{"line":73,"address":[2990815],"length":1,"stats":{"Line":2}},{"line":80,"address":[2992375,2992369,2991168],"length":1,"stats":{"Line":2}},{"line":82,"address":[2991198],"length":1,"stats":{"Line":2}},{"line":83,"address":[2992388,2991313,2991239],"length":1,"stats":{"Line":0}},{"line":84,"address":[2991275],"length":1,"stats":{"Line":2}},{"line":87,"address":[2991303,2991656],"length":1,"stats":{"Line":4}},{"line":88,"address":[2991694,2991762],"length":1,"stats":{"Line":6}},{"line":89,"address":[2992318,2991858,2991934],"length":1,"stats":{"Line":0}},{"line":90,"address":[2991905],"length":1,"stats":{"Line":3}},{"line":94,"address":[2992416],"length":1,"stats":{"Line":1}},{"line":95,"address":[2992955,2992459,2992721],"length":1,"stats":{"Line":5}},{"line":96,"address":[2992728],"length":1,"stats":{"Line":1}},{"line":99,"address":[2992860,2992779],"length":1,"stats":{"Line":1}},{"line":103,"address":[2992948],"length":1,"stats":{"Line":3}},{"line":105,"address":[2992545],"length":1,"stats":{"Line":1}},{"line":109,"address":[2993903,2992960,2993897],"length":1,"stats":{"Line":1}},{"line":111,"address":[2993003],"length":1,"stats":{"Line":1}},{"line":112,"address":[2993011,2993043],"length":1,"stats":{"Line":2}},{"line":113,"address":[2993098],"length":1,"stats":{"Line":1}},{"line":114,"address":[2993150],"length":1,"stats":{"Line":1}},{"line":120,"address":[2993133,2993332],"length":1,"stats":{"Line":2}},{"line":122,"address":[2993545,2993427,2993337],"length":1,"stats":{"Line":2}},{"line":125,"address":[2993389],"length":1,"stats":{"Line":1}},{"line":126,"address":[2993406,2993490],"length":1,"stats":{"Line":1}},{"line":128,"address":[2993667,2993587],"length":1,"stats":{"Line":2}},{"line":131,"address":[2993687],"length":1,"stats":{"Line":1}},{"line":133,"address":[2993831,2993759,2993699],"length":1,"stats":{"Line":2}},{"line":134,"address":[2993799,2993736],"length":1,"stats":{"Line":1}},{"line":135,"address":[2993858],"length":1,"stats":{"Line":1}},{"line":137,"address":[2993156],"length":1,"stats":{"Line":1}},{"line":141,"address":[2993920],"length":1,"stats":{"Line":1}},{"line":142,"address":[2993974,2993933],"length":1,"stats":{"Line":2}},{"line":143,"address":[2994027],"length":1,"stats":{"Line":1}},{"line":144,"address":[2994066],"length":1,"stats":{"Line":1}},{"line":147,"address":[2994047],"length":1,"stats":{"Line":1}},{"line":152,"address":[2994080],"length":1,"stats":{"Line":1}},{"line":162,"address":[2994160],"length":1,"stats":{"Line":1}},{"line":163,"address":[2994173],"length":1,"stats":{"Line":1}},{"line":166,"address":[2994184],"length":1,"stats":{"Line":1}},{"line":167,"address":[2994224],"length":1,"stats":{"Line":1}},{"line":168,"address":[2994217],"length":1,"stats":{"Line":1}},{"line":171,"address":[2994281,2994229],"length":1,"stats":{"Line":2}},{"line":172,"address":[2994287],"length":1,"stats":{"Line":1}},{"line":174,"address":[2994240],"length":1,"stats":{"Line":1}},{"line":178,"address":[2994400,2994328],"length":1,"stats":{"Line":2}},{"line":179,"address":[2994363],"length":1,"stats":{"Line":1}},{"line":183,"address":[2994348,2994458],"length":1,"stats":{"Line":2}},{"line":184,"address":[2994417],"length":1,"stats":{"Line":1}},{"line":187,"address":[2994402],"length":1,"stats":{"Line":1}}],"covered":57,"coverable":59},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej02.rs"],"content":"use serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n\n\n#[derive(Clone, Serialize, Deserialize)]\nenum Genero {\n    ROCK,\n    POP,\n    JAZZ,\n    RAP,\n    OTROS,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Cancion {\n    titulo: String,\n    artista: String,\n    genero: Genero,\n}\n\nstruct PlayList {\n    nombre: String,\n    canciones: Vec\u003cCancion\u003e,\n    archivo_canciones: PathBuf,\n}\n\nenum ErroresPersonalizados {\n    CancionNoEncontrada(String),\n    ErrorArchivo(String),\n    PosicionFueraDeRango,\n}\n\nimpl Cancion {\n    fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\n        Cancion {\n            titulo,\n            artista,\n            genero,\n        }\n    }\n}\n\npub fn compare_genre(genero1: \u0026Genero, genero2: \u0026Genero) -\u003e bool {\n    match (genero1, genero2) {\n        (Genero::JAZZ, Genero::JAZZ) =\u003e true,\n        (Genero::ROCK, Genero::ROCK) =\u003e true,\n        (Genero::RAP, Genero::RAP) =\u003e true,\n        (Genero::POP, Genero::POP) =\u003e true,\n        (Genero::OTROS, Genero::OTROS) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare (cancion1: \u0026Cancion, cancion2: \u0026Cancion) -\u003e bool {\n    cancion1.artista == cancion2.artista \u0026\u0026\n    cancion1.titulo == cancion2.titulo \u0026\u0026\n    compare_genre(\u0026cancion1.genero, \u0026cancion2.genero)\n\n}\n\nimpl PlayList {\n    fn new(nombre: String, archivo_canciones: String) -\u003e PlayList {\n        let path = PathBuf::from(archivo_canciones);\n        PlayList {\n            nombre,\n            canciones: Vec::new(),\n            archivo_canciones: path,\n        }\n    }\n\n    pub fn cargar_al_archivo(\u0026mut self, cancion: \u0026Cancion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Abrir el archivo en modo escritura.\n        let mut archivo = match File::create(self.archivo_canciones.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Problema al abrir el archivo\")))?,\n            Ok(arch) =\u003e arch,            \n        };\n\n        let cancion_serializada = serde_json::to_string(\u0026cancion).unwrap();\n        match archivo.write(\u0026cancion_serializada.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Problema al escribir en el archivo\")))?,\n            Ok(_) =\u003e Ok(()),  \n        }\n    }\n\n    fn agregar_cancion(\u0026mut self, cancion: \u0026Cancion) {\n        self.canciones.push(cancion.clone());\n        self.cargar_al_archivo(cancion); //Qué hago con el unused result?\n\n    }\n\n    fn eliminar_cancion(\u0026mut self, cancion: \u0026Cancion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Find the song I want to delete in the vec.\n        let mut index_song_delete= -1;\n        for i in 0.. self.canciones.len() {\n            if compare(\u0026self.canciones[i], \u0026cancion) {\n                index_song_delete= i as i32;\n                break;\n            }  \n        }\n        //Delete the car. \n        if index_song_delete != -1 { //If I found the car to delete.\n\n            let file = std::fs::OpenOptions::new() //Me armo mi file nuevo.\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_canciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n            self.canciones.remove(index_song_delete as usize);\n\n            let writer = std::io::BufWriter::new(\u0026file); //Crea un nuevo BufWriter.\n\n            serde_json::to_writer(writer, \u0026self.canciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo: {}\", e)))?;\n        \n            Ok(())\n        } else {\n            Err(ErroresPersonalizados::CancionNoEncontrada(format!(\"NO se encontró la canción que desea eliminar.\")))\n        }\n    }\n\n    fn mover_cancion(\u0026mut self, cancion: \u0026Cancion, posicion_nueva: u32) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        if posicion_nueva \u003c self.canciones.len() as u32 {\n\n            //Search song in the playlist.\n            let mut song_index:i32= -1;\n            for i in 0..self.canciones.len() {\n                if compare(\u0026self.canciones[i], \u0026cancion) {\n                    song_index= i as i32;\n                    break;\n                }\n            }\n\n            if song_index != -1 { //If I found the song.\n                //Move the song to the new position.\n                let song = self.canciones.remove(song_index as usize);\n                self.canciones.insert(posicion_nueva as usize, song);\n\n                let file = std::fs::OpenOptions::new() //Me armo mi file nuevo.\n                    .read(true)\n                    .write(true)\n                    .open(\u0026self.archivo_canciones)\n                    .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n                \n                let writer = std::io::BufWriter::new(\u0026file); //Crea un nuevo BufWriter.\n\n                serde_json::to_writer(writer, \u0026self.canciones)\n                    .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo: {}\", e)))?;\n\n                Ok(())\n            } else {\n                Err(ErroresPersonalizados::CancionNoEncontrada(format!(\"No se encontró la canción que desea mover.\")))\n            }\n\n        } else {\n            Err(ErroresPersonalizados::PosicionFueraDeRango)\n        }\n    }\n\n    fn buscar_cancion_por_nombre(\u0026self, nombre: String) -\u003e Option\u003cCancion\u003e {\n        for song in self.canciones.iter() {\n            if (song.titulo == nombre) {\n                return Some(song.clone());\n            }\n        }\n        None\n    }\n\n    fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_genero= Vec::new();\n\n        for song in self.canciones.iter() {\n            if compare_genre(\u0026song.genero, \u0026genero) {\n                canciones_genero.push(song.clone());\n            }\n        }\n        canciones_genero\n    }\n\n    fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_artista= Vec::new();\n\n        for song in self.canciones.iter() {\n            if song.artista == artista {\n                canciones_artista.push(song.clone());\n            }\n        }\n\n        canciones_artista\n    }\n\n    fn modificar_titulo_playlist(\u0026mut self, titulo_nuevo: String) {\n        self.nombre= titulo_nuevo;\n    }\n\n    fn eliminar_todas_las_canciones(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        self.canciones.clear();\n\n        let mut archivo = OpenOptions::new() \n            .write(true)\n            .read(true)\n            .open(self.archivo_canciones.clone())\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n        archivo.write_all(b\"[]\").map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?; //b\"[]\" to write an empty JSON array to the file. Ask if okay???\n\n        Ok(())\n    }\n }\n\n\n #[cfg(test)]\n\n mod test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        assert_eq!(playlist.canciones.len(), 3);\n    }\n\n    #[test]\n    fn testear_eliminar_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        \n        playlist.eliminar_cancion(\u0026cancion1); //Delete just 1 song.\n        assert_eq!(playlist.canciones.len(), 1);\n\n        //Try to delete a song that is not in the playlist.\n        playlist.eliminar_cancion(\u0026cancion3);\n        assert_eq!(playlist.canciones.len(), 1); //lenght shouldn't change.\n    }\n\n    #[test]\n    fn testear_buscar_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n        \n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n\n        playlist.agregar_cancion(\u0026cancion1);\n\n        //Search for a song that is in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion1\")).is_some());\n\n        //Search for a song that is not in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion10\")).is_none());\n    }\n\n    #[test]\n    fn testear_eliminar_canciones() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        playlist.eliminar_todas_las_canciones();\n        assert_eq!(playlist.canciones.len(), 0);\n    }\n\n    #[test]\n    fn testear_mover_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); //Originally in pos 0 (in playlist).\n        playlist.agregar_cancion(\u0026cancion2); //Originally in pos 1 (in playlist).\n        playlist.agregar_cancion(\u0026cancion3); //Originally in pos 2 (in playlist).\n\n        //Check that.\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\"));\n\n        //Move a song that is in the playlist.\n        playlist.mover_cancion(\u0026cancion2, 2);\n        assert_eq!(playlist.canciones[2].titulo, String::from(\"Cancion2\"));\n\n        //Move a song that is not in the playlist.\n        playlist.mover_cancion(\u0026cancion4, 0);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n\n        //Move a song that is in the playlist to a non existing position.\n        playlist.mover_cancion(\u0026cancion1, 3);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n    }\n\n    #[test]\n    fn testear_cambiar_nombre_playlist() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        //Check that.\n        assert_eq!(playlist.nombre, String::from(\"Chill music\"));\n        \n        //Change the name.\n        playlist.modificar_titulo_playlist(String::from(\"Nombre nuevo\"));\n        assert_eq!(playlist.nombre, String::from(\"Nombre nuevo\"));\n    }\n\n    #[test]\n    fn testear_canciones_mismo_genero() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 jazz songs.\n        let mut jazz_songs: Vec\u003cCancion\u003e;\n        jazz_songs= playlist.obtener_canciones_por_genero(Genero::JAZZ);\n        assert_eq!(jazz_songs.len(), 2);\n\n        //Try with a genre that is not in the playlist.\n        let mut pop_songs= playlist.obtener_canciones_por_genero(Genero::POP);\n        assert_eq!(pop_songs.len(), 0);\n    }\n\n    #[test]\n    fn testear_canciones_mismo_artista() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 pepa songs.\n        let mut pepa_songs: Vec\u003cCancion\u003e;\n        pepa_songs= playlist.obtener_canciones_por_artista(String::from(\"pepa\"));\n        assert_eq!(pepa_songs.len(), 2);\n\n        //Try with an artist that is not in the playlist.\n        let mut titi_songs= playlist.obtener_canciones_por_artista(String::from(\"titi\"));\n        assert_eq!(titi_songs.len(), 0);\n    }\n }","traces":[{"line":40,"address":[2752416],"length":1,"stats":{"Line":1}},{"line":49,"address":[2752480,2752534],"length":1,"stats":{"Line":1}},{"line":50,"address":[2752536,2752490],"length":1,"stats":{"Line":2}},{"line":60,"address":[2752656],"length":1,"stats":{"Line":1}},{"line":61,"address":[2752679,2752696],"length":1,"stats":{"Line":2}},{"line":62,"address":[2752712],"length":1,"stats":{"Line":1}},{"line":63,"address":[2752732],"length":1,"stats":{"Line":1}},{"line":68,"address":[2752768,2753095,2753120],"length":1,"stats":{"Line":1}},{"line":69,"address":[2752803],"length":1,"stats":{"Line":1}},{"line":72,"address":[2752907],"length":1,"stats":{"Line":1}},{"line":77,"address":[2753152,2754353,2754359],"length":1,"stats":{"Line":2}},{"line":79,"address":[2753182],"length":1,"stats":{"Line":1}},{"line":80,"address":[2753223,2754372,2753297],"length":1,"stats":{"Line":0}},{"line":81,"address":[2753259],"length":1,"stats":{"Line":3}},{"line":84,"address":[2753640,2753287],"length":1,"stats":{"Line":4}},{"line":85,"address":[2753678,2753746],"length":1,"stats":{"Line":4}},{"line":86,"address":[2754302,2753842,2753918],"length":1,"stats":{"Line":0}},{"line":87,"address":[2753889],"length":1,"stats":{"Line":4}},{"line":91,"address":[2754400],"length":1,"stats":{"Line":1}},{"line":92,"address":[2754430],"length":1,"stats":{"Line":1}},{"line":93,"address":[2754481],"length":1,"stats":{"Line":1}},{"line":97,"address":[2755444,2754512,2755450],"length":1,"stats":{"Line":1}},{"line":99,"address":[2754555],"length":1,"stats":{"Line":1}},{"line":100,"address":[2754595,2754563],"length":1,"stats":{"Line":2}},{"line":101,"address":[2754650],"length":1,"stats":{"Line":1}},{"line":102,"address":[2754702],"length":1,"stats":{"Line":1}},{"line":107,"address":[2754685,2754884],"length":1,"stats":{"Line":2}},{"line":109,"address":[2755094,2754889,2754979],"length":1,"stats":{"Line":2}},{"line":112,"address":[2754941],"length":1,"stats":{"Line":1}},{"line":113,"address":[2666563,2666528],"length":1,"stats":{"Line":1}},{"line":115,"address":[2755136,2755216],"length":1,"stats":{"Line":2}},{"line":117,"address":[2755236],"length":1,"stats":{"Line":1}},{"line":119,"address":[2755306,2755378,2755248],"length":1,"stats":{"Line":2}},{"line":120,"address":[2666784,2666819],"length":1,"stats":{"Line":1}},{"line":122,"address":[2755405],"length":1,"stats":{"Line":1}},{"line":124,"address":[2754708],"length":1,"stats":{"Line":1}},{"line":128,"address":[2756564,2755472,2756558],"length":1,"stats":{"Line":1}},{"line":129,"address":[2755607,2755526],"length":1,"stats":{"Line":2}},{"line":132,"address":[2755614],"length":1,"stats":{"Line":1}},{"line":133,"address":[2755622,2755669],"length":1,"stats":{"Line":2}},{"line":134,"address":[2755724],"length":1,"stats":{"Line":1}},{"line":135,"address":[2755776],"length":1,"stats":{"Line":1}},{"line":140,"address":[2755958,2755759],"length":1,"stats":{"Line":2}},{"line":142,"address":[2755968],"length":1,"stats":{"Line":1}},{"line":143,"address":[2756003],"length":1,"stats":{"Line":1}},{"line":145,"address":[2756028,2756118,2756236],"length":1,"stats":{"Line":2}},{"line":148,"address":[2756080],"length":1,"stats":{"Line":1}},{"line":149,"address":[2667040,2667075],"length":1,"stats":{"Line":1}},{"line":152,"address":[2756298],"length":1,"stats":{"Line":1}},{"line":154,"address":[2756486,2756414,2756354],"length":1,"stats":{"Line":2}},{"line":155,"address":[2756454,2756391],"length":1,"stats":{"Line":1}},{"line":157,"address":[2756513],"length":1,"stats":{"Line":1}},{"line":159,"address":[2755782],"length":1,"stats":{"Line":1}},{"line":163,"address":[2755548],"length":1,"stats":{"Line":1}},{"line":167,"address":[2756969,2756592],"length":1,"stats":{"Line":1}},{"line":168,"address":[2756635,2756707],"length":1,"stats":{"Line":2}},{"line":169,"address":[2756848,2756905],"length":1,"stats":{"Line":2}},{"line":170,"address":[2756926],"length":1,"stats":{"Line":1}},{"line":173,"address":[2756869],"length":1,"stats":{"Line":1}},{"line":176,"address":[2757398,2757404,2756992],"length":1,"stats":{"Line":1}},{"line":177,"address":[2757033],"length":1,"stats":{"Line":1}},{"line":179,"address":[2757111,2757043],"length":1,"stats":{"Line":2}},{"line":180,"address":[2757337,2757266],"length":1,"stats":{"Line":2}},{"line":181,"address":[2757359],"length":1,"stats":{"Line":1}},{"line":184,"address":[2757296],"length":1,"stats":{"Line":1}},{"line":187,"address":[2757880,2757424],"length":1,"stats":{"Line":1}},{"line":188,"address":[2757464],"length":1,"stats":{"Line":1}},{"line":190,"address":[2757582,2757517],"length":1,"stats":{"Line":2}},{"line":191,"address":[2757742,2757819],"length":1,"stats":{"Line":2}},{"line":192,"address":[2757841],"length":1,"stats":{"Line":1}},{"line":196,"address":[2757767],"length":1,"stats":{"Line":1}},{"line":199,"address":[2757904,2757964],"length":1,"stats":{"Line":1}},{"line":200,"address":[2757999,2757922],"length":1,"stats":{"Line":2}},{"line":203,"address":[2758580,2758032,2758574],"length":1,"stats":{"Line":1}},{"line":204,"address":[2758070],"length":1,"stats":{"Line":1}},{"line":206,"address":[2758285,2758188,2758079],"length":1,"stats":{"Line":2}},{"line":209,"address":[2758133],"length":1,"stats":{"Line":1}},{"line":210,"address":[2667552,2667587],"length":1,"stats":{"Line":1}},{"line":212,"address":[2667843,2667808],"length":1,"stats":{"Line":2}},{"line":214,"address":[2758530],"length":1,"stats":{"Line":1}}],"covered":78,"coverable":80},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej03.rs"],"content":"use std::{collections::VecDeque, path::PathBuf};\nuse crate::tp03::ej03::Fecha;\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\n\n\n#[derive(Clone, Serialize, Deserialize)]\nenum TipoAnimal {\n    PERRO,\n    GATO,\n    CABALLO,\n    OTROS,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Veterinaria {\n    nombre: String,\n    direccion: String,\n    id: i32,\n    atenciones: VecDeque\u003cAtencion\u003e,\n    atenciones_realizadas: Vec\u003cAtencion\u003e,\n    archivo_atenciones: PathBuf,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Atencion {\n    mascota: Mascota,\n    diagnostico_final: String,\n    tratamiento: String,\n    fecha: Option\u003cFecha\u003e,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Mascota {\n    nombre: String,\n    edad: String,\n    tipo: TipoAnimal,\n    dueño: Dueño,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Dueño {\n    nombre: String,\n    direccion: String,\n    telefono: u32,\n}\n\npub fn compare_owners(owner1: \u0026Dueño, owner2: \u0026Dueño) -\u003e bool {\n    owner1.direccion == owner2.direccion \u0026\u0026\n    owner1.nombre == owner2.nombre \u0026\u0026\n    owner1.telefono == owner2.telefono\n}\n\npub fn compare_type(type1: \u0026TipoAnimal, type2: \u0026TipoAnimal)  -\u003e bool{\n    match (type1, type2) {\n        (TipoAnimal::CABALLO, TipoAnimal::CABALLO) =\u003e true,\n        (TipoAnimal::PERRO, TipoAnimal::PERRO) =\u003e true,\n        (TipoAnimal::GATO, TipoAnimal::GATO) =\u003e true,\n        (TipoAnimal::OTROS, TipoAnimal::OTROS) =\u003e true,\n        _ =\u003e false, \n    }\n}\n\npub fn compare_pets (mascota1: \u0026Mascota, mascota2: \u0026Mascota) -\u003e bool {\n    compare_owners(\u0026mascota1.dueño, \u0026mascota2.dueño) \u0026\u0026\n    mascota1.edad == mascota2.edad \u0026\u0026\n    mascota1.nombre == mascota2.nombre \u0026\u0026\n    compare_type(\u0026mascota1.tipo, \u0026mascota2.tipo)\n}\n\nfn compare_fecha(fecha1: \u0026Option\u003cFecha\u003e, fecha2: \u0026Option\u003cFecha\u003e) -\u003e bool {\n    match (fecha1, fecha2) {\n        (Some(f1), Some(f2)) =\u003e f1.dia == f2.dia \u0026\u0026 f1.mes == f2.mes \u0026\u0026 f1.año == f2.año,\n        (None, None) =\u003e true, // Ambas son None → consideradas iguales\n        _ =\u003e false,           // Una tiene valor y la otra no → distintas\n    }\n}\n\n\n\npub fn compare_atencion(atencion1: \u0026Atencion, atencion2: \u0026Atencion) -\u003e bool {\n    atencion1.diagnostico_final == atencion2.diagnostico_final \u0026\u0026\n    compare_fecha(\u0026atencion1.fecha, \u0026atencion2.fecha) \u0026\u0026\n    atencion1.tratamiento == atencion2.tratamiento \u0026\u0026\n    compare_pets(\u0026atencion1.mascota, \u0026atencion2.mascota)\n}\n\n\nenum ErroresPersonalizados {\n    ErrorArchivo,\n    MascotaNoEncontrada,\n    AtencionNoEncontrada,\n}\n\nimpl Veterinaria {\n    fn new(nombre: String, direccion: String, id: i32, archivo_atenciones: String) -\u003e Veterinaria {\n        let path = PathBuf::from(archivo_atenciones);\n        Veterinaria {\n            nombre,\n            direccion,\n            id,\n            atenciones: VecDeque::new(),\n            atenciones_realizadas: Vec::new(),\n            archivo_atenciones: path,\n        }\n    }\n\n    pub fn cargar_al_archivo(\u0026mut self, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut archivo: File = match File::create(self.archivo_atenciones.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        let atencion_serializada = serde_json::to_string(\u0026atencion).unwrap();\n        match archivo.write(\u0026atencion_serializada.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(_) =\u003e Ok(()),\n        }\n    }\n\n    pub fn agregar_nueva_mascota(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion = Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_back(nueva_atencion.clone());\n        self.cargar_al_archivo(\u0026nueva_atencion.clone());\n    }\n\n    pub fn cargar_al_inicio_del_archivo(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let file = std::fs::OpenOptions::new()\n            .read(true)\n            .write(true)\n            .open(\u0026self.archivo_atenciones)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n    \n        let writer = std::io::BufWriter::new(\u0026file);\n        serde_json::to_writer(writer, \u0026self.atenciones)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n        \n        Ok(())\n    }\n\n    fn agregar_mascota_maxima_prioridad(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion= Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_front(nueva_atencion.clone());\n        //Tendría que hacer que la atención nueva también esté en el archivo al inicio (para que persista con el orden en el que se encuentran los datos en la estructura).\n        self.cargar_al_inicio_del_archivo();\n    }\n\n    fn atender_mascota(\u0026mut self) -\u003e Option\u003cMascota\u003e{\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            return Some(mascota_atendida.mascota);\n            //Está bien modificar el archivo acá???\n            //Tendría que eliminar a la mascota de atenciones.\n            //Tendría que modificar mi atender mascota original para que lo agregue a atenciones realizadas, no?\n\n        } \n        None\n    }\n\n    fn eliminar_mascota(\u0026mut self, mascota: Mascota) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        //Find pet.\n        let mut indice_mascota_retirada:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_pets(\u0026self.atenciones[i].mascota,\u0026 mascota) {\n                indice_mascota_retirada= i as i32;\n                break;\n            }\n        }\n        //Delete pet.\n        if indice_mascota_retirada != -1 { //If I found the pet.\n            self.atenciones.remove(indice_mascota_retirada as usize);\n\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n\n        \n    }\n\n    fn registrar_atencion(\u0026mut self, tratamiento: String, diagnostico: String, fecha: Option\u003cFecha\u003e) {\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            let atencion_hecha= Atencion {\n                mascota: mascota_atendida.mascota,\n                diagnostico_final: diagnostico,\n                tratamiento: tratamiento,\n                fecha,\n            };\n\n            self.atenciones_realizadas.push(atencion_hecha);\n        };\n    }\n\n    fn buscar_atencion(\u0026self, nombre_mascota: String, nombre_dueño: String, telefono: u32) -\u003e Option\u003cAtencion\u003e {\n        for atencion in self.atenciones.iter() {\n            if atencion.mascota.nombre == nombre_mascota \u0026\u0026 atencion.mascota.dueño.nombre == nombre_dueño \u0026\u0026 atencion.mascota.dueño.telefono == telefono {\n                return Some(atencion.clone());\n            }\n        }\n        None\n    }\n\n    fn modificar_diagnostico(\u0026mut self, diagnostico_nuevo: String, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n        //Modify diagnostic.\n        if indice_atencion!= -1 { //If I found the attention.\n            self.atenciones[indice_atencion as usize].diagnostico_final = diagnostico_nuevo;\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n    }\n\n    fn modificar_fecha(\u0026mut self, fecha_nueva: Option\u003cFecha\u003e, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 { \n            self.atenciones[indice_atencion as usize].fecha = fecha_nueva;\n\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n    }\n\n    fn eliminar_atencion (\u0026mut self, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 {\n            self.atenciones.remove(indice_atencion as usize);\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n    }\n}\n\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tp03::ej03::Fecha;\n\n    fn crear_dueño() -\u003e Dueño {\n        Dueño {\n            nombre: String::from(\"Juan Perez\"),\n            direccion: String::from(\"Calle Falsa 123\"),\n            telefono: 12345678,\n        }\n    }\n\n    fn crear_mascota(nombre: \u0026str, tipo: TipoAnimal) -\u003e Mascota {\n        Mascota {\n            nombre: String::from(nombre),\n            edad: String::from(\"5\"),\n            tipo,\n            dueño: crear_dueño(),\n        }\n    }\n\n    fn crear_fecha() -\u003e Option\u003cFecha\u003e {\n        Some(Fecha { dia: 1, mes: 1, año: 2024 })\n    }\n\n    #[test]\n    fn test_agregar_nueva_mascota() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 1\"), String::from(\"Arg\"), 1, String::from(path));\n        let mascota = crear_mascota(\"Firulais\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        assert_eq!(vet.atenciones.len(), 1);\n    }\n\n    #[test]\n    fn test_agregar_mascota_maxima_prioridad() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 2\"), String::from(\"Arg \"), 2, String::from(path));\n        let m1 = crear_mascota(\"Gato\", TipoAnimal::GATO);\n        let m2 = crear_mascota(\"Caballo\", TipoAnimal::CABALLO);\n\n        vet.agregar_nueva_mascota(m1.clone(), crear_fecha());\n        vet.agregar_mascota_maxima_prioridad(m2.clone(), crear_fecha());\n\n        assert_eq!(vet.atenciones.front().unwrap().mascota.nombre, \"Caballo\");\n    }\n\n    #[test]\n    fn test_atender_mascota() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 3\"), String::from(\"Arg\"), 3, String::from(path));\n        let mascota = crear_mascota(\"Toby\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        let atendido = vet.atender_mascota();\n\n        assert!(atendido.is_some());\n        assert_eq!(atendido.unwrap().nombre, \"Toby\");\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_registrar_atencion() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 4\"), String::from(\"Arg\"), 4 , String::from(path));\n        let mascota = crear_mascota(\"Rex\", TipoAnimal::PERRO);\n        let fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        vet.registrar_atencion(String::from(\"Antibióticos\"), String::from(\"Infección\"), fecha.clone());\n\n        assert_eq!(vet.atenciones.len(), 0);\n        assert_eq!(vet.atenciones_realizadas.len(), 1);\n        let atendida = \u0026vet.atenciones_realizadas[0];\n        assert_eq!(atendida.mascota.nombre, \"Rex\");\n        assert_eq!(atendida.tratamiento, \"Antibióticos\");\n        assert_eq!(atendida.diagnostico_final, \"Infección\");\n        assert!(compare_fecha(\u0026atendida.fecha, \u0026fecha));\n    }\n\n    #[test]\n    fn test_eliminar_mascota() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 5\"), String::from(\"Zoológico\"), 5, String::from(path));\n        let mascota = crear_mascota(\"Milo\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        assert_eq!(vet.atenciones.len(), 1);\n\n        vet.eliminar_mascota(mascota);\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_buscar_atencion() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        let resultado = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert!(resultado.is_some());\n        assert_eq!(resultado.unwrap().mascota.nombre, \"Rocky\");\n    }\n\n    #[test]\n    fn test_modificar_diagnostico() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert!(atencion.is_some());\n        vet.modificar_diagnostico(\"Resfrio\".to_string(), \u0026atencion.unwrap());\n\n        let updated_atencion =  vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n        assert!(updated_atencion.is_some());\n        atencion = Some(updated_atencion.unwrap());\n\n        assert_eq!(atencion.unwrap().diagnostico_final, String::from(\"Resfrio\")); //Ok.\n    }\n\n    #[test]\n    fn test_modificar_fecha() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n        let mut fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), fecha);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        let fecha_nueva = Fecha {\n            año: 2025,\n            dia: 24,\n            mes: 12,\n        };\n        vet.modificar_fecha(Some(fecha_nueva), \u0026atencion.unwrap());\n\n        let updated_atencion =  vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n        assert!(updated_atencion.is_some());\n        atencion = Some(updated_atencion.unwrap());\n\n        assert_eq!(atencion.clone().unwrap().fecha.unwrap().año, 2025);\n        assert_eq!(atencion.clone().unwrap().fecha.unwrap().mes, 12);\n        assert_eq!(atencion.clone().unwrap().fecha.unwrap().dia, 24);\n    }\n\n    #[test]\n    fn test_eliminar_atencion() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n        let mut fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), fecha);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert_eq!(vet.atenciones.len(), 1); //Estado inicial.\n\n        vet.eliminar_atencion(\u0026atencion.unwrap());\n        assert_eq!(vet.atenciones.len(), 0); //Ok.\n    }\n\n    #[test]\n    fn test_agregar_mascota_maxima_prioridad_archivo() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 2\"), String::from(\"Arg \"), 2, String::from(path));\n        let m1 = crear_mascota(\"Gato\", TipoAnimal::GATO);\n        let m2 = crear_mascota(\"Caballo\", TipoAnimal::CABALLO);\n\n        vet.agregar_nueva_mascota(m1.clone(), crear_fecha());\n        vet.agregar_mascota_maxima_prioridad(m2.clone(), crear_fecha());\n\n        assert_eq!(vet.atenciones.front().unwrap().mascota.nombre, \"Caballo\");\n        //En el archivo aparece Caballo primero!. Ok.\n    }\n\n    #[test]\n    fn test_eliminar_mascota_nuevo() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 5\"), String::from(\"Zoológico\"), 5, String::from(path));\n        let mascota = crear_mascota(\"Milo\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        assert_eq!(vet.atenciones.len(), 1);\n\n        assert!(vet.eliminar_mascota(mascota).is_ok());\n        assert_eq!(vet.atenciones.len(), 0);\n\n        let mascota2 = crear_mascota(\"Pepe\", TipoAnimal::GATO);\n        assert!(vet.eliminar_mascota(mascota2.clone()).is_err());\n\n    }\n\n    #[test]\n    fn eliminar_atencion_nuevo() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n        let mut fecha = crear_fecha();\n        let mascota2 = crear_mascota(\"Pepe\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), fecha);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert_eq!(vet.atenciones.len(), 1); //Estado inicial.\n\n        assert!(vet.eliminar_atencion(\u0026atencion.unwrap()).is_ok());\n        assert_eq!(vet.atenciones.len(), 0); //Ok.\n\n        \n        /*let mut atencion2= Atencion { mascota2.clone(), String::from(\"fiebre\"), String::from(\"antibioticos\"), None}; //Por qué no me deja???\n        assert!(vet.eliminar_atencion(\u0026atencion2).is_err());*/\n\n    }\n}\n\n\n","traces":[{"line":53,"address":[3038224],"length":1,"stats":{"Line":2}},{"line":54,"address":[3038247,3038264],"length":1,"stats":{"Line":2}},{"line":55,"address":[3038280],"length":1,"stats":{"Line":2}},{"line":56,"address":[3038300],"length":1,"stats":{"Line":2}},{"line":59,"address":[3038336,3038390],"length":1,"stats":{"Line":1}},{"line":60,"address":[3038346,3038392],"length":1,"stats":{"Line":6}},{"line":69,"address":[3038496],"length":1,"stats":{"Line":2}},{"line":70,"address":[3038536,3038519],"length":1,"stats":{"Line":2}},{"line":71,"address":[3038552],"length":1,"stats":{"Line":2}},{"line":72,"address":[3038580],"length":1,"stats":{"Line":2}},{"line":73,"address":[3038600],"length":1,"stats":{"Line":5}},{"line":76,"address":[3038640],"length":1,"stats":{"Line":3}},{"line":77,"address":[3038650],"length":1,"stats":{"Line":1}},{"line":78,"address":[3038719,3038780],"length":1,"stats":{"Line":2}},{"line":80,"address":[3038773],"length":1,"stats":{"Line":0}},{"line":86,"address":[3038832],"length":1,"stats":{"Line":1}},{"line":87,"address":[3038872,3038855],"length":1,"stats":{"Line":2}},{"line":88,"address":[3038888],"length":1,"stats":{"Line":1}},{"line":89,"address":[3038922],"length":1,"stats":{"Line":1}},{"line":90,"address":[3038956],"length":1,"stats":{"Line":1}},{"line":101,"address":[3039542,3039611,3038992],"length":1,"stats":{"Line":1}},{"line":102,"address":[3039043],"length":1,"stats":{"Line":1}},{"line":107,"address":[3039199],"length":1,"stats":{"Line":2}},{"line":108,"address":[3039255],"length":1,"stats":{"Line":2}},{"line":113,"address":[3040579,3040585,3039648],"length":1,"stats":{"Line":1}},{"line":114,"address":[3039674],"length":1,"stats":{"Line":5}},{"line":115,"address":[3039715,3040602,3039829],"length":1,"stats":{"Line":0}},{"line":116,"address":[3039791],"length":1,"stats":{"Line":1}},{"line":119,"address":[3039819,3040024],"length":1,"stats":{"Line":7}},{"line":120,"address":[3040062,3040130],"length":1,"stats":{"Line":7}},{"line":121,"address":[3040228,3040332,3040524],"length":1,"stats":{"Line":0}},{"line":122,"address":[3040305],"length":1,"stats":{"Line":6}},{"line":126,"address":[3041225,3040624],"length":1,"stats":{"Line":1}},{"line":129,"address":[3040740],"length":1,"stats":{"Line":3}},{"line":130,"address":[3040795],"length":1,"stats":{"Line":1}},{"line":134,"address":[3041022,3041093],"length":1,"stats":{"Line":4}},{"line":135,"address":[3041128],"length":1,"stats":{"Line":4}},{"line":138,"address":[3041711,3041705,3041248],"length":1,"stats":{"Line":1}},{"line":139,"address":[3041359,3041434,3041268],"length":1,"stats":{"Line":2}},{"line":142,"address":[3041314],"length":1,"stats":{"Line":1}},{"line":143,"address":[2813776,2813785],"length":1,"stats":{"Line":1}},{"line":145,"address":[3041483],"length":1,"stats":{"Line":1}},{"line":146,"address":[3041536,3041638,3041688,3041577],"length":1,"stats":{"Line":2}},{"line":147,"address":[3041562,3041628],"length":1,"stats":{"Line":1}},{"line":149,"address":[3041656],"length":1,"stats":{"Line":1}},{"line":152,"address":[3042246,3041728],"length":1,"stats":{"Line":1}},{"line":155,"address":[3041844],"length":1,"stats":{"Line":1}},{"line":156,"address":[3041899],"length":1,"stats":{"Line":1}},{"line":160,"address":[3042126,3042194],"length":1,"stats":{"Line":2}},{"line":162,"address":[3042221],"length":1,"stats":{"Line":1}},{"line":165,"address":[3042272,3042697,3042703],"length":1,"stats":{"Line":1}},{"line":166,"address":[3042296],"length":1,"stats":{"Line":1}},{"line":167,"address":[3042379],"length":1,"stats":{"Line":1}},{"line":173,"address":[3042607],"length":1,"stats":{"Line":0}},{"line":176,"address":[3042720,3043746,3043724],"length":1,"stats":{"Line":1}},{"line":178,"address":[3042748],"length":1,"stats":{"Line":2}},{"line":179,"address":[3042759,3042826],"length":1,"stats":{"Line":4}},{"line":180,"address":[3042972,3043020],"length":1,"stats":{"Line":4}},{"line":181,"address":[3043049],"length":1,"stats":{"Line":2}},{"line":186,"address":[3042995],"length":1,"stats":{"Line":2}},{"line":187,"address":[3043140,3043087],"length":1,"stats":{"Line":4}},{"line":190,"address":[3043263,3043155,3043734,3043390],"length":1,"stats":{"Line":4}},{"line":193,"address":[3043219],"length":1,"stats":{"Line":2}},{"line":194,"address":[2813872,2813881],"length":1,"stats":{"Line":2}},{"line":196,"address":[3043448],"length":1,"stats":{"Line":2}},{"line":197,"address":[3043548,3043695,3043504,3043618],"length":1,"stats":{"Line":4}},{"line":198,"address":[2813929,2813920],"length":1,"stats":{"Line":2}},{"line":200,"address":[3043636],"length":1,"stats":{"Line":2}},{"line":202,"address":[3043058],"length":1,"stats":{"Line":1}},{"line":208,"address":[3043760,3044634,3044507],"length":1,"stats":{"Line":1}},{"line":209,"address":[3043800,3043889],"length":1,"stats":{"Line":2}},{"line":211,"address":[3043973],"length":1,"stats":{"Line":1}},{"line":217,"address":[3044334],"length":1,"stats":{"Line":1}},{"line":221,"address":[3044672,3045194],"length":1,"stats":{"Line":2}},{"line":222,"address":[3044720,3044787],"length":1,"stats":{"Line":6}},{"line":223,"address":[3045050,3044936],"length":1,"stats":{"Line":6}},{"line":224,"address":[3045128],"length":1,"stats":{"Line":4}},{"line":227,"address":[3044967],"length":1,"stats":{"Line":0}},{"line":230,"address":[3045216,3046522,3046462],"length":1,"stats":{"Line":1}},{"line":232,"address":[3045252],"length":1,"stats":{"Line":1}},{"line":233,"address":[3045355,3045287],"length":1,"stats":{"Line":2}},{"line":234,"address":[3045541,3045501],"length":1,"stats":{"Line":2}},{"line":235,"address":[3045578],"length":1,"stats":{"Line":1}},{"line":240,"address":[3045524],"length":1,"stats":{"Line":1}},{"line":241,"address":[3046500,3045624,3045713],"length":1,"stats":{"Line":1}},{"line":243,"address":[3045906,3046472,3046014,3046141],"length":1,"stats":{"Line":2}},{"line":246,"address":[3045970],"length":1,"stats":{"Line":1}},{"line":247,"address":[2813977,2813968],"length":1,"stats":{"Line":1}},{"line":249,"address":[3046199],"length":1,"stats":{"Line":1}},{"line":250,"address":[3046299,3046255,3046369,3046433],"length":1,"stats":{"Line":2}},{"line":251,"address":[2814025,2814016],"length":1,"stats":{"Line":1}},{"line":253,"address":[3046387],"length":1,"stats":{"Line":1}},{"line":255,"address":[3045587],"length":1,"stats":{"Line":0}},{"line":259,"address":[3047281,3046560],"length":1,"stats":{"Line":1}},{"line":261,"address":[3046590],"length":1,"stats":{"Line":1}},{"line":262,"address":[3046598],"length":1,"stats":{"Line":1}},{"line":263,"address":[3046685],"length":1,"stats":{"Line":1}},{"line":264,"address":[3046734],"length":1,"stats":{"Line":1}},{"line":269,"address":[3046720],"length":1,"stats":{"Line":1}},{"line":270,"address":[3046769],"length":1,"stats":{"Line":1}},{"line":273,"address":[3046816,3047002,3046913],"length":1,"stats":{"Line":2}},{"line":276,"address":[3046868],"length":1,"stats":{"Line":1}},{"line":277,"address":[2814073,2814064],"length":1,"stats":{"Line":1}},{"line":279,"address":[3047051],"length":1,"stats":{"Line":1}},{"line":280,"address":[3047148,3047218,3047261,3047104],"length":1,"stats":{"Line":2}},{"line":281,"address":[2814121,2814112],"length":1,"stats":{"Line":1}},{"line":283,"address":[3047236],"length":1,"stats":{"Line":1}},{"line":285,"address":[3046740],"length":1,"stats":{"Line":0}},{"line":289,"address":[3048055,3047312,3048049],"length":1,"stats":{"Line":2}},{"line":291,"address":[3047337],"length":1,"stats":{"Line":1}},{"line":292,"address":[3047377,3047345],"length":1,"stats":{"Line":4}},{"line":293,"address":[3047432],"length":1,"stats":{"Line":2}},{"line":294,"address":[3047481],"length":1,"stats":{"Line":2}},{"line":299,"address":[3047467],"length":1,"stats":{"Line":2}},{"line":300,"address":[3047516],"length":1,"stats":{"Line":2}},{"line":302,"address":[3047545,3047651,3047752],"length":1,"stats":{"Line":2}},{"line":305,"address":[3047597],"length":1,"stats":{"Line":1}},{"line":306,"address":[2814169,2814160],"length":1,"stats":{"Line":1}},{"line":308,"address":[3047810],"length":1,"stats":{"Line":1}},{"line":309,"address":[3047910,3047866,3048026,3047980],"length":1,"stats":{"Line":2}},{"line":310,"address":[2814208,2814217],"length":1,"stats":{"Line":1}},{"line":312,"address":[3047998],"length":1,"stats":{"Line":1}},{"line":314,"address":[3047487],"length":1,"stats":{"Line":0}}],"covered":115,"coverable":123},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej04.rs"],"content":"use std::collections::HashMap;\nuse crate::tp03::ej03::Fecha;\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n#[derive(Clone, Serialize, Deserialize)]\nenum Genero {\n    Novela,\n    Infantil,\n    Tecnico,\n    Otros\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nenum EstadoPrestamo {\n    Devuelto,\n    EnPrestamo,\n}\n\n#[derive(Clone)]\nstruct Biblioteca {\n    nombre: String,\n    direccion: String,\n    libros: HashMap\u003cu32, Libro\u003e, //Key: ISBN.\n    prestamos: Vec\u003cPrestamo\u003e,\n    archivo_libros: PathBuf,\n    archivo_prestamos: PathBuf,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Libro {\n    isbn: u32,\n    titulo: String,\n    copias_disponiles: u32,\n    autor: String,\n    numero_paginas: u32,\n    genero: Genero,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Prestamo {\n    isbn_libro: u32,\n    cliente: Cliente,\n    fecha_vencimiento: Fecha,\n    fecha_devolucion: Fecha, \n    estado: EstadoPrestamo,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Cliente {\n    nombre: String,\n    telefono: u32,\n    correo: String,\n}\n\n#[derive(Debug)]\nenum ErroresPersonalizados {\n    ErrorArchivo,\n    LibroNoEncontrado,\n    PrestamoNoPosible,\n}\n\npub fn no_devolvio (estado: \u0026EstadoPrestamo) -\u003e bool {\n    match estado {\n        (EstadoPrestamo::EnPrestamo) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare_clientes (cliente1: \u0026Cliente, cliente2: \u0026Cliente) -\u003e bool {\n    cliente1.nombre == cliente2.nombre \u0026\u0026\n    cliente1.correo == cliente2.correo \u0026\u0026\n    cliente1.telefono == cliente2.telefono\n}\n\nimpl Biblioteca {\n\n    pub fn cargar_al_archivo_libros(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut archivo_libros:File = match File::create(self.archivo_libros.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        serde_json::to_writer(\u0026archivo_libros, \u0026self.libros)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    pub fn cargar_al_archivo_prestamos(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut archivo_prestamos:File = match File::create(self.archivo_prestamos.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        serde_json::to_writer(\u0026archivo_prestamos, \u0026self.prestamos)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    fn obtener_cantidad_copias (\u0026self, libro: \u0026Libro) -\u003e u32 {\n        if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            return book.copias_disponiles;\n        } else {\n            return 0;\n        } \n    }\n\n    pub fn modificar_campo_json_libro(\u0026mut self, isbn: u32, nuevas_copias: u32) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Open the json file.\n        \n        let file = File::open(self.archivo_libros.clone()).map_err(|_| ErroresPersonalizados::ErrorArchivo)?; \n        \n        let mut libros_deserializados: HashMap\u003cu32, Libro\u003e  = serde_json::from_reader(file)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n\n        //Modify the specific field.\n        if let Some(libro) = libros_deserializados.get_mut(\u0026isbn.clone()) {\n            libro.copias_disponiles = nuevas_copias;\n        } else {\n            return Err(ErroresPersonalizados::LibroNoEncontrado);\n        }\n\n        //Serialize the updated data structure back into JSON format.\n\n        let file = File::create(self.archivo_libros.clone()).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n        serde_json::to_writer(file, \u0026libros_deserializados).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    pub fn modificar_campo_json_prestmo(\u0026mut self, estado: \u0026EstadoPrestamo, cliente: \u0026Cliente, isbn: \u0026u32) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Open the json file.\n        \n        let file = File::open(self.archivo_prestamos.clone()).map_err(|_| ErroresPersonalizados::ErrorArchivo)?; \n        \n        let mut prestamos_deserializados: Vec\u003cPrestamo\u003e  = serde_json::from_reader(file)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n\n        //Modify the specific field.\n        for prestamo in prestamos_deserializados.iter_mut() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == isbn.clone() {\n                prestamo.estado = estado.clone();\n                break; //Si encontré el cliente no hay necesidad de seguir buscando.\n            }\n        }\n\n        //Serialize the updated data structure back into JSON format.\n\n        let file = File::create(self.archivo_prestamos.clone()).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n        serde_json::to_writer(file, \u0026prestamos_deserializados).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    fn decrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let (isbn, copias) = {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles -= 1;\n                (book.isbn, book.copias_disponiles)\n            } else {\n                return Err(ErroresPersonalizados::LibroNoEncontrado)?; \n            }\n        }; // Mutable borrow ends here\n        \n        self.modificar_campo_json_libro(isbn, copias); //Debería hacer que se propague el result de esto?\n        Ok(())\n    }\n\n    fn incrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let (isbn, copias) = {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles += 1;\n                (book.isbn, book.copias_disponiles)\n            } else {\n                return Err(ErroresPersonalizados::LibroNoEncontrado); \n            }\n        }; // Mutable borrow ends here\n        \n        self.modificar_campo_json_libro(isbn, copias); //Debería hacer que se propague el result de esto?\n        Ok(())\n    }\n\n    fn contar_prestamos_cliente (\u0026self, cliente: \u0026Cliente) -\u003e u32 {\n        let mut cant_prestamos= 0;\n\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) {\n                cant_prestamos += 1;\n            }\n        }\n        cant_prestamos\n    }\n\n    fn realizar_prestamo (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Check if the book exists and has available copies.\n        let mut updated_loan: Option\u003cPrestamo\u003e = None;\n        let mut updated_book: Option\u003cLibro\u003e = None;\n\n        let okay_prestamo = if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            book.copias_disponiles \u003e= 1\n        } else {\n            false\n        };\n\n        //Check if the client has fewer than 5 loans.\n        if okay_prestamo \u0026\u0026 self.contar_prestamos_cliente(cliente) \u003c 5 {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles -= 1;\n                updated_book = Some(book.clone());\n                //Crear el préstamo en estado en prestamo.\n                self.prestamos.push(Prestamo {\n                    isbn_libro: 999, // libro cualquiera\n                    cliente: cliente.clone(),\n                    fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n                    fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n                    estado: EstadoPrestamo::EnPrestamo,\n                });\n            }\n        } else  {\n            return Err(ErroresPersonalizados::PrestamoNoPosible);\n        }\n\n\n\n        //Mod arch libro (copias)\n        if updated_book.clone().is_some() {\n            self.modificar_campo_json_libro(updated_book.clone().unwrap().isbn.clone(), updated_book.clone().unwrap().copias_disponiles.clone()); \n            self.cargar_al_archivo_prestamos();\n        }\n\n        Ok(())\n    }\n\n\n    fn prestamos_vencer(\u0026self, cant_dias: u32, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut fecha_limite = fecha_actual.clone();\n        fecha_limite.sumar_dias(cant_dias);\n\n        let mut lista_prestamos_vencer = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            let fecha_igual = prestamo.fecha_vencimiento.dia == fecha_actual.dia \u0026\u0026 prestamo.fecha_vencimiento.mes == fecha_actual.mes \u0026\u0026 prestamo.fecha_vencimiento.año == fecha_actual.año;\n\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_limite) \u0026\u0026  // fecha_vencimiento \u003c= fecha_limite\n            (prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual) || fecha_igual)  // fecha_vencimiento \u003e= fecha_actual\n            {\n                lista_prestamos_vencer.push(prestamo.clone());\n            }\n        }\n         lista_prestamos_vencer    \n    }\n\n    fn prestamos_vencidos(\u0026self, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut lista_prestamos_vencidos = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual)\n            {\n                lista_prestamos_vencidos.push(prestamo.clone());\n            }\n        }\n        lista_prestamos_vencidos \n    }\n\n    fn buscar_prestamo (\u0026self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Option\u003cPrestamo\u003e {\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                return Some(prestamo.clone());\n            }\n        }\n        None\n    }\n\n    fn devolver_libro (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut updated_book: Option\u003cLibro\u003e = None;\n        let mut updated_loan: Option\u003cPrestamo\u003e = None;\n\n        for prestamo in self.prestamos.iter_mut() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                prestamo.estado= EstadoPrestamo::Devuelto;\n                if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                    book.copias_disponiles += 1;     \n                    updated_book = Some(book.clone());  \n                    updated_loan = Some(prestamo.clone());         \n                } else {\n                    return Err(ErroresPersonalizados::LibroNoEncontrado);\n                }\n\n                break; //Si encontré el cliente no hay necesidad de seguir buscando.\n            }\n        }\n\n        //Mod arch libro (copias)\n        if updated_book.clone().is_some() {\n            self.modificar_campo_json_libro(updated_book.clone().unwrap().isbn.clone(), updated_book.clone().unwrap().copias_disponiles.clone()); \n            \n            //Mod arch prest.\n            if updated_loan.clone().is_some() {\n                self.modificar_campo_json_prestmo(\u0026updated_loan.clone().unwrap().estado, \u0026updated_loan.clone().unwrap().cliente, \u0026updated_book.clone().unwrap().isbn);\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_obtener_cant_copias_libro() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        //Insertar libro.\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        let copias = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias, 7);\n    \n        //Libro no existente debe devolver 0\n        let libro_inexistente = Libro {\n            isbn: 999,\n            titulo: \"No existe\".to_string(),\n            copias_disponiles: 0,\n            autor: \"\".to_string(),\n            numero_paginas: 0,\n            genero: Genero::Otros,\n        };\n        let copias_inexistente = biblioteca.obtener_cantidad_copias(\u0026libro_inexistente);\n        assert_eq!(copias_inexistente, 0);\n    }\n\n    #[test]\n    fn test_decrementar_copias() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.decrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 6);\n    }\n\n    #[test]\n    fn test_incrementar_copias() {\n        let mut libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.incrementar_cantidad_copias(\u0026libro);\n\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 8);\n    }\n\n    #[test]\n    fn test_contar_prestamos_cliente() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n        let prestamo2 = Prestamo {\n            isbn_libro: libro2.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1, prestamo2],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\n        assert_eq!(cantidad, 2);\n    }\n\n    #[test]\n    fn test_realizar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            correo: \"juan@mail.com\".to_string(),\n        };\n    \n        let libro = Libro {\n            isbn: 101,\n            titulo: \"Libro Test\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor Test\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n    \n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Test\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        biblioteca.libros.insert(libro.isbn, libro.clone());\n    \n        // Cliente sin préstamos previos, debería poder tomar prestado\n        let exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(exito.is_ok());\n    \n        // Copias deberían reducirse en 1\n        let copias_restantes = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_restantes, libro.copias_disponiles - 1);\n    \n        // Simulamos que el cliente ya tiene 5 préstamos\n        for _ in 0..5 {\n            biblioteca.prestamos.push(Prestamo {\n                isbn_libro: 999, // libro cualquiera\n                cliente: cliente.clone(),\n                fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n                fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n                estado: EstadoPrestamo::EnPrestamo,\n            });\n        }\n    \n        // Ahora no debería permitir más préstamos\n        let no_exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(no_exito.is_err());\n    \n        // Copias no deberían cambiar porque no se hizo el préstamo\n        let copias_final = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_final, libro.copias_disponiles - 1);\n    }\n\n    #[test]\n    fn test_prestamos_a_vencer () {\n        let fecha_actual = Fecha { dia: 10, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n            nombre: \"Luis\".to_string(),\n            telefono: 5551234,\n            correo: \"luis@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"Libro de prueba\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n\n         // Préstamo que vence dentro de 5 días (día 14)\n        let prestamo_proximo = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 14, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo que vence después de 10 días (día 22)\n        let prestamo_lejano = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 22, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo ya devuelto, no debería aparecer\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 12, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 11, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo_proximo.clone(), prestamo_lejano, prestamo_devuelto],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        let prestamos_vencer = biblioteca.prestamos_vencer(5, \u0026fecha_actual);\n\n        // Sólo debería contener el préstamo que vence dentro de 5 días y está activo\n        assert_eq!(prestamos_vencer.len(), 1);\n\n    }\n\n    #[test]\n    fn test_prestamos_vencidos() {\n        let fecha_actual = Fecha { dia: 15, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n          nombre: \"Carlos\".to_string(),\n          telefono: 123456,\n          correo: \"carlos@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 1,\n            titulo: \"Libro X\".to_string(),\n            copias_disponiles: 1,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n\n        let prestamo_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_no_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 20, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 5, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 6, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblio Test\".to_string(),\n            direccion: \"Dirección\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![\n                prestamo_vencido.clone(),\n                prestamo_no_vencido,\n                prestamo_devuelto,\n            ],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        let vencidos = biblioteca.prestamos_vencidos(\u0026fecha_actual);\n\n        assert_eq!(vencidos.len(), 1);\n    }\n\n    #[test]\n    fn test_buscar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        assert!(biblioteca.buscar_prestamo(\u0026libro1, \u0026cliente).is_some());\n\n        //Busco uno que no exista;\n        assert!(biblioteca.buscar_prestamo(\u0026libro2, \u0026cliente).is_none())\n    }\n\n    #[test]\n    fn test_devolver_libro() {\n        let cliente = Cliente {\n            nombre: \"Roberto\".to_string(),\n            telefono: 555123789,\n            correo: \"roberto@mail.com\".to_string(),\n        };\n    \n        \n        let mut libro = Libro {\n            isbn: 42,\n            titulo: \"pepe\".to_string(),\n            copias_disponiles: 5,  // Inicialmente hay 5 copias\n            autor: \"Autor\".to_string(),\n            numero_paginas: 300,\n            genero: Genero::Novela,\n        };\n    \n        \n        let prestamo = Prestamo {\n            isbn_libro: libro.isbn.clone(),\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 15, mes: 6, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },  // Aún no devuelto\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        \n        let mut biblioteca = Biblioteca {\n            nombre: \"biblioteca\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn.clone(), libro.clone());\n        biblioteca.devolver_libro(\u0026libro, \u0026cliente);//Lo devuelvo.\n        let libro_devuelto = biblioteca.buscar_prestamo(\u0026libro, \u0026cliente);\n        let esta_devuelto = {\n            match libro_devuelto.unwrap().estado {\n                (EstadoPrestamo::Devuelto) =\u003e true,\n                _ =\u003e false,\n                \n            }\n        };\n\n        //println!(\"{}\", biblioteca.libros.len());\n        let updated_book = biblioteca.libros.get(\u0026libro.isbn.clone());\n        libro = updated_book.unwrap().clone();\n        assert_eq!(libro.copias_disponiles, 6); //Ok.\n\n        assert_eq!(esta_devuelto, true);\n    }\n\n    //Tests nuevos.\n    #[test]\n    fn test_cargar_al_archivo_libros() {\n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.clone().into(),\n            archivo_prestamos: path_prestamos.clone().into(),\n        };\n\n        biblioteca.libros.insert(1, libro1.clone());\n        biblioteca.libros.insert(2, libro2.clone());\n\n        assert_eq!(biblioteca.libros.len(), 2);\n        assert!(biblioteca.cargar_al_archivo_libros().is_ok()); //Ok.\n    }\n\n    #[test]\n    fn test_cargar_al_archivo_prestamos() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        assert!(biblioteca.cargar_al_archivo_prestamos().is_ok());\n    }\n\n    #[test]\n    fn test_decrementar_copias_nuevo() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.cargar_al_archivo_libros();\n\n\n        biblioteca.decrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 6);\n    }\n\n\n    #[test]\n    fn test_incrementar_copias_nuevo() {\n        let mut libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let mut libro1 = Libro {\n            isbn: 000,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.libros.insert(libro1.isbn, libro1.clone());\n        biblioteca.cargar_al_archivo_libros();\n        \n        biblioteca.incrementar_cantidad_copias(\u0026libro);\n\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 8);\n    }\n\n    #[test]\n    fn test_devolver_libro_nuevo() {\n        let cliente = Cliente {\n            nombre: \"Roberto\".to_string(),\n            telefono: 555123789,\n            correo: \"roberto@mail.com\".to_string(),\n        };\n    \n        \n        let mut libro = Libro {\n            isbn: 42,\n            titulo: \"pepe\".to_string(),\n            copias_disponiles: 5,  // Inicialmente hay 5 copias\n            autor: \"Autor\".to_string(),\n            numero_paginas: 300,\n            genero: Genero::Novela,\n        };\n    \n        \n        let prestamo = Prestamo {\n            isbn_libro: libro.isbn.clone(),\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 15, mes: 6, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },  // Aún no devuelto\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        \n        let mut biblioteca = Biblioteca {\n            nombre: \"biblioteca\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn.clone(), libro.clone());\n        biblioteca.cargar_al_archivo_libros();\n        biblioteca.cargar_al_archivo_prestamos();\n\n\n        biblioteca.devolver_libro(\u0026libro, \u0026cliente);//Lo devuelvo.\n        let libro_devuelto = biblioteca.buscar_prestamo(\u0026libro, \u0026cliente);\n        let esta_devuelto = {\n            match libro_devuelto.unwrap().estado {\n                (EstadoPrestamo::Devuelto) =\u003e true,\n                _ =\u003e false,\n                \n            }\n        };\n\n        //println!(\"{}\", biblioteca.libros.len());\n        let updated_book = biblioteca.libros.get(\u0026libro.isbn.clone());\n        libro = updated_book.unwrap().clone();\n        assert_eq!(libro.copias_disponiles, 6); //Ok.\n\n        assert_eq!(esta_devuelto, true);\n\n        //El archivo de libros se modifica. Ok.\n        //El archivo de préstamos se modifica. Ok.\n\n    }\n\n\n    #[test]\n    fn test_realizar_prestamo_nuevo() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            correo: \"juan@mail.com\".to_string(),\n        };\n    \n        let libro = Libro {\n            isbn: 101,\n            titulo: \"Libro Test\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor Test\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n    \n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Test\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.cargar_al_archivo_libros();\n        biblioteca.cargar_al_archivo_prestamos();\n    \n        // Cliente sin préstamos previos, debería poder tomar prestado\n        let exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(exito.is_ok());\n    \n        // Copias deberían reducirse en 1\n        let copias_restantes = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_restantes, libro.copias_disponiles - 1);\n\n        //El archivo de libros y de préstamos se modifica. Ok.\n    }\n}","traces":[{"line":69,"address":[2847952],"length":1,"stats":{"Line":1}},{"line":70,"address":[2847957],"length":1,"stats":{"Line":1}},{"line":76,"address":[2847984],"length":1,"stats":{"Line":1}},{"line":77,"address":[2848016,2848007],"length":1,"stats":{"Line":3}},{"line":78,"address":[2848032],"length":1,"stats":{"Line":1}},{"line":79,"address":[2848060],"length":1,"stats":{"Line":1}},{"line":84,"address":[2848096,2848599,2848605],"length":1,"stats":{"Line":1}},{"line":85,"address":[2848116],"length":1,"stats":{"Line":1}},{"line":86,"address":[2848157,2848622,2848259],"length":1,"stats":{"Line":0}},{"line":87,"address":[2848218],"length":1,"stats":{"Line":1}},{"line":90,"address":[2848471,2848235,2848532,2848582],"length":1,"stats":{"Line":2}},{"line":91,"address":[2848456,2848522],"length":1,"stats":{"Line":1}},{"line":93,"address":[2848550],"length":1,"stats":{"Line":1}},{"line":96,"address":[2849143,2848640,2849149],"length":1,"stats":{"Line":1}},{"line":97,"address":[2848660],"length":1,"stats":{"Line":1}},{"line":98,"address":[2848701,2848803,2849166],"length":1,"stats":{"Line":0}},{"line":99,"address":[2848762],"length":1,"stats":{"Line":1}},{"line":102,"address":[2849076,2849015,2849126,2848779],"length":1,"stats":{"Line":2}},{"line":103,"address":[2849000,2849066],"length":1,"stats":{"Line":1}},{"line":105,"address":[2849094],"length":1,"stats":{"Line":1}},{"line":108,"address":[2849184],"length":1,"stats":{"Line":1}},{"line":109,"address":[2849198],"length":1,"stats":{"Line":2}},{"line":110,"address":[2849254],"length":1,"stats":{"Line":1}},{"line":112,"address":[2849263],"length":1,"stats":{"Line":1}},{"line":116,"address":[2849280,2850489,2850540],"length":1,"stats":{"Line":1}},{"line":119,"address":[2849320],"length":1,"stats":{"Line":1}},{"line":121,"address":[2850534,2849626,2849681,2849519],"length":1,"stats":{"Line":2}},{"line":122,"address":[2849671,2849603],"length":1,"stats":{"Line":1}},{"line":126,"address":[2849882,2849798],"length":1,"stats":{"Line":2}},{"line":127,"address":[2849946],"length":1,"stats":{"Line":1}},{"line":129,"address":[2849968],"length":1,"stats":{"Line":2}},{"line":134,"address":[3251529,3251520],"length":1,"stats":{"Line":2}},{"line":135,"address":[2850217,2850453,2850298],"length":1,"stats":{"Line":2}},{"line":137,"address":[2850401],"length":1,"stats":{"Line":1}},{"line":140,"address":[2852046,2850576,2852004],"length":1,"stats":{"Line":2}},{"line":143,"address":[2850645],"length":1,"stats":{"Line":2}},{"line":145,"address":[2852037,2851051,2850880,2850990],"length":1,"stats":{"Line":3}},{"line":146,"address":[2851041,2850967],"length":1,"stats":{"Line":2}},{"line":150,"address":[2851211,2851144],"length":1,"stats":{"Line":4}},{"line":151,"address":[2851366,2851416],"length":1,"stats":{"Line":4}},{"line":152,"address":[2851457],"length":1,"stats":{"Line":0}},{"line":159,"address":[2851501,2851393,2852014],"length":1,"stats":{"Line":4}},{"line":160,"address":[2851952,2851710,2851791],"length":1,"stats":{"Line":4}},{"line":162,"address":[2851894],"length":1,"stats":{"Line":2}},{"line":165,"address":[2852080],"length":1,"stats":{"Line":1}},{"line":166,"address":[2852266],"length":1,"stats":{"Line":1}},{"line":167,"address":[2852099],"length":1,"stats":{"Line":1}},{"line":168,"address":[2852286,2852159,2852257],"length":1,"stats":{"Line":2}},{"line":169,"address":[2852260],"length":1,"stats":{"Line":1}},{"line":171,"address":[2852308,2852178],"length":1,"stats":{"Line":0}},{"line":175,"address":[2852274],"length":1,"stats":{"Line":1}},{"line":176,"address":[2852279],"length":1,"stats":{"Line":1}},{"line":179,"address":[2852352],"length":1,"stats":{"Line":2}},{"line":180,"address":[2852487],"length":1,"stats":{"Line":2}},{"line":181,"address":[2852371],"length":1,"stats":{"Line":2}},{"line":182,"address":[2852507,2852478,2852432],"length":1,"stats":{"Line":4}},{"line":183,"address":[2852481],"length":1,"stats":{"Line":2}},{"line":185,"address":[2852449],"length":1,"stats":{"Line":0}},{"line":189,"address":[2852495],"length":1,"stats":{"Line":2}},{"line":190,"address":[2852500],"length":1,"stats":{"Line":2}},{"line":193,"address":[2852544],"length":1,"stats":{"Line":1}},{"line":194,"address":[2852558],"length":1,"stats":{"Line":1}},{"line":196,"address":[2852607,2852566],"length":1,"stats":{"Line":2}},{"line":197,"address":[2852660,2852709],"length":1,"stats":{"Line":2}},{"line":198,"address":[2852711,2852685],"length":1,"stats":{"Line":1}},{"line":201,"address":[2852676],"length":1,"stats":{"Line":1}},{"line":204,"address":[2854161,2852736,2854155],"length":1,"stats":{"Line":1}},{"line":206,"address":[2852792],"length":1,"stats":{"Line":1}},{"line":207,"address":[2852797],"length":1,"stats":{"Line":1}},{"line":209,"address":[2852805,2852870,2852941],"length":1,"stats":{"Line":3}},{"line":210,"address":[2852925],"length":1,"stats":{"Line":1}},{"line":212,"address":[2852943],"length":1,"stats":{"Line":0}},{"line":216,"address":[2853005,2852951],"length":1,"stats":{"Line":2}},{"line":217,"address":[2853119,2853035],"length":1,"stats":{"Line":2}},{"line":218,"address":[2853179,2853251,2853233],"length":1,"stats":{"Line":2}},{"line":219,"address":[2853350,2853244,2853271],"length":1,"stats":{"Line":2}},{"line":221,"address":[2853477,2853580],"length":1,"stats":{"Line":2}},{"line":223,"address":[2853494],"length":1,"stats":{"Line":1}},{"line":224,"address":[2853506],"length":1,"stats":{"Line":1}},{"line":225,"address":[2853539],"length":1,"stats":{"Line":1}},{"line":226,"address":[2853572],"length":1,"stats":{"Line":1}},{"line":230,"address":[2852961],"length":1,"stats":{"Line":1}},{"line":236,"address":[2853764,2853214],"length":1,"stats":{"Line":2}},{"line":237,"address":[2853894],"length":1,"stats":{"Line":1}},{"line":238,"address":[2854128],"length":1,"stats":{"Line":1}},{"line":241,"address":[2853855],"length":1,"stats":{"Line":1}},{"line":245,"address":[2854176,2854811,2854805],"length":1,"stats":{"Line":1}},{"line":246,"address":[2854222],"length":1,"stats":{"Line":1}},{"line":247,"address":[2854254],"length":1,"stats":{"Line":1}},{"line":249,"address":[2854267],"length":1,"stats":{"Line":1}},{"line":251,"address":[2854348,2854277],"length":1,"stats":{"Line":2}},{"line":252,"address":[2854570,2854503],"length":1,"stats":{"Line":2}},{"line":254,"address":[2854631],"length":1,"stats":{"Line":1}},{"line":255,"address":[2854664],"length":1,"stats":{"Line":1}},{"line":256,"address":[2854706],"length":1,"stats":{"Line":1}},{"line":258,"address":[2854763],"length":1,"stats":{"Line":1}},{"line":261,"address":[2854527],"length":1,"stats":{"Line":1}},{"line":264,"address":[2854832,2855277,2855271],"length":1,"stats":{"Line":1}},{"line":265,"address":[2854872],"length":1,"stats":{"Line":1}},{"line":267,"address":[2854882,2854950],"length":1,"stats":{"Line":2}},{"line":268,"address":[2855105,2855171],"length":1,"stats":{"Line":2}},{"line":269,"address":[2855185],"length":1,"stats":{"Line":1}},{"line":271,"address":[2855232],"length":1,"stats":{"Line":1}},{"line":274,"address":[2855130],"length":1,"stats":{"Line":1}},{"line":277,"address":[2855296],"length":1,"stats":{"Line":1}},{"line":278,"address":[2855393,2855352],"length":1,"stats":{"Line":2}},{"line":279,"address":[2855453,2855509],"length":1,"stats":{"Line":2}},{"line":280,"address":[2855521],"length":1,"stats":{"Line":1}},{"line":283,"address":[2855474],"length":1,"stats":{"Line":1}},{"line":286,"address":[2855568,2857515,2857536],"length":1,"stats":{"Line":1}},{"line":287,"address":[2855619],"length":1,"stats":{"Line":1}},{"line":288,"address":[2855627],"length":1,"stats":{"Line":1}},{"line":290,"address":[2855718,2855635],"length":1,"stats":{"Line":2}},{"line":291,"address":[2855873,2855922],"length":1,"stats":{"Line":4}},{"line":292,"address":[2855968],"length":1,"stats":{"Line":2}},{"line":293,"address":[2855986],"length":1,"stats":{"Line":2}},{"line":294,"address":[2856071,2856137,2856155],"length":1,"stats":{"Line":4}},{"line":295,"address":[2856175,2856254,2856148],"length":1,"stats":{"Line":4}},{"line":296,"address":[2856502,2856384],"length":1,"stats":{"Line":2}},{"line":298,"address":[2856088],"length":1,"stats":{"Line":0}},{"line":306,"address":[2855908,2856594],"length":1,"stats":{"Line":4}},{"line":307,"address":[2856727],"length":1,"stats":{"Line":2}},{"line":310,"address":[2856974],"length":1,"stats":{"Line":2}},{"line":311,"address":[2857099],"length":1,"stats":{"Line":2}},{"line":314,"address":[2856685],"length":1,"stats":{"Line":2}}],"covered":118,"coverable":125},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej05.rs"],"content":"use std::{path::PathBuf, ptr::eq};\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nenum TipoSuscripcion {\n    Basic,\n    Clasic,\n    Super,\n}\n\nimpl PartialEq for TipoSuscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoSuscripcion::Basic, TipoSuscripcion::Basic) =\u003e true,\n            (TipoSuscripcion::Clasic, TipoSuscripcion::Clasic) =\u003e true,\n            (TipoSuscripcion::Super, TipoSuscripcion::Super) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n\nimpl TipoSuscripcion {\n    fn costo_mensual(\u0026self) -\u003e f64 {\n        match self {\n            TipoSuscripcion::Basic =\u003e 5.0,\n            TipoSuscripcion::Clasic =\u003e 9.5,\n            TipoSuscripcion::Super =\u003e 15.0,\n        }\n    }\n\n    fn upgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e{\n        match self {\n            TipoSuscripcion::Basic =\u003e Some(TipoSuscripcion::Clasic),\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Super),\n            TipoSuscripcion::Super =\u003e None,\n        }\n    }\n\n    fn downgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\n        match  self {\n            TipoSuscripcion::Basic =\u003e None,\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Basic),\n            TipoSuscripcion::Super =\u003e Some(TipoSuscripcion::Clasic),\n            \n        }\n    }\n\n    fn soy_basic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Basic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_clasic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Clasic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_super(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Super =\u003e true,\n            _ =\u003e false, \n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Suscripcion {\n    tipo: TipoSuscripcion,\n    duracion_meses: u8,\n    fecha_inicio: String,\n    activa: bool,\n}\n\nimpl Suscripcion {\n    fn new(tipo: TipoSuscripcion, duracion_meses: u8, fecha_inicio: String) -\u003e Suscripcion {\n        Suscripcion {\n            tipo,\n            duracion_meses,\n            fecha_inicio,\n            activa: true,\n        }\n    }\n\n    fn activar_suscripcion(\u0026mut self) {\n        self.activa = true\n    }\n\n    fn desactivar_suscripcion(\u0026mut self) {\n        self.activa = false\n    }\n\n    fn upgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.upgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede ascender de Super.\".to_string()) //Is it okay to make it an err? \n        }\n    }\n\n    fn downgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.downgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e {\n                self.desactivar_suscripcion();\n                Err(\"Se ha canclado su suscripción.\".to_string())\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nenum MedioPago {\n    Efectivo,\n    MercadoPago {\n        cbu: u32,\n    },\n    TransferenciaBancaria {\n        cuenta_destino: String,\n        cuenta_origen: String,    },\n    TarjetaCredito {\n        numero_tarjeta: u32,\n    },\n    Cripto {\n        tipo_cripto: String,\n    },\n}\n\nimpl MedioPago {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            MedioPago::Efectivo =\u003e String::from(\"Efectivo\"),\n            MedioPago::TarjetaCredito { numero_tarjeta } =\u003e String::from(\"TarjetaCredito\"),\n            MedioPago::MercadoPago { cbu } =\u003e String::from(\"MercadoPago\"),\n            MedioPago::TransferenciaBancaria { cuenta_destino, cuenta_origen } =\u003e String::from(\"TransferenciaBancaria\"),\n            MedioPago::Cripto { tipo_cripto } =\u003e String::from(\"Cripto\"),\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Usuario {\n    suscripciones: Vec\u003cSuscripcion\u003e,\n    medio_pago: MedioPago,\n    id: u32,\n    username: String,\n    nombre: String,\n    apellido: String,\n    email: String,\n}\n\nimpl Usuario {\n    fn agregar_suscripcion(\u0026mut self, suscripcion: Suscripcion) {\n        self.suscripciones.iter_mut().for_each(|s| s.desactivar_suscripcion()); //Deactivate all previous subscriptons.\n        self.suscripciones.push(suscripcion); //Add the new subscription.\n    }\n\n    fn obtener_suscripcion_activa(\u0026self) -\u003e Option\u003c\u0026Suscripcion\u003e {\n        self.suscripciones.iter().find(|s| s.activa)\n    }\n\n    fn obtener_suscripcion_activa_mutable(\u0026mut self) -\u003e Option\u003c\u0026mut Suscripcion\u003e {\n        self.suscripciones.iter_mut().find(|s| s.activa)\n    }\n\n    fn cancelar_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion_a_cancelar) =\u003e {\n                suscripcion_a_cancelar.desactivar_suscripcion();\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede cancelar esa suscripción. Ya sea porque no existe o porque ya está desactivada.\".to_string())\n        }\n    }\n\n    fn tiene_suscripcion_activa(\u0026self) -\u003e bool {\n        self.suscripciones.iter().any(|s| s.activa)\n    }\n\n    fn upgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.upgrade();\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para mejorar.\".to_string())\n        }\n    }\n\n    fn downgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.downgrade()?;\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para degradar.\".to_string())\n        }\n    }\n}\n\nenum ErroresPersonalizados {\n    ErrorArchivo,\n}\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct StreamingRust {\n    usuarios: Vec\u003cUsuario\u003e, \n    archivo_usuarios_suscripciones: PathBuf,\n    \n}\n\nimpl StreamingRust {\n\n    pub fn crear_plataforma(archivo_usuarios_suscripciones: String) -\u003e StreamingRust {\n        let path = PathBuf::from(archivo_usuarios_suscripciones);\n        StreamingRust {\n            usuarios: Vec::new(),\n            archivo_usuarios_suscripciones: path,\n        }\n    }\n\n    fn cargar_usuario_al_archivo(\u0026mut self, usuario: \u0026Usuario) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut file = OpenOptions::new()\n        .create(true)      // Create file if it doesn't exist\n        .append(true)      // Append to end of file (don't overwrite)\n        .open(\u0026self.archivo_usuarios_suscripciones)\n        .map_err(|_| ErroresPersonalizados::ErrorArchivo)?;\n\n        let usuario_serializado = serde_json::to_string(\u0026usuario).unwrap();\n\n        match file.write(\u0026usuario_serializado.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo),\n            Ok(_) =\u003e Ok(()),\n        }\n    }\n\n    fn modificar_archivo(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut file:File = match File::create(self.archivo_usuarios_suscripciones.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        let writer = std::io::BufWriter::new(\u0026file);\n\n        serde_json::to_writer(writer, \u0026self.usuarios) \n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    pub fn crear_usuario(\u0026mut self, suscripcion: \u0026Suscripcion, medio_pago: \u0026MedioPago, id: u32, username: String, nombre: String, apellido: String, email: String) {\n        //Tendría que chequear que el usuario no existe antes??\n        let usuario = Usuario {\n            id: id,\n            suscripciones: vec![suscripcion.clone()],\n            medio_pago: medio_pago.clone(),\n            username: username,\n            nombre: nombre,\n            apellido: apellido,\n            email: email,\n        };\n\n        self.usuarios.push(usuario.clone());\n\n        //Append al archivo de suscripciones.\n        self.cargar_usuario_al_archivo(\u0026usuario.clone());\n    }\n\n    pub fn upgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        //Given an user upgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.upgrade_suscripcion(); //Update subscription.\n\n            //Modificar archivo suscripciones.\n            self.modificar_archivo();\n        }\n\n    }\n\n    pub fn downgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) -\u003e Result\u003c(), String\u003e {\n        //Given an user downgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.downgrade_suscripcion()?; //Downgrade subscription.\n\n            //Modificar archivo suscripciones.\n            self.modificar_archivo();\n\n            return Ok(());\n        }\n        Err(\"No se encontró el usuario\".to_string())\n    }\n\n    pub fn cancelar_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.cancelar_suscripcion(); //Downgrade subscription.\n\n            //Modificar archivo suscripciones.\n            self.modificar_archivo();\n        }\n    }\n\n    //Estadísticas.\n    pub fn suscripcion_mas_contratada_activos(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones activas de los usuarios.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro usuarios con suscripción activa.\n            .for_each(|u| { //Para cada una de ellas.\n                //Obtener el tipo de suscripción activa.\n                if let Some(suscripcion) = u.obtener_suscripcion_activa() {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {  //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n\n                    }\n                }\n               \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn suscripcion_mas_contratada(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        //No me importan solo las suscripciones activas, tengo que chequear todas.\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario.\n                //Recorrer sus suscripciones (todas).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n                    }\n                });                     \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn medio_pago_mas_usado_activos(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n        \n        //Si no coincide con ninguna, creo la posición con el medio de pago y la cantidad inicializada en 1.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro los usuarios con suscripciones activas.\n            .for_each(|u| {\n                //Busco si su medio de pago coincide con alguna entrada en el vector -\u003e aumento en 1 la cantidad.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                    entry.1 += 1;\n                } else {\n                    auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                }\n            });\n\n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.\n    }\n\n    pub fn medio_pago_mas_usado(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario. (No filter).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                    }\n                });                     \n            });\n        \n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.    \n    }\n\n}\n\n\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_upgrade_downgrade() {\n        let mut suscripcion0 = Suscripcion::new(TipoSuscripcion::Basic, 3, \"12/9/2020\".to_string());\n        let mut suscripcion1 = Suscripcion::new(TipoSuscripcion::Super, 3, \"4/9/2019\".to_string());\n\n        //Test upgrade. Ok.\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.upgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_clasic(), true);\n\n        assert!(suscripcion1.upgrade().is_err());\n\n        //Test downgrade. Ok.\n        assert!(suscripcion0.downgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.downgrade().is_err());\n        assert_eq!(suscripcion0.activa, false);\n    }\n\n    #[test]\n    fn test_upgrade_subscription() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n        let mut usuarios = vec![user0.clone()];\n        let mut plataforma = StreamingRust {usuarios, archivo_usuarios_suscripciones: path.into()};\n\n        plataforma.upgrade_suscripcion(\u0026mut user0);\n\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n\n        assert!(user0.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Clasic)); //Ok.\n\n\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 124 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Super,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        plataforma.usuarios.push(user1.clone());\n        plataforma.upgrade_suscripcion(\u0026mut user1);\n        assert!(user1.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Super)); //Ok.\n\n\n        plataforma.cancelar_suscripcion(\u0026mut user0);\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n        assert_eq!(user0.suscripciones.iter().any(|s| s.activa), false); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        //Creo los usuarios para agregarlos a mi plataforma después.\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user2 = Usuario {\n            username: \"sus2\".to_string(),\n            email: \"sus2@email\".to_string(),\n            apellido: \"2\".to_string(),\n            id: 3,\n            nombre: \"sus2\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 123 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user3 = Usuario {\n            username: \"sus3\".to_string(),\n            email: \"sus3@email\".to_string(),\n            apellido: \"3\".to_string(),\n            id: 4,\n            nombre: \"sus3\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: false,\n            }],\n        };\n\n        //En resumen: \n        //Medios de pago: Activos: 2 de efectivo, 1 de mercado pago. Inactivos: 1 Efectivo.\n        //Suscripciones: Activos: 2 Basic, 1 Clasic. Inactivos: 1 Clasic.\n\n        let mut usuarios = vec![user0.clone(), user1.clone(), user2.clone(), user3.clone()];\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n\n        let mut plataforma = StreamingRust {usuarios, archivo_usuarios_suscripciones: path.into()};\n\n        assert_eq!(plataforma.medio_pago_mas_usado_activos(), Some((\"Efectivo\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.medio_pago_mas_usado(), Some((\"Efectivo\".to_string(), 3))); //Ok.\n\n        assert_eq!(plataforma.suscripcion_mas_contratada(), Some((TipoSuscripcion::Clasic, 2))); //Ok. (Se queda con el último valor que encontró (el clasic en este caso) si hay un empate).\n        assert_eq!(plataforma.suscripcion_mas_contratada_activos(), Some((TipoSuscripcion::Basic, 2))); //Ok.\n    }\n\n    //Tests agregados: \n    #[test]\n    fn test_upgrade_downgrade_2() {\n        let mut suscripcion0 = Suscripcion::new(TipoSuscripcion::Clasic, 3, \"12/9/2020\".to_string());\n        let mut suscripcion1 = Suscripcion::new(TipoSuscripcion::Super, 3, \"4/9/2019\".to_string());\n\n        //Test upgrade. Ok.\n        assert_eq!(suscripcion0.tipo.soy_clasic(), true);\n        assert!(suscripcion0.upgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_super(), true);\n\n        assert!(suscripcion1.upgrade().is_err());\n\n        //Test downgrade. Ok.\n        assert_eq!(suscripcion1.tipo.soy_super(), true);\n        assert!(suscripcion1.downgrade().is_ok());\n        assert_eq!(suscripcion1.tipo.soy_clasic(), true);\n    }\n\n    #[test]\n    fn crear_plataforma() {\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n        let mut plataforma:StreamingRust = StreamingRust::crear_plataforma(String::from(path));\n        assert!(plataforma.usuarios.is_empty()); //Ok. Se crea con el vector de usuarios vacío.\n\n        let mut suscripcion: Suscripcion = Suscripcion::new(TipoSuscripcion::Clasic, 3, \"12/9/2020\".to_string());\n\n        let mut user = plataforma.crear_usuario(\u0026suscripcion, \u0026MedioPago::Cripto { tipo_cripto: \"Bitcoin\".to_string() }, 123, \"username\".to_string(), \"nombre\".to_string(), \"apellido\".to_string(), \"email\".to_string());\n        \n        assert_ne!(plataforma.usuarios.is_empty(), true); //Ok.\n        assert_eq!(plataforma.usuarios.len(), 1); //Ok.\n    } \n\n    #[test]\n    fn test_downgrade() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut usuarios = vec![user0.clone()];\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n\n        let mut plataforma = StreamingRust {usuarios, archivo_usuarios_suscripciones: path.into()};\n\n        assert!(plataforma.downgrade_suscripcion(\u0026mut user0).is_err()); //Ok.\n\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 124 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Super,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        plataforma.usuarios.push(user1.clone());\n        assert!(plataforma.downgrade_suscripcion(\u0026mut user1).is_ok());\n\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user1.id) {\n            user1.suscripciones = updated_user.suscripciones.clone();\n        }\n\n        assert!(user1.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Clasic)); //Ok.\n    }\n\n    #[test]\n    fn test_usuario_features() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: false,\n            }],\n        };\n\n        assert!(user0.cancelar_suscripcion().is_err()); //Ok.\n        assert!(user0.upgrade_suscripcion().is_err()); //Ok.\n        assert!(user0.downgrade_suscripcion().is_err()); //Ok.\n\n        let mut suscripcion: Suscripcion = Suscripcion::new(TipoSuscripcion::Clasic, 3, \"12/9/2020\".to_string());\n        user0.agregar_suscripcion(suscripcion);\n        assert_eq!(user0.suscripciones.len(), 2); //Ok.\n\n        //Activar la primera suscripción.\n        user0.suscripciones[0].activar_suscripcion();\n        assert_eq!(user0.suscripciones[0].activa, true); //Ok.\n    }\n\n    #[test]\n    fn test_crear_usuario_archivo() {\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n        let mut plataforma:StreamingRust = StreamingRust::crear_plataforma(String::from(path));\n\n        plataforma.crear_usuario(\u0026Suscripcion { tipo: TipoSuscripcion::Basic, duracion_meses: 8, fecha_inicio: \"12/12/2000\".to_string(), activa: true }, \u0026MedioPago::Efectivo, 1, \"user1\".to_string(), \"nombre1\".to_string(), \"ape1\".to_string(), \"email1\".to_string());\n        //Ok. El archivo de usuarios_suscripciones se crea correctamente.\n\n        plataforma.crear_usuario(\u0026Suscripcion { tipo: TipoSuscripcion::Basic, duracion_meses: 8, fecha_inicio: \"12/12/2000\".to_string(), activa: true }, \u0026MedioPago::Efectivo, 2, \"user2\".to_string(), \"nombre2\".to_string(), \"ape2\".to_string(), \"email2\".to_string());\n        //Ok. El usuario nuevo se agrega bien al final del archivo (append).\n    }\n\n    #[test]\n    fn test_costo_mensual() {\n        /*fn costo_mensual(\u0026self) -\u003e f64 {\n        match self {\n            TipoSuscripcion::Basic =\u003e 5.0,\n            TipoSuscripcion::Clasic =\u003e 9.5,\n            TipoSuscripcion::Super =\u003e 15.0,\n        }\n    }\n */\n        let tipo_b = TipoSuscripcion::Basic;\n        assert_eq!(tipo_b.costo_mensual(), 5.0);\n\n        let tipo_c = TipoSuscripcion::Clasic;\n        assert_eq!(tipo_c.costo_mensual(), 9.5);\n\n        let tipo_s = TipoSuscripcion::Super;\n        assert_eq!(tipo_s.costo_mensual(), 15.0);\n    }\n}","traces":[{"line":18,"address":[3114976,3115031],"length":1,"stats":{"Line":1}},{"line":19,"address":[3114986,3115033],"length":1,"stats":{"Line":2}},{"line":30,"address":[3115120],"length":1,"stats":{"Line":1}},{"line":31,"address":[3115125],"length":1,"stats":{"Line":1}},{"line":32,"address":[3115157],"length":1,"stats":{"Line":1}},{"line":33,"address":[3115173],"length":1,"stats":{"Line":1}},{"line":34,"address":[3115189],"length":1,"stats":{"Line":1}},{"line":38,"address":[3115216],"length":1,"stats":{"Line":1}},{"line":39,"address":[3115221],"length":1,"stats":{"Line":1}},{"line":40,"address":[3115253],"length":1,"stats":{"Line":1}},{"line":41,"address":[3115268],"length":1,"stats":{"Line":1}},{"line":42,"address":[3115283],"length":1,"stats":{"Line":1}},{"line":46,"address":[3115296],"length":1,"stats":{"Line":1}},{"line":47,"address":[3115301],"length":1,"stats":{"Line":2}},{"line":48,"address":[3115333],"length":1,"stats":{"Line":1}},{"line":49,"address":[3115340],"length":1,"stats":{"Line":1}},{"line":50,"address":[3115355],"length":1,"stats":{"Line":1}},{"line":55,"address":[3115376],"length":1,"stats":{"Line":1}},{"line":56,"address":[3115381],"length":1,"stats":{"Line":1}},{"line":62,"address":[3115408],"length":1,"stats":{"Line":1}},{"line":63,"address":[3115413],"length":1,"stats":{"Line":1}},{"line":69,"address":[3115440],"length":1,"stats":{"Line":1}},{"line":70,"address":[3115445],"length":1,"stats":{"Line":1}},{"line":86,"address":[3115472],"length":1,"stats":{"Line":1}},{"line":95,"address":[3115520],"length":1,"stats":{"Line":1}},{"line":96,"address":[3115525],"length":1,"stats":{"Line":1}},{"line":99,"address":[3115536],"length":1,"stats":{"Line":2}},{"line":100,"address":[3115541],"length":1,"stats":{"Line":2}},{"line":103,"address":[3115552],"length":1,"stats":{"Line":1}},{"line":104,"address":[3115582],"length":1,"stats":{"Line":1}},{"line":105,"address":[3115628],"length":1,"stats":{"Line":1}},{"line":106,"address":[3115636],"length":1,"stats":{"Line":1}},{"line":107,"address":[3115639],"length":1,"stats":{"Line":1}},{"line":109,"address":[3115654],"length":1,"stats":{"Line":1}},{"line":113,"address":[3115728],"length":1,"stats":{"Line":1}},{"line":114,"address":[3115758],"length":1,"stats":{"Line":2}},{"line":115,"address":[3115804],"length":1,"stats":{"Line":1}},{"line":116,"address":[3115812],"length":1,"stats":{"Line":1}},{"line":117,"address":[3115815],"length":1,"stats":{"Line":1}},{"line":120,"address":[3115834],"length":1,"stats":{"Line":1}},{"line":121,"address":[3115839],"length":1,"stats":{"Line":2}},{"line":145,"address":[3115904],"length":1,"stats":{"Line":1}},{"line":146,"address":[3115928],"length":1,"stats":{"Line":1}},{"line":147,"address":[3115993],"length":1,"stats":{"Line":1}},{"line":148,"address":[3116106],"length":1,"stats":{"Line":0}},{"line":149,"address":[3116025],"length":1,"stats":{"Line":1}},{"line":150,"address":[3116063],"length":1,"stats":{"Line":0}},{"line":151,"address":[3116144],"length":1,"stats":{"Line":0}},{"line":168,"address":[3116192,3116361,3116383],"length":1,"stats":{"Line":1}},{"line":169,"address":[3116211,3116273],"length":1,"stats":{"Line":4}},{"line":170,"address":[3116315],"length":1,"stats":{"Line":1}},{"line":173,"address":[3116400],"length":1,"stats":{"Line":1}},{"line":174,"address":[3116409],"length":1,"stats":{"Line":3}},{"line":177,"address":[3116448],"length":1,"stats":{"Line":1}},{"line":178,"address":[3195978,3195968],"length":1,"stats":{"Line":3}},{"line":181,"address":[3116496],"length":1,"stats":{"Line":1}},{"line":182,"address":[3116526],"length":1,"stats":{"Line":1}},{"line":183,"address":[3116564],"length":1,"stats":{"Line":1}},{"line":184,"address":[3116574],"length":1,"stats":{"Line":1}},{"line":185,"address":[3116584],"length":1,"stats":{"Line":1}},{"line":187,"address":[3116599],"length":1,"stats":{"Line":1}},{"line":191,"address":[3116672],"length":1,"stats":{"Line":1}},{"line":192,"address":[3116681],"length":1,"stats":{"Line":3}},{"line":195,"address":[3116736],"length":1,"stats":{"Line":1}},{"line":196,"address":[3116768],"length":1,"stats":{"Line":2}},{"line":197,"address":[3116806],"length":1,"stats":{"Line":1}},{"line":198,"address":[3116816],"length":1,"stats":{"Line":1}},{"line":199,"address":[3116841],"length":1,"stats":{"Line":1}},{"line":201,"address":[3116856],"length":1,"stats":{"Line":1}},{"line":205,"address":[3116928],"length":1,"stats":{"Line":1}},{"line":206,"address":[3116964],"length":1,"stats":{"Line":1}},{"line":207,"address":[3117002],"length":1,"stats":{"Line":1}},{"line":208,"address":[3117147,3117015],"length":1,"stats":{"Line":2}},{"line":209,"address":[3117201],"length":1,"stats":{"Line":1}},{"line":211,"address":[3117076],"length":1,"stats":{"Line":1}},{"line":228,"address":[3117216,3117380],"length":1,"stats":{"Line":1}},{"line":229,"address":[3117234],"length":1,"stats":{"Line":1}},{"line":231,"address":[3117244],"length":1,"stats":{"Line":2}},{"line":236,"address":[3117916,3117910,3117408],"length":1,"stats":{"Line":2}},{"line":237,"address":[3117433,3117505],"length":1,"stats":{"Line":4}},{"line":240,"address":[3117479],"length":1,"stats":{"Line":2}},{"line":241,"address":[3196016,3196025],"length":1,"stats":{"Line":2}},{"line":243,"address":[3117634,3117586],"length":1,"stats":{"Line":4}},{"line":245,"address":[3117663,3117728],"length":1,"stats":{"Line":4}},{"line":246,"address":[3117824],"length":1,"stats":{"Line":0}},{"line":247,"address":[3117864],"length":1,"stats":{"Line":2}},{"line":251,"address":[3118381,3117936,3118387],"length":1,"stats":{"Line":1}},{"line":252,"address":[3117959],"length":1,"stats":{"Line":1}},{"line":253,"address":[3118068,3118000,3118404],"length":1,"stats":{"Line":0}},{"line":254,"address":[3118033],"length":1,"stats":{"Line":1}},{"line":257,"address":[3118058],"length":1,"stats":{"Line":1}},{"line":259,"address":[3118276,3118244,3118362],"length":1,"stats":{"Line":2}},{"line":260,"address":[3118261],"length":1,"stats":{"Line":1}},{"line":262,"address":[3118328],"length":1,"stats":{"Line":1}},{"line":265,"address":[3119560,3118432,3119465],"length":1,"stats":{"Line":1}},{"line":269,"address":[3118599,3118662,3119471],"length":1,"stats":{"Line":4}},{"line":270,"address":[3118871],"length":1,"stats":{"Line":1}},{"line":277,"address":[3119331,3119282],"length":1,"stats":{"Line":4}},{"line":280,"address":[3119366],"length":1,"stats":{"Line":2}},{"line":283,"address":[3119600],"length":1,"stats":{"Line":1}},{"line":285,"address":[3119623],"length":1,"stats":{"Line":3}},{"line":286,"address":[3119714],"length":1,"stats":{"Line":1}},{"line":289,"address":[3119738],"length":1,"stats":{"Line":1}},{"line":294,"address":[3119760],"length":1,"stats":{"Line":1}},{"line":296,"address":[3119809],"length":1,"stats":{"Line":3}},{"line":297,"address":[3119903,3120036],"length":1,"stats":{"Line":2}},{"line":300,"address":[3120089],"length":1,"stats":{"Line":1}},{"line":302,"address":[3120099],"length":1,"stats":{"Line":1}},{"line":304,"address":[3119964],"length":1,"stats":{"Line":0}},{"line":307,"address":[3120128],"length":1,"stats":{"Line":1}},{"line":308,"address":[3120151],"length":1,"stats":{"Line":3}},{"line":309,"address":[3120242],"length":1,"stats":{"Line":1}},{"line":312,"address":[3120266],"length":1,"stats":{"Line":1}},{"line":317,"address":[3120636,3120630,3120288],"length":1,"stats":{"Line":1}},{"line":318,"address":[3120313],"length":1,"stats":{"Line":1}},{"line":320,"address":[3120375,3120323],"length":1,"stats":{"Line":2}},{"line":321,"address":[3120403],"length":1,"stats":{"Line":0}},{"line":325,"address":[3196190,3196176],"length":1,"stats":{"Line":4}},{"line":326,"address":[3196208],"length":1,"stats":{"Line":2}},{"line":328,"address":[3196240],"length":1,"stats":{"Line":1}},{"line":330,"address":[3196382,3196298,3196512,3196496,3196480],"length":1,"stats":{"Line":5}},{"line":331,"address":[3196397,3196477,3196482],"length":1,"stats":{"Line":2}},{"line":333,"address":[3196424],"length":1,"stats":{"Line":1}},{"line":340,"address":[3120504,3120596],"length":1,"stats":{"Line":2}},{"line":341,"address":[3120558],"length":1,"stats":{"Line":3}},{"line":342,"address":[3196589,3196576],"length":1,"stats":{"Line":3}},{"line":345,"address":[3120971,3120977,3120656],"length":1,"stats":{"Line":1}},{"line":347,"address":[3120681],"length":1,"stats":{"Line":1}},{"line":349,"address":[3120691,3120743],"length":1,"stats":{"Line":2}},{"line":350,"address":[3120771],"length":1,"stats":{"Line":0}},{"line":354,"address":[3120801,3120754],"length":1,"stats":{"Line":2}},{"line":355,"address":[3196624],"length":1,"stats":{"Line":2}},{"line":357,"address":[3196656,3196704],"length":1,"stats":{"Line":2}},{"line":359,"address":[3196901,3196944,3196928,3196728],"length":1,"stats":{"Line":4}},{"line":360,"address":[3196820,3196903,3196898],"length":1,"stats":{"Line":2}},{"line":363,"address":[3196847],"length":1,"stats":{"Line":1}},{"line":368,"address":[3120937,3120845],"length":1,"stats":{"Line":2}},{"line":369,"address":[3120899],"length":1,"stats":{"Line":3}},{"line":370,"address":[3197008,3197021],"length":1,"stats":{"Line":3}},{"line":373,"address":[3121341,3121335,3120992],"length":1,"stats":{"Line":1}},{"line":374,"address":[3121027],"length":1,"stats":{"Line":1}},{"line":376,"address":[3121037,3121089],"length":1,"stats":{"Line":2}},{"line":377,"address":[3121122],"length":1,"stats":{"Line":0}},{"line":381,"address":[3197056,3197070],"length":1,"stats":{"Line":4}},{"line":382,"address":[3197088],"length":1,"stats":{"Line":2}},{"line":384,"address":[3197376,3197339,3197121,3197390],"length":1,"stats":{"Line":4}},{"line":385,"address":[3197336,3197216,3197341],"length":1,"stats":{"Line":2}},{"line":387,"address":[3197243],"length":1,"stats":{"Line":1}},{"line":391,"address":[3121231],"length":1,"stats":{"Line":1}},{"line":392,"address":[3121285],"length":1,"stats":{"Line":3}},{"line":393,"address":[3197552,3197576],"length":1,"stats":{"Line":3}},{"line":396,"address":[3121676,3121360,3121682],"length":1,"stats":{"Line":1}},{"line":397,"address":[3121395],"length":1,"stats":{"Line":1}},{"line":399,"address":[3121457,3121405],"length":1,"stats":{"Line":2}},{"line":400,"address":[3121490],"length":1,"stats":{"Line":0}},{"line":404,"address":[3121468,3121528],"length":1,"stats":{"Line":2}},{"line":405,"address":[3121560],"length":1,"stats":{"Line":2}},{"line":406,"address":[3197699,3197744],"length":1,"stats":{"Line":2}},{"line":408,"address":[3198016,3197766,3198030,3197985],"length":1,"stats":{"Line":4}},{"line":409,"address":[3197865,3197982,3197987],"length":1,"stats":{"Line":2}},{"line":412,"address":[3197887],"length":1,"stats":{"Line":1}},{"line":417,"address":[3121572],"length":1,"stats":{"Line":1}},{"line":418,"address":[3121626],"length":1,"stats":{"Line":3}},{"line":419,"address":[3121646],"length":1,"stats":{"Line":3}}],"covered":154,"coverable":164},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej06.rs"],"content":"use std::{collections::HashMap, path::PathBuf};\nuse chrono::{DateTime, Utc};\nuse rand::Rng;\nuse std::ptr::eq;\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Usuario {\n    nombre: String,\n    apellido: String,\n    email: String,\n    dni: u32,\n    identidad_validada: bool,\n    balance_fiat: f64,\n    balance_criptomoneda: HashMap\u003cString, f64\u003e, //Nombre_cripto -\u003e cantidad.\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Blockchain {\n    nombre: String,\n    prefijo: String,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Criptomoneda { \n    nombre: String,\n    prefijo: String,\n    listado_blockchains: Vec\u003cBlockchain\u003e,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub enum TipoTransaccion {\n    IngresoFiat,\n    CompraCripto,\n    VentaCripto,\n    RetiroCripto,\n    RecepcionCripto,\n    RetiroFiat,\n}\n\nimpl PartialEq for TipoTransaccion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoTransaccion::CompraCripto, TipoTransaccion::CompraCripto) =\u003e true,\n            (TipoTransaccion::IngresoFiat, TipoTransaccion::IngresoFiat) =\u003e true,\n            (TipoTransaccion::RecepcionCripto, TipoTransaccion::RecepcionCripto) =\u003e true,\n            (TipoTransaccion::RetiroCripto, TipoTransaccion::RetiroCripto) =\u003e true,\n            (TipoTransaccion::RetiroFiat, TipoTransaccion::RetiroFiat) =\u003e true,\n            (TipoTransaccion::VentaCripto, TipoTransaccion::VentaCripto) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nenum Medio {\n    MercadoPago,\n    TransferenciaBancaria,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Transaccion {\n    fecha: DateTime\u003cUtc\u003e,\n    tipo: TipoTransaccion,\n    usuario: Usuario,\n    monto_fiat: Option\u003cf64\u003e,\n    criptomoneda: Option\u003cCriptomoneda\u003e,\n    monto_criptomoneda: Option\u003cf64\u003e,\n    cotizacion: Option\u003cf64\u003e,\n    blockchain: Option\u003cBlockchain\u003e,\n    hash: Option\u003cString\u003e,\n    medio: Option\u003cMedio\u003e,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct PlataformaXYZ {\n    usuarios: HashMap\u003cString, Usuario\u003e, //Email -\u003e usuario.\n    criptomonedas: HashMap\u003cString, Criptomoneda\u003e, //Nombre_cripto -\u003e cripto.\n    transacciones: Vec\u003cTransaccion\u003e,\n    archivo_transacciones: PathBuf,\n    archivo_usuarios_balances: PathBuf,\n}\n\n//Custom errors.\n#[derive(Clone, Debug)]\nenum ErrorIntercambio { \n    UsuarioNoValido,\n    BalanceInsuficiente,\n    CriptoNoEncontrada,\n    BlockchainNoDisponible,\n    UsuarioNoEncontrado,\n    ErrorArchivo, //está bien que esté dentro de errorIntercambio o tendría que estar en otro enum?\n}\n\n//Obtener cotizacion.\npub fn obtener_cotizacion(cripto_nombre: \u0026str) -\u003e f64  { //Datos en dólares del 28/05/2025.\n    match cripto_nombre {\n        \"Bitcoin\" =\u003e 107281.20,\n        \"Ethereum\" =\u003e 18.10,\n        \"Litecoin\" =\u003e 94.42,\n        _ =\u003e 50.0,\n    }\n}\n\nimpl PlataformaXYZ {\n    fn new(archivo_transacciones: String, archivo_usuarios_balances: String) -\u003e Self {\n        let path_trans = PathBuf::from(archivo_transacciones);\n        let path_users_bal = PathBuf::from(archivo_usuarios_balances);\n        PlataformaXYZ { usuarios: HashMap::new(), criptomonedas: HashMap::new(), transacciones:Vec::new(), archivo_transacciones: path_trans, archivo_usuarios_balances: path_users_bal }\n    //Tendría que inicializar los archivos de transacciones y de usuarios_balances acá vacíos??? O así está bien?\n    \n    }\n\n    fn cargar_transaccion_al_archivo(\u0026mut self, transaccion: \u0026Transaccion) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        let mut file = OpenOptions::new()\n        .create(true)      // Create file if it doesn't exist\n        .append(true)      // Append to end of file (don't overwrite)\n        .open(\u0026self.archivo_transacciones)\n        .map_err(|_| ErrorIntercambio::ErrorArchivo)?;\n\n        let transaccion_serializada = serde_json::to_string(\u0026transaccion).unwrap();\n\n        match file.write(\u0026transaccion_serializada.as_bytes()) {\n            Err(e) =\u003e Err(ErrorIntercambio::ErrorArchivo),\n            Ok(_) =\u003e Ok(()),\n        }\n    }\n\n    fn cargar_usuarios_al_archivo(\u0026mut self) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Cargar todos los usuarios al archivo.\n        let mut file:File = match File::create(self.archivo_usuarios_balances.clone()) {\n            Err(e) =\u003e Err(ErrorIntercambio::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        let writer = std::io::BufWriter::new(\u0026file);\n\n        serde_json::to_writer(writer, \u0026self.usuarios) \n            .map_err(|e| ErrorIntercambio::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    //Registrar usuario.\n    pub fn registrar_usuario(\u0026mut self, usuario: Usuario) { \n        self.usuarios.insert(usuario.email.clone(), usuario);\n    }\n\n    pub fn registrar_criptomoneda(\u0026mut self, criptomoneda: Criptomoneda) {\n        self.criptomonedas.insert(criptomoneda.nombre.clone(), criptomoneda);\n    }\n\n    pub fn ingresar_dinero(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Verify that the user exists and it is valided.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        match usuario.identidad_validada {\n            true =\u003e {\n                //Acredito el monto fiat.\n                usuario.balance_fiat += monto_fiat;\n                //println!(\"{}\", usuario.balance_fiat); Just to checked it worked (Ok.)\n                //Creo la transaccion.\n                let transaccion = Transaccion {\n                    fecha: Utc::now(),\n                    tipo: TipoTransaccion::IngresoFiat,\n                    usuario: usuario.clone(),\n                    monto_fiat: Some(monto_fiat),\n                    criptomoneda: None,\n                    monto_criptomoneda: None,\n                    cotizacion: None,\n                    blockchain: None,\n                    hash: None,\n                    medio: None,\n                };\n\n                //Agrego la transaccion a mi registro de transacciones.\n                self.transacciones.push(transaccion.clone());\n                //Modificar archivo transaccion (agregar transaccion)\n                self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n                //Modificar al usuario en el archivo de usuarios_balances. \n                self.cargar_usuarios_al_archivo();\n\n                Ok(())\n            }\n            false =\u003e Err(ErrorIntercambio::UsuarioNoValido),\n        }\n    }\n\n    pub fn comprar_determinada_criptomoneda(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        if usuario.balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Check if the cripto exists.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //If we've come this far it is because the purchase can be made.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre); \n        usuario.balance_fiat -= monto_fiat; //Descuento el monto_fiat del balance_fiat del usuario.\n\n        //Acredito la cantidad acorde de criptos.\n        let cantidad_cripto = monto_fiat/cotizacion;\n\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) += cantidad_cripto;\n\n\n        /* EXPLICACIÓN:\n\n        entry() = busca si existe la clave, me da acceso para leer/crear la entrada. Retorna un entry enum (occupied, vacant).\n        or_insert() = \n            match entry {\n                Occupied(entrada) =\u003e entrada.get_mut(), // Si existe, devuelve \u0026mut al valor\n                Vacant(entrada) =\u003e entrada.insert(0.0), // Si no existe, inserta 0.0 y devuelve \u0026mut\n            }\n\n        Si \"pepe\" existe: retorna \u0026mut f64 apuntando al valor actual\n        Si \"pepe\" no existe: crea la entrada con valor 0.0 y retorna \u0026mut f64\n        */\n\n\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            usuario: usuario.clone(),\n            tipo: TipoTransaccion::CompraCripto,\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(cantidad_cripto),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n        //Modificar al usuario en el archivo de usuarios_balances. \n        self.cargar_usuarios_al_archivo();\n        \n\n        Ok(())\n    }\n\n    pub fn vender_determinada_criptomoneda(\u0026mut self, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda, monto_criptomoneda: f64) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the cripto exixts.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //Check if the user has enough of that cripto to sell.\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        let monto_fiat = cotizacion * monto_criptomoneda;\n\n        //Actualizar datos del usuario.\n        usuario.balance_fiat += monto_fiat;\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) -= monto_criptomoneda; \n\n        //Creo la transaccion. \n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::VentaCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n        //Modificar al usuario en el archivo de usuarios_balances. \n        self.cargar_usuarios_al_archivo();\n\n        Ok(())\n    }\n\n    pub fn retirar_criptomoneda_a_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, blockchain: \u0026Blockchain, usuario: \u0026mut Usuario) -\u003e Result\u003cString, ErrorIntercambio\u003e {\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Verificar que la blockchain es soportada por la cripto.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?;\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n         //Generar hash simulado\n         let mut rng = rand::rng();\n         let hash = format!(\"{}{}\", blockchain.nombre, rng.random::\u003cu32\u003e());\n         \n         let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n\n         *usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre).unwrap() -= monto_criptomoneda; //Descuento la cantidad acorde de esa cripto.\n\n         //Generar transaccion.\n         let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: Some(hash.clone()),\n            medio: None,\n         };\n\n         self.transacciones.push(transaccion.clone());\n         //Modificar archivo transaccion (agregar transaccion)\n         self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n         //Modificar al usuario en el archivo de usuarios_balances. \n         self.cargar_usuarios_al_archivo();\n\n         Ok(hash)\n    }\n\n    pub fn recibir_criptomoneda_de_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, usuario: \u0026mut Usuario, blockchain: \u0026Blockchain) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user data.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check cripto and blockchain.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?; //Si no existe se propaga el error y termina la función.\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n        //Acredito la cripto en el balance del usuario.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        if let Some(balance) = usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre) { //Busco si ya está la cripto en los balances del usuario.\n            *balance += monto_criptomoneda / cotizacion; \n        } else {\n            // Si la criptomoneda no existe en el balance, la inicializo con el monto dado.\n            usuario.balance_criptomoneda.insert(criptomoneda.nombre.clone(), monto_criptomoneda / cotizacion);\n        }\n\n        //Genero la transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RecepcionCripto,\n            usuario: usuario.clone(),\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_fiat: None,\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n        //Modificar al usuario en el archivo de usuarios_balances. \\\n        self.cargar_usuarios_al_archivo();\n\n        Ok(())\n    }\n    \n    pub fn retirar_fiat_por_determinado_medio(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, medio: \u0026Medio) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        let balance_fiat = usuario.balance_fiat;\n        if balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Descontar el monto fiat del monto del usuario.\n        usuario.balance_fiat -= monto_fiat;\n\n        //Generar transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroFiat,\n            usuario: usuario.clone(),\n            monto_fiat: Some(monto_fiat),\n            criptomoneda: None,\n            monto_criptomoneda: None,\n            cotizacion: None,\n            blockchain: None,\n            hash: None,\n            medio: Some(medio.clone()),\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n        \n        //Modificar al usuario en el archivo de usuarios_balances. \n        self.cargar_usuarios_al_archivo();\n\n        Ok(())\n    }\n\n\n\n\n    //Estadísticas.\n    pub fn criptomoneda_mas_vendida(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea VentaCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de ventas asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más ventas).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n\n        /*EXPLANATION: \n        Inside the map closure:\n\n        (nombre, cantidad) destructures the reference: nombre is \u0026String, cantidad is \u0026u32\n        nombre.clone() creates an owned String from the \u0026String\n        *cantidad dereferences the \u0026u32 to get an owned u32\n         */\n    }\n\n    pub fn criptomoneda_mas_comprada(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea CompraCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::CompraCripto)\n            .for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de compras asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más compras).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n    }\n\n    pub fn crpitomoneda_mas_volumen_venta (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción VentaCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de venta).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    }\n\n\n    pub fn crpitomoneda_mas_volumen_compra (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t|t.tipo == TipoTransaccion::CompraCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción CompraCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de compra).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    } \n}\n\n\n#[cfg(test)]\nmod test {\n    use core::hash;\n    use std::path;\n\n    use super::*;\n\n    fn crear_plataforma() -\u003e PlataformaXYZ {\n        let path_transacciones = \"src/tp05/archivo_transacciones.txt\";\n        let path_usuarios_balances = \"src/tp05/archivo_usuarios_transacciones.txt\";\n        let mut plataforma = PlataformaXYZ::new(String::from(path_transacciones), String::from(path_usuarios_balances));\n\n\n\n        //Crear usuarios.\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user2 = Usuario {\n            nombre: \"Rosita\".to_string(),\n            apellido: \"R\".to_string(),\n            email: \"emailRosita\".to_string(),\n            dni: 345,\n            identidad_validada: true,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        plataforma.registrar_usuario(user0);\n        plataforma.registrar_usuario(user1);\n        plataforma.registrar_usuario(user2);\n        plataforma.registrar_usuario(user3);\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        let litecoin_chain = Blockchain {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        let litecoin = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![litecoin_chain],\n        };\n\n        plataforma.registrar_criptomoneda(bitcoin);\n        plataforma.registrar_criptomoneda(ethereum);\n        plataforma.registrar_criptomoneda(litecoin);\n\n        plataforma\n    }\n\n\n    #[test]\n    fn test_ingresar_dinero() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Test with an user that is valid.\n        \n        //println!(\"Balance before: {}\", \u0026user0.balance_fiat);\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user0).is_ok());\n\n        //let usuario = plataforma.usuarios.get(\u0026user0.email);\n        //println!(\"From platform {}\", usuario.unwrap().balance_fiat); //Se modifica.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0.balance_fiat = updated_user.balance_fiat; // Synchronize user0 with the updated user\n\n        //println!(\"Balance after: {}\", user0.balance_fiat);\n        assert_eq!(user0.balance_fiat, 12000.0);\n\n\n        //Test with an user that is not valid.\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user3).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_comprar_determinada_moneda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { //Esta cripto sí está.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let pepecripto = Criptomoneda { //Esta cripto no.\n            nombre: \"PepeCripto\".to_string(),\n            prefijo: \"PC\".to_string(),\n            listado_blockchains: vec![],\n        };\n\n        //Compra de una cripto que existe desde un usario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Tiene la cripto.\n\n        //Compra de una cripto que no existe desde un usuario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026pepecripto).is_err()); //Ok.\n\n        //Compra de una cripto que sí existe desde un usuario que NO puede(user1, por el balance).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user1, \u0026bitcoin).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_vender_determinada_criptomeda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.01).is_ok());\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone();\n        assert_eq!(user0.balance_fiat, 8072.812); //Ok. Se le acreditó el balance fiat de su venta.\n    }\n\n    #[test]\n    fn test_retirar_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { //Blockchain válida.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let bitcoin_unvalid_chain = Blockchain { //Blockchain NO válida.\n            nombre: \"bit\".to_string(),\n            prefijo: \"b\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0).is_ok());\n\n        //let hash = plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0);\n        //println!(\"{}\", hash.unwrap()); \n\n\n        //Probar con una blockchain que no existe.\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_unvalid_chain, \u0026mut user0).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_recibir_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n        //Arranca user0 sin criptos. (HM len == 0).\n        //println!(\"Error: {:?}\",plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain) ); \n        assert!(plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain).is_ok()); //Ok.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Ok.\n    }\n\n    #[test]\n    fn test_retirar_fiat() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let medio = \u0026Medio::MercadoPago;\n\n        assert!(plataforma.retirar_fiat_por_determinado_medio(5000.0,\u0026mut user0, medio).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_fiat, 5000.0); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 100000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Voy a usar a user0 para haga todas las transacciones.\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        let litecoin_chain = Blockchain {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        let litecoin = Criptomoneda {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LIC\".to_string(),\n            listado_blockchains: vec![litecoin_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n        \n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026ethereum);\n\n        plataforma.comprar_determinada_criptomoneda(100.0, \u0026mut user0, \u0026litecoin);\n        \n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n\n        //assert_eq!(user0.balance_criptomoneda.len(), 2);\n        //println!(\"{}\", plataforma.transacciones.len());\n        assert_eq!(plataforma.criptomoneda_mas_comprada(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_compra(), Some((\"Ethereum\".to_string(), 55.24861878453038))); //Ok.\n\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026ethereum, 0.0001);\n\n        assert_eq!(plataforma.criptomoneda_mas_vendida(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_venta(), Some((\"Bitcoin\".to_string(), 0.0002))); //Ok.\n    }\n\n    #[test]\n    fn test_obtener_cotizacion() {\n        assert_eq!(obtener_cotizacion(\"Litecoin\"), 94.42);\n        assert_eq!(obtener_cotizacion(\"pepe\"), 50.0);\n\n    }\n\n    #[test]\n    fn test_cargar_usuarios_al_archivo() {\n        let mut plataforma = crear_plataforma();\n        \n        assert!(plataforma.cargar_usuarios_al_archivo().is_ok()); //Ok. El archivo de modifica bien.\n\n        let mut user_nuevo = Usuario {\n            nombre: \"Caca\".to_string(),\n            apellido: \"C\".to_string(),\n            email: \"caca@email\".to_string(),\n            dni: 666,\n            identidad_validada: true,\n            balance_fiat: 100000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        plataforma.registrar_usuario(user_nuevo.clone());\n        assert!(plataforma.cargar_usuarios_al_archivo().is_ok()); //Se agrega bien al final del archivo. Ok.\n    }\n\n\n}","traces":[{"line":48,"address":[3127494,3127440],"length":1,"stats":{"Line":1}},{"line":49,"address":[3127496,3127450],"length":1,"stats":{"Line":1}},{"line":102,"address":[3127648],"length":1,"stats":{"Line":1}},{"line":104,"address":[3127724,3127671],"length":1,"stats":{"Line":2}},{"line":105,"address":[3127701,3127772],"length":1,"stats":{"Line":2}},{"line":106,"address":[3127804,3127749],"length":1,"stats":{"Line":2}},{"line":107,"address":[3127788],"length":1,"stats":{"Line":1}},{"line":112,"address":[3128421,3127840],"length":1,"stats":{"Line":1}},{"line":113,"address":[3127862],"length":1,"stats":{"Line":1}},{"line":114,"address":[3127936],"length":1,"stats":{"Line":2}},{"line":115,"address":[3128021,3128074],"length":1,"stats":{"Line":4}},{"line":120,"address":[3128464,3129046,3129052],"length":1,"stats":{"Line":2}},{"line":121,"address":[3128489,3128655,3128580],"length":1,"stats":{"Line":5}},{"line":124,"address":[3128535],"length":1,"stats":{"Line":2}},{"line":125,"address":[3100496,3100505],"length":1,"stats":{"Line":2}},{"line":127,"address":[3128707,3128755],"length":1,"stats":{"Line":5}},{"line":129,"address":[3128787,3128852],"length":1,"stats":{"Line":5}},{"line":130,"address":[3128948],"length":1,"stats":{"Line":0}},{"line":131,"address":[3129002],"length":1,"stats":{"Line":7}},{"line":135,"address":[3129613,3129072,3129619],"length":1,"stats":{"Line":1}},{"line":137,"address":[3129095],"length":1,"stats":{"Line":1}},{"line":138,"address":[3129136,3129636,3129235],"length":1,"stats":{"Line":0}},{"line":139,"address":[3129197],"length":1,"stats":{"Line":1}},{"line":142,"address":[3129225],"length":1,"stats":{"Line":1}},{"line":144,"address":[3129476,3129432,3129546,3129596],"length":1,"stats":{"Line":2}},{"line":145,"address":[3100544,3100553],"length":1,"stats":{"Line":1}},{"line":147,"address":[3129564],"length":1,"stats":{"Line":1}},{"line":151,"address":[3129856,3129664,3129881],"length":1,"stats":{"Line":2}},{"line":152,"address":[3129684,3129771],"length":1,"stats":{"Line":4}},{"line":155,"address":[3130128,3129888,3130104],"length":1,"stats":{"Line":2}},{"line":156,"address":[3129907,3129998],"length":1,"stats":{"Line":3}},{"line":159,"address":[3130144,3131060,3131054],"length":1,"stats":{"Line":1}},{"line":161,"address":[3130223,3130266,3130187],"length":1,"stats":{"Line":2}},{"line":162,"address":[3130255,3130203],"length":1,"stats":{"Line":1}},{"line":164,"address":[3130308],"length":1,"stats":{"Line":1}},{"line":167,"address":[3130352],"length":1,"stats":{"Line":1}},{"line":171,"address":[3130366],"length":1,"stats":{"Line":1}},{"line":173,"address":[3130408],"length":1,"stats":{"Line":1}},{"line":174,"address":[3130423],"length":1,"stats":{"Line":1}},{"line":184,"address":[3130908,3130847],"length":1,"stats":{"Line":2}},{"line":186,"address":[3130943],"length":1,"stats":{"Line":1}},{"line":189,"address":[3131027],"length":1,"stats":{"Line":1}},{"line":191,"address":[3131034],"length":1,"stats":{"Line":1}},{"line":193,"address":[3130317],"length":1,"stats":{"Line":1}},{"line":197,"address":[3131088,3132402,3132408],"length":1,"stats":{"Line":1}},{"line":199,"address":[3131144,3131180,3131223],"length":1,"stats":{"Line":2}},{"line":200,"address":[3131160,3131212],"length":1,"stats":{"Line":1}},{"line":203,"address":[3131262],"length":1,"stats":{"Line":1}},{"line":204,"address":[3131271],"length":1,"stats":{"Line":0}},{"line":208,"address":[3131297],"length":1,"stats":{"Line":1}},{"line":209,"address":[3131343],"length":1,"stats":{"Line":1}},{"line":213,"address":[3131328],"length":1,"stats":{"Line":1}},{"line":214,"address":[3131358],"length":1,"stats":{"Line":1}},{"line":218,"address":[3131378],"length":1,"stats":{"Line":1}},{"line":219,"address":[3131430],"length":1,"stats":{"Line":1}},{"line":222,"address":[3131444],"length":1,"stats":{"Line":2}},{"line":224,"address":[3131463],"length":1,"stats":{"Line":1}},{"line":242,"address":[3131550],"length":1,"stats":{"Line":2}},{"line":243,"address":[3131580],"length":1,"stats":{"Line":1}},{"line":246,"address":[3131676,3131618],"length":1,"stats":{"Line":4}},{"line":247,"address":[3131756],"length":1,"stats":{"Line":2}},{"line":248,"address":[3131777],"length":1,"stats":{"Line":1}},{"line":254,"address":[3132250,3132198],"length":1,"stats":{"Line":3}},{"line":256,"address":[3132288],"length":1,"stats":{"Line":2}},{"line":259,"address":[3132372],"length":1,"stats":{"Line":4}},{"line":262,"address":[3132379],"length":1,"stats":{"Line":1}},{"line":265,"address":[3132432,3133811,3133817],"length":1,"stats":{"Line":1}},{"line":267,"address":[3132479,3132515,3132558],"length":1,"stats":{"Line":2}},{"line":268,"address":[3132547,3132495],"length":1,"stats":{"Line":1}},{"line":271,"address":[3132597],"length":1,"stats":{"Line":1}},{"line":272,"address":[3132606],"length":1,"stats":{"Line":0}},{"line":276,"address":[3132631],"length":1,"stats":{"Line":1}},{"line":277,"address":[3132658],"length":1,"stats":{"Line":0}},{"line":281,"address":[3132683],"length":1,"stats":{"Line":1}},{"line":282,"address":[3132722],"length":1,"stats":{"Line":1}},{"line":283,"address":[3133010],"length":1,"stats":{"Line":0}},{"line":286,"address":[3132766],"length":1,"stats":{"Line":1}},{"line":287,"address":[3132812],"length":1,"stats":{"Line":1}},{"line":290,"address":[3132831],"length":1,"stats":{"Line":1}},{"line":291,"address":[3132845],"length":1,"stats":{"Line":1}},{"line":295,"address":[3132935],"length":1,"stats":{"Line":1}},{"line":297,"address":[3132973],"length":1,"stats":{"Line":1}},{"line":299,"address":[3133079,3133003],"length":1,"stats":{"Line":2}},{"line":300,"address":[3133159],"length":1,"stats":{"Line":1}},{"line":301,"address":[3133186],"length":1,"stats":{"Line":1}},{"line":307,"address":[3133607,3133659],"length":1,"stats":{"Line":2}},{"line":309,"address":[3133697],"length":1,"stats":{"Line":1}},{"line":312,"address":[3133781],"length":1,"stats":{"Line":1}},{"line":314,"address":[3133788],"length":1,"stats":{"Line":1}},{"line":317,"address":[3133840,3136095,3136123],"length":1,"stats":{"Line":1}},{"line":318,"address":[3133931,3133984,3134035],"length":1,"stats":{"Line":2}},{"line":319,"address":[3134024,3133955],"length":1,"stats":{"Line":1}},{"line":321,"address":[3134073],"length":1,"stats":{"Line":1}},{"line":322,"address":[3134087],"length":1,"stats":{"Line":0}},{"line":325,"address":[3134130],"length":1,"stats":{"Line":1}},{"line":326,"address":[3134178],"length":1,"stats":{"Line":1}},{"line":327,"address":[3134330],"length":1,"stats":{"Line":0}},{"line":331,"address":[3134282,3134241,3134385],"length":1,"stats":{"Line":2}},{"line":332,"address":[3134253,3134371],"length":1,"stats":{"Line":1}},{"line":334,"address":[3134421],"length":1,"stats":{"Line":1}},{"line":335,"address":[3100617,3100592],"length":1,"stats":{"Line":3}},{"line":337,"address":[3134487],"length":1,"stats":{"Line":1}},{"line":338,"address":[3134496],"length":1,"stats":{"Line":1}},{"line":342,"address":[3134532],"length":1,"stats":{"Line":1}},{"line":343,"address":[3134554,3134625],"length":1,"stats":{"Line":2}},{"line":345,"address":[3134803,3134871],"length":1,"stats":{"Line":2}},{"line":347,"address":[3134909],"length":1,"stats":{"Line":1}},{"line":351,"address":[3134970],"length":1,"stats":{"Line":1}},{"line":353,"address":[3135010],"length":1,"stats":{"Line":1}},{"line":355,"address":[3135042,3135100],"length":1,"stats":{"Line":2}},{"line":356,"address":[3135180],"length":1,"stats":{"Line":1}},{"line":357,"address":[3135207],"length":1,"stats":{"Line":1}},{"line":358,"address":[3135283,3135236],"length":1,"stats":{"Line":2}},{"line":359,"address":[3135398,3135331],"length":1,"stats":{"Line":2}},{"line":363,"address":[3135856,3135804],"length":1,"stats":{"Line":2}},{"line":365,"address":[3135894],"length":1,"stats":{"Line":1}},{"line":368,"address":[3135978],"length":1,"stats":{"Line":1}},{"line":370,"address":[3135990],"length":1,"stats":{"Line":1}},{"line":373,"address":[3137770,3137764,3136144],"length":1,"stats":{"Line":1}},{"line":375,"address":[3136305,3136262,3136226],"length":1,"stats":{"Line":2}},{"line":376,"address":[3136242,3136294],"length":1,"stats":{"Line":1}},{"line":378,"address":[3136347],"length":1,"stats":{"Line":1}},{"line":379,"address":[3136356],"length":1,"stats":{"Line":0}},{"line":383,"address":[3136422,3136381,3136482],"length":1,"stats":{"Line":2}},{"line":384,"address":[3136393,3136471],"length":1,"stats":{"Line":1}},{"line":386,"address":[3136516],"length":1,"stats":{"Line":1}},{"line":387,"address":[3100640,3100665],"length":1,"stats":{"Line":3}},{"line":389,"address":[3136582],"length":1,"stats":{"Line":1}},{"line":390,"address":[3136586],"length":1,"stats":{"Line":0}},{"line":394,"address":[3136615],"length":1,"stats":{"Line":1}},{"line":395,"address":[3136744,3136656],"length":1,"stats":{"Line":1}},{"line":396,"address":[3136732],"length":1,"stats":{"Line":0}},{"line":399,"address":[3136756],"length":1,"stats":{"Line":1}},{"line":404,"address":[3136811],"length":1,"stats":{"Line":1}},{"line":406,"address":[3136849],"length":1,"stats":{"Line":1}},{"line":407,"address":[3136931,3136867],"length":1,"stats":{"Line":2}},{"line":409,"address":[3137023],"length":1,"stats":{"Line":1}},{"line":410,"address":[3137044],"length":1,"stats":{"Line":1}},{"line":411,"address":[3137120,3137073],"length":1,"stats":{"Line":2}},{"line":416,"address":[3137612,3137560],"length":1,"stats":{"Line":2}},{"line":418,"address":[3137650],"length":1,"stats":{"Line":1}},{"line":421,"address":[3137734],"length":1,"stats":{"Line":1}},{"line":423,"address":[3137741],"length":1,"stats":{"Line":1}},{"line":426,"address":[3137792,3138832,3138826],"length":1,"stats":{"Line":1}},{"line":428,"address":[3137884,3137848,3137927],"length":1,"stats":{"Line":2}},{"line":429,"address":[3137916,3137864],"length":1,"stats":{"Line":1}},{"line":431,"address":[3137966],"length":1,"stats":{"Line":1}},{"line":432,"address":[3137975],"length":1,"stats":{"Line":0}},{"line":436,"address":[3138001],"length":1,"stats":{"Line":1}},{"line":437,"address":[3138015],"length":1,"stats":{"Line":1}},{"line":438,"address":[3138208],"length":1,"stats":{"Line":0}},{"line":442,"address":[3138050],"length":1,"stats":{"Line":1}},{"line":446,"address":[3138064],"length":1,"stats":{"Line":1}},{"line":448,"address":[3138102],"length":1,"stats":{"Line":1}},{"line":449,"address":[3138118],"length":1,"stats":{"Line":1}},{"line":455,"address":[3138274,3138197],"length":1,"stats":{"Line":2}},{"line":458,"address":[3138680,3138631],"length":1,"stats":{"Line":2}},{"line":460,"address":[3138715],"length":1,"stats":{"Line":1}},{"line":463,"address":[3138799],"length":1,"stats":{"Line":1}},{"line":465,"address":[3138806],"length":1,"stats":{"Line":1}},{"line":472,"address":[3139245,3138896,3139239],"length":1,"stats":{"Line":1}},{"line":473,"address":[3138931],"length":1,"stats":{"Line":1}},{"line":476,"address":[3138993,3138941],"length":1,"stats":{"Line":2}},{"line":477,"address":[3139026],"length":1,"stats":{"Line":0}},{"line":482,"address":[3139064,3139004],"length":1,"stats":{"Line":4}},{"line":483,"address":[3100736],"length":1,"stats":{"Line":2}},{"line":484,"address":[3100769,3101017,3101040,3101054],"length":1,"stats":{"Line":4}},{"line":485,"address":[3100864,3101019,3101014],"length":1,"stats":{"Line":2}},{"line":487,"address":[3100895],"length":1,"stats":{"Line":1}},{"line":491,"address":[3139135],"length":1,"stats":{"Line":1}},{"line":492,"address":[3139189],"length":1,"stats":{"Line":3}},{"line":493,"address":[3101176,3101152],"length":1,"stats":{"Line":3}},{"line":504,"address":[3139613,3139264,3139607],"length":1,"stats":{"Line":1}},{"line":505,"address":[3139299],"length":1,"stats":{"Line":1}},{"line":507,"address":[3139361,3139309],"length":1,"stats":{"Line":2}},{"line":508,"address":[3139394],"length":1,"stats":{"Line":0}},{"line":513,"address":[3139372,3139432],"length":1,"stats":{"Line":4}},{"line":514,"address":[3101312],"length":1,"stats":{"Line":2}},{"line":515,"address":[3101630,3101616,3101593,3101345],"length":1,"stats":{"Line":4}},{"line":516,"address":[3101595,3101440,3101590],"length":1,"stats":{"Line":2}},{"line":518,"address":[3101471],"length":1,"stats":{"Line":1}},{"line":522,"address":[3139503],"length":1,"stats":{"Line":1}},{"line":523,"address":[3101696,3101706],"length":1,"stats":{"Line":3}},{"line":524,"address":[3101752,3101728],"length":1,"stats":{"Line":3}},{"line":527,"address":[3139975,3139981,3139632],"length":1,"stats":{"Line":1}},{"line":528,"address":[3139667],"length":1,"stats":{"Line":1}},{"line":531,"address":[3139677,3139729],"length":1,"stats":{"Line":2}},{"line":532,"address":[3139762],"length":1,"stats":{"Line":0}},{"line":536,"address":[3139740,3139800],"length":1,"stats":{"Line":4}},{"line":537,"address":[3102263,3101888,3102269],"length":1,"stats":{"Line":2}},{"line":538,"address":[3102288,3101921,3102057,3102302],"length":1,"stats":{"Line":4}},{"line":539,"address":[3102021],"length":1,"stats":{"Line":1}},{"line":542,"address":[3102069,3102159],"length":1,"stats":{"Line":1}},{"line":546,"address":[3139871],"length":1,"stats":{"Line":1}},{"line":547,"address":[3102368,3102387],"length":1,"stats":{"Line":3}},{"line":548,"address":[3139945],"length":1,"stats":{"Line":3}},{"line":552,"address":[3140000,3140349,3140343],"length":1,"stats":{"Line":1}},{"line":553,"address":[3140035],"length":1,"stats":{"Line":1}},{"line":556,"address":[3140045,3140097],"length":1,"stats":{"Line":2}},{"line":557,"address":[3140130],"length":1,"stats":{"Line":0}},{"line":561,"address":[3102560,3102574],"length":1,"stats":{"Line":4}},{"line":562,"address":[3102608,3102989,3102983],"length":1,"stats":{"Line":2}},{"line":563,"address":[3103008,3102641,3102777,3103022],"length":1,"stats":{"Line":4}},{"line":564,"address":[3102741],"length":1,"stats":{"Line":1}},{"line":567,"address":[3102879,3102789],"length":1,"stats":{"Line":1}},{"line":571,"address":[3140239],"length":1,"stats":{"Line":1}},{"line":572,"address":[3103088,3103107],"length":1,"stats":{"Line":3}},{"line":573,"address":[3103168,3103192],"length":1,"stats":{"Line":3}}],"covered":191,"coverable":208},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05;\npub mod ej06;","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","julieta-murias","repos","seminario-rust","src","main.rs"],"content":"//mod tp02;\nmod tp03;\n//mod tp04;\nmod tp05;\n\n\nuse std::io::stdin;\nuse core::panic;\nconst NUMERO:i32 = 10; //ejercicio 7\nconst WORD: \u0026str = \"Abracadabra\"; //ejercicio 8\n\nfn main() { \n    //Práctica 1:\n    \n    //ejercicio 1--------------------------------\n    let fp_number  = 2.0;\n    println! (\"Write another number: \");\n    let mut number = String::new();\n    stdin().read_line(\u0026 mut number).expect(\"error\");\n    let number_okay:f64 = number.trim().parse().expect(\"error2\");\n\n    println! (\"first operation * , {}\" , fp_number * number_okay);\n    println! (\"second operation / , {}\" , number_okay / fp_number);\n    println! (\"third operation + , {}\" , fp_number + number_okay);\n    println! (\"fourth operation - , {}\" , number_okay - fp_number);\n\n\n    //ejercicio 2------------------------------------\n    let integer_number:u32 = 1234567890;\n    let hex_string = format!(\"{:X}\" , integer_number);\n    println!(\"{}\", hex_string);\n\n\n    //ejercicio 3---------------------------------\n    let t:bool = true; //defino variable booleana\n\n    let mut var_ingresada=String::new(); //el dato tiene que ser de tipo string para leerlo por teclado\n\n    println!(\"Ingresa un valor booleano (true or false\");\n\n\n   //leo el dato\n    stdin().read_line(\u0026mut var_ingresada)\n    .expect(\"error\"); \n\n    //convierto el dato a un booleano\n    let mut var_ingresada: bool = match var_ingresada.trim().parse(){\n        Ok(bool) =\u003e bool,\n        Err(_) =\u003e {\n            eprintln!(\"error\");\n            return;\n        }\n    };\n\n    let mut var_ingresada = var_ingresada \u0026\u0026 t;\n    println!(\"AND {} \", var_ingresada);\n\n    let mut var_ingresada = var_ingresada || t;\n    println!(\"OR {} \", var_ingresada);\n\n\n\n    //ejercicio4 ----------------------------------------\n    let tupla:(String , i32 , bool) = (\"let's get rusty\".to_string() , 10 , false);\n    println!(\"{} , {} , {}\" , tupla.0, tupla.1 , tupla.2);\n\n\n\n    //ejercicio 5 ----------------------------------------\n    let mut chain = String::from(\"Hello \");\n\n    let mut chain_ingresada = String::new();\n\n    println!(\"Ingresa una cadena\");\n\n    //leo el dato\n    stdin().read_line(\u0026mut chain_ingresada).expect(\"error\");\n\n    //concateno ambas cadenas\n    chain.push_str(\u0026*chain_ingresada);\n\n    let chain = chain.to_string();\n    let chain = chain.to_ascii_uppercase();\n\n    println!(\"{}\", chain);\n\n\n    //ejercicio 6 ------------------------------------------\n    let mut number :u32 = 2;\n    let mut number_ingresado = String::new();\n\n    println!(\"Ingresa un número\");\n\n    stdin().read_line(\u0026mut number_ingresado).\n    expect(\"error\");\n\n    let mut number_ingresado:u32 = match number_ingresado.trim().parse(){\n        Ok(u32) =\u003e u32,\n        Err(_) =\u003e {\n            eprintln!(\"error\");\n            return;\n        }\n    };\n\n    let mut number = number + number_ingresado;\n    println!(\"{}\", number.pow(2));\n\n\n    //ejercicio 7 ------------------------------------------\n    let mut arreglo:[i32 ; 6] = [10 , 4 , 77 , 6 , 8 , 0];\n    \n    for number in arreglo.iter_mut(){\n        *number = match number{\n        \u0026mut number =\u003e number * NUMERO,\n        }\n     }\n    \n    for index in 0..arreglo.len() {\n        println!(\"{}\", arreglo[index]);\n    }\n\n\n\n    //ejercicio 8 --------------------------------------\n    println!(\"Ingrese una letra para ver la cantidad de veces que ésta aparece en la constante definida\");\n\n    let mut caracter = String::from (\" \");\n\n\n    //leo el caracter\n    stdin().read_line(\u0026mut caracter)\n    .expect(\"error\");\n\n\n    //convierto el string que leí a caracter\n    let mut caracter: char = caracter.trim().parse()\n    .expect(\"error\");\n\n    let mut cantidad: u32 = 0;\n    for letra in WORD.chars(){\n        if caracter.to_ascii_lowercase() == letra.to_ascii_lowercase(){\n            cantidad = cantidad + 1;\n        }\n    }\n\n    println!( \"La cantidad de veces que aparece el caracter {} es : {}\", caracter , cantidad);\n\n\n\n    //ejercicio 9 -------------------------------------\n    let numeros : [i32 ; 5] = [0 , 300 , -100 , 10 , 9];\n\n    let mut suma_total:i32 = 0;\n\n    for numero in 0..numeros.len(){\n        suma_total += numeros[numero];\n    }\n\n    println!(\"La suma total de los números es {}\" , suma_total);\n\n\n\n    //ejercicio 10 ---------------------------------------------\n    let numeros1: [i32 ; 5] = [10 , 20 , 30 , 40 , 50];\n    let numeros2: [i32 ; 5] =  [1 , 2 , 3 , 4 , 5];\n\n    let mut numeros_suma: [i32 ; 5] = [0, 0, 0, 0, 0];\n\n    \n    for number in 0..5{\n        let mut suma_auxiliar: i32 = 0;\n        suma_auxiliar = numeros1[number] + numeros2[number];\n\n        numeros_suma[number] = suma_auxiliar;\n    }\n\n    for elemento in 0..numeros_suma.len(){\n        println!(\"{}\" , numeros_suma[elemento]);\n    }\n\n\n\n    //ejercicio 11 ---------------------------------------\n    let cadenas:[\u0026str ; 5] = [\"Hello\" , \"Bye\" , \"How are you?\" , \"Pepe\" , \"Good\"];\n\n    println!(\"Ingrese una cadena\");\n    let mut cadena_ingresada = String::new();\n\n\n    stdin().read_line(\u0026mut cadena_ingresada)\n    .expect(\"Error :/\");\n\n    let cadena_ingresada = cadena_ingresada.trim();\n\n    if cadenas.contains(\u0026cadena_ingresada){\n        println!(\"Está! :D\");\n    } else {\n        println!(\"No está :/\");\n    }\n\n\n\n    //ejercicio 12-----------------------------------\n    let numeros: [i32 ; 4] = [0 , -10 , -20 , 100];\n    let tupla: (String , [i32 ; 4]) = (\"Hello pepe\".to_string() , numeros);\n\n    println!(\"La cadena de la tupla dice: {}\" , tupla.0);\n\n    let mut suma_total: i32 = 0;\n    for number in 0..tupla.1.len(){\n        suma_total += tupla.1[number];\n\n    }\n\n    println!(\"{}\" , suma_total);\n    \n\n\n\n}","traces":[{"line":12,"address":[3218416,3226346,3225364],"length":1,"stats":{"Line":0}},{"line":16,"address":[3218444],"length":1,"stats":{"Line":0}},{"line":17,"address":[3218452],"length":1,"stats":{"Line":0}},{"line":18,"address":[3218509],"length":1,"stats":{"Line":0}},{"line":19,"address":[3218514,3218585],"length":1,"stats":{"Line":0}},{"line":20,"address":[3218686],"length":1,"stats":{"Line":0}},{"line":22,"address":[3218844],"length":1,"stats":{"Line":0}},{"line":23,"address":[3218970],"length":1,"stats":{"Line":0}},{"line":24,"address":[3219096],"length":1,"stats":{"Line":0}},{"line":25,"address":[3219222],"length":1,"stats":{"Line":0}},{"line":29,"address":[3219331],"length":1,"stats":{"Line":0}},{"line":30,"address":[3219358],"length":1,"stats":{"Line":0}},{"line":31,"address":[3219536,3219465],"length":1,"stats":{"Line":0}},{"line":35,"address":[3219605],"length":1,"stats":{"Line":0}},{"line":37,"address":[3219621],"length":1,"stats":{"Line":0}},{"line":39,"address":[3219698,3219628],"length":1,"stats":{"Line":0}},{"line":43,"address":[3219717],"length":1,"stats":{"Line":0}},{"line":47,"address":[3219845],"length":1,"stats":{"Line":0}},{"line":48,"address":[3220007],"length":1,"stats":{"Line":0}},{"line":50,"address":[3226287,3219978],"length":1,"stats":{"Line":0}},{"line":55,"address":[3220026],"length":1,"stats":{"Line":0}},{"line":56,"address":[3220048],"length":1,"stats":{"Line":0}},{"line":58,"address":[3220144],"length":1,"stats":{"Line":0}},{"line":59,"address":[3220172],"length":1,"stats":{"Line":0}},{"line":64,"address":[3220268],"length":1,"stats":{"Line":0}},{"line":65,"address":[3220346,3220413],"length":1,"stats":{"Line":0}},{"line":70,"address":[3220568],"length":1,"stats":{"Line":0}},{"line":72,"address":[3220603],"length":1,"stats":{"Line":0}},{"line":74,"address":[3220654,3220721],"length":1,"stats":{"Line":0}},{"line":77,"address":[3220740],"length":1,"stats":{"Line":0}},{"line":80,"address":[3220868],"length":1,"stats":{"Line":0}},{"line":82,"address":[3220938],"length":1,"stats":{"Line":0}},{"line":83,"address":[3220953,3221044],"length":1,"stats":{"Line":0}},{"line":85,"address":[3221119,3221051],"length":1,"stats":{"Line":0}},{"line":89,"address":[3218423],"length":1,"stats":{"Line":0}},{"line":90,"address":[3221196],"length":1,"stats":{"Line":0}},{"line":92,"address":[3221273,3221203],"length":1,"stats":{"Line":0}},{"line":94,"address":[3221292],"length":1,"stats":{"Line":0}},{"line":97,"address":[3221420],"length":1,"stats":{"Line":0}},{"line":98,"address":[3221594],"length":1,"stats":{"Line":0}},{"line":100,"address":[3221565,3226139],"length":1,"stats":{"Line":0}},{"line":105,"address":[3221656,3221608],"length":1,"stats":{"Line":0}},{"line":106,"address":[3221642,3221683],"length":1,"stats":{"Line":0}},{"line":110,"address":[3221786],"length":1,"stats":{"Line":0}},{"line":112,"address":[3226113,3221865],"length":1,"stats":{"Line":0}},{"line":113,"address":[3226111],"length":1,"stats":{"Line":0}},{"line":114,"address":[3222053,3226118],"length":1,"stats":{"Line":0}},{"line":118,"address":[3222091],"length":1,"stats":{"Line":0}},{"line":119,"address":[3222264,3225961],"length":1,"stats":{"Line":0}},{"line":125,"address":[3222279],"length":1,"stats":{"Line":0}},{"line":127,"address":[3222324],"length":1,"stats":{"Line":0}},{"line":131,"address":[3222422,3222351],"length":1,"stats":{"Line":0}},{"line":136,"address":[3222712,3222523],"length":1,"stats":{"Line":0}},{"line":139,"address":[3222719],"length":1,"stats":{"Line":0}},{"line":140,"address":[3222730],"length":1,"stats":{"Line":0}},{"line":141,"address":[3225927,3222924,3225867],"length":1,"stats":{"Line":0}},{"line":142,"address":[3225897,3225932],"length":1,"stats":{"Line":0}},{"line":146,"address":[3222941],"length":1,"stats":{"Line":0}},{"line":151,"address":[3223080],"length":1,"stats":{"Line":0}},{"line":153,"address":[3223135],"length":1,"stats":{"Line":0}},{"line":155,"address":[3223146,3225833],"length":1,"stats":{"Line":0}},{"line":156,"address":[3225763,3223319,3225838],"length":1,"stats":{"Line":0}},{"line":159,"address":[3223334],"length":1,"stats":{"Line":0}},{"line":164,"address":[3223430],"length":1,"stats":{"Line":0}},{"line":165,"address":[3223485],"length":1,"stats":{"Line":0}},{"line":167,"address":[3223540],"length":1,"stats":{"Line":0}},{"line":170,"address":[3223562,3225716],"length":1,"stats":{"Line":0}},{"line":171,"address":[3223735],"length":1,"stats":{"Line":0}},{"line":172,"address":[3225521,3223746,3225676],"length":1,"stats":{"Line":0}},{"line":174,"address":[3225729,3225657,3225709],"length":1,"stats":{"Line":0}},{"line":177,"address":[3223761],"length":1,"stats":{"Line":0}},{"line":178,"address":[3223934,3225378],"length":1,"stats":{"Line":0}},{"line":184,"address":[3223949],"length":1,"stats":{"Line":0}},{"line":186,"address":[3224084],"length":1,"stats":{"Line":0}},{"line":187,"address":[3224137],"length":1,"stats":{"Line":0}},{"line":190,"address":[3224144,3224215],"length":1,"stats":{"Line":0}},{"line":193,"address":[3224310],"length":1,"stats":{"Line":0}},{"line":195,"address":[3224380],"length":1,"stats":{"Line":0}},{"line":196,"address":[3224570,3224452],"length":1,"stats":{"Line":0}},{"line":198,"address":[3224478,3224426],"length":1,"stats":{"Line":0}},{"line":204,"address":[3224499],"length":1,"stats":{"Line":0}},{"line":205,"address":[3224591,3224543],"length":1,"stats":{"Line":0}},{"line":207,"address":[3224639,3224706],"length":1,"stats":{"Line":0}},{"line":209,"address":[3224775],"length":1,"stats":{"Line":0}},{"line":210,"address":[3225338,3224786],"length":1,"stats":{"Line":0}},{"line":211,"address":[3225271,3225343,3224932],"length":1,"stats":{"Line":0}},{"line":215,"address":[3224947],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":87},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej01.rs"],"content":"\n    pub fn es_par(numero: i32) -\u003e bool {\n        numero % 2 == 0\n    }\n\n    #[test]\n    //#[should_panic] \n    fn probar (){\n        let number:i32 = 2;\n        let par:bool = es_par(number);\n        assert_eq!(par, true);\n    }\n   \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej02.rs"],"content":"\n    \n    pub fn es_primo (numero : i32) -\u003e bool{\n\n        if numero \u003e 1 {\n\n            //check if primo\n            if (numero % numero == 0) \u0026 (numero % 1 == 0){ \n                if numero % (numero/2) != 0 {\n                    true\n                }\n\n                else{\n                    false\n                }\n            } else {\n                false\n            }\n        }\n\n        else{\n            false\n        }\n\n    }\n\n    #[test]\n    fn testear(){\n       let number:i32 = 1;\n        let primo:bool = es_primo(number);\n\n         assert_eq!(primo, false);\n    }\n    \n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej03.rs"],"content":"\n\n    \n    pub fn suma_pares(arreglo:[i32; 10]) -\u003e i32{\n        \n        let mut suma_p:i32 = 0;\n        for number in arreglo.iter(){\n            if number % 2 == 0 {\n                suma_p += number;\n            }\n        }\n\n        suma_p\n    }\n\n    //#[test] \n    fn testear (){\n        let numeros:[i32; 10] = [1,2,3,4,5,6,7,8,9,10];\n        let resultado = suma_pares(numeros);\n\n        assert_eq!(resultado, 30);\n\n    }\n    \n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej04.rs"],"content":"\n\n\n    pub fn cant_impar (numbers:[i32 ; 10]) -\u003e u32{\n\n        let mut impares = 0;\n        for number in numbers.iter(){\n            if number % 2 != 0{\n                impares += 1;\n            }\n        }\n\n        impares\n    }\n\n\n# [should_panic]\n# [test]\nfn helper (){\n    let numeros:[i32 ; 10] = [1,2,3,4,5,6,7,8,9,10];\n    let numeros_impares = cant_impar(numeros);\n\n    assert_eq!(numeros_impares , 9);\n\n}\n\n    \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej05.rs"],"content":"\n\n    fn duplicar_valores(numbers:[f64 ; 5]) -\u003e [f64 ; 5]{\n\n        let mut new_array :[f64 ; 5] = [0.0,0.0,0.0,0.0,0.0];\n\n        for n in 0 .. numbers.len(){\n            new_array[n] = numbers[n] * 2.0;\n\n        }\n\n        new_array\n\n    }\n\n\n //# [should_panic]\n # [test]\nfn helper(){\n    let numeros:[f64 ; 5] = [0.0 , 1.1 , 2.2 , 3.3 , 4.4];\n    let doble_numeros:[f64 ; 5] = duplicar_valores(numeros);\n\n    assert_eq!(doble_numeros[0] , 0.0)\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej06.rs"],"content":"\n\n\n\n    pub fn longitud_de_cadenas(strings:[String ; 3]) -\u003e [u32 ; 3]{\n\n        let mut longitudes:[u32 ; 3] = [0 , 0 , 0];\n        for n in 0..strings.len(){\n            longitudes[n] = strings[n].len() as u32;\n        }\n\n        longitudes\n\n    }\n      \n\n# [should_panic]\n# [test]\nfn tester (){\n    let arreglo_strings:[String ; 3] = [String::from(\"Hello\") , String::from(\"world\") , String::from(\"!\")]; \n    let output:[u32 ; 3] = longitud_de_cadenas (arreglo_strings);\n\n    assert_eq!(output[0] , 8); \n}\n   \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej07.rs"],"content":"\n\n\n    pub fn cant_mayores(numbers:[i32 ; 10] , limite:i32 ) -\u003e u32{\n\n        let mut cant_mayor = 0;\n        for number in numbers.iter(){\n            if number \u003e \u0026limite{ \n                cant_mayor += 1;\n            }\n        }\n\n        cant_mayor\n\n    }\n\n    # [should_panic]\n    # [test]\n    fn testear(){\n        let numeros:[i32 ; 10] = [-5 , 800 , -30, -2 , -1 , 0 , 244 , 9999 , 11 , 12];\n        let limite = 0;\n    \n        let cant_num_mayores = cant_mayores (numeros , limite);\n    \n        assert_eq!(cant_num_mayores , 9); \n    }\n    \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej08.rs"],"content":"\n\n\n\n\n    pub fn sumar_arreglos(array1:[f64 ; 2] , array2:[f64 ; 2]) -\u003e [f64 ; 2]{\n\n        let mut results:[f64 ; 2]= [0.0 , 0.0];\n\n        for n in 0..array1.len(){\n            results[n] = array1[n] + array2[n];\n        }\n\n        results\n    }\n\n//# [should_panic]\n# [test]\nfn testear(){\n    let numbers1:[f64 ; 2]= [0.0 , 25.2];\n    let numbers2:[f64 ; 2]= [-2.4 , 3.1];\n\n    let sums:[f64 ; 2]= sumar_arreglos(numbers1 , numbers2);\n\n    assert_eq!(sums[0] , -2.4);\n    assert_eq!(sums[1] , 28.3);\n}\n    \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej09.rs"],"content":"\n\n\n    pub fn cantidad_en_rango (array:[i32 ; 10] , inferior: i32 , superior: i32) -\u003e u32{\n        let mut cant_num:u32 = 0;\n\n        for number in array.iter(){\n            if \u0026inferior \u003c= number \u0026\u0026 number \u003c= \u0026superior{\n                cant_num += 1;\n            }\n        }\n\n        cant_num\n    }\n\n#[should_panic]\n#[test]\nfn testear(){\n    let numbers:[i32 ; 10]= [0,1,2,3,4,5,6,7,8,9];\n    let inferior = 1;\n    let superior = 5;\n\n    let cant_numeros_entre = cantidad_en_rango(numbers , inferior , superior);\n\n    assert_eq!(cant_numeros_entre , 9);\n}\n   \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej10.rs"],"content":"\n\n\n    pub fn cantidad_de_cadenas_mayor_a (array:[String ; 4] , limite: u32) -\u003e u32{\n        let mut cant_result:u32 = 0;\n\n        for element in array.iter(){\n            if element.len() as u32 \u003e limite{\n                cant_result += 1;\n            }\n        }\n\n        cant_result\n\n    }\n\n//#[should_panic]\n#[test]\nfn testear(){\n    let strings:[String ; 4] = [String::from(\"Hello\") , String::from(\"Abracadabra\") , String::from(\"Eye\") , String::from(\"Banana\")];\n    let limite:u32 = 4;\n\n    let cant_cumplen = cantidad_de_cadenas_mayor_a(strings , limite);\n\n    assert_eq!(cant_cumplen , 3);\n}\n\n    \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej11.rs"],"content":"\n\n\n\n    pub fn multiplicar_valores ( array: \u0026mut [i32 ; 5] , factor: i32){\n        \n        for number in array.iter_mut(){\n            *number = *number * factor; \n        }\n\n    }\n\n//#[should_panic]\n#[test]\nfn testear(){\n    let mut numbers:[i32 ; 5] = [1 , 2 , 3 , 4 , 5];\n    let factor: i32 = -1;\n\n    multiplicar_valores(\u0026mut numbers , factor); \n\n    assert_eq!(numbers[0] , -1);\n}\n\n    \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej12.rs"],"content":"\n\n\n    pub fn reemplazar_pares (array:\u0026mut[i32 ; 10]){\n\n        for number in array.iter_mut(){\n            if *number % 2 == 0 {\n                *number = -1;\n            }\n        }\n    }\n\n//# [should_panic]\n#[test]\nfn testear(){\n    let mut numbers:[i32 ; 10] = [1,2,3,4,5,6,7,8,9,10];\n    reemplazar_pares (\u0026mut numbers);\n\n    assert_eq!(numbers[1] , -1);\n}\n   \n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej13.rs"],"content":"\n\n\n\n\n    pub fn ordenar_nombres (array: \u0026mut[String; 7]){ \n        array.sort();\n\n    }\n\n//#[should_panic]\n#[test]\nfn testear(){\n    let mut names:[String ; 7] = [String::from(\"Juli\") , String::from(\"Benja\") , String::from(\"Gonza\") , String::from(\"Fio\") , String::from(\"Angi\") , String::from(\"Emi\") , String::from(\"Angel\")];\n\n    ordenar_nombres (\u0026mut names);\n\n    assert_eq!(names[0] , \"Angel\");\n}\n   \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","ej14.rs"],"content":"//# [should_panic]\n//#[test]\n\n\n\n    pub fn incrementar (number: \u0026mut f64){\n        *number = *number + 1.0;\n    }\n\n//# [should_panic]\n#[test]\nfn testear(){\n    let mut number:f64 = 0.0;\n    incrementar (\u0026mut number);\n\n    assert_eq!(number , 1.0);\n}\n\n  ","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp02","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05; \npub mod ej06;\npub mod ej07;\npub mod ej08;\npub mod ej09;\npub mod ej10;\npub mod ej11;\npub mod ej12;\npub mod ej13;\npub mod ej14;","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej01.rs"],"content":"struct Persona {\n    edad: u32,\n    nombre: String,\n    direccion: Option\u003cString\u003e,\n}\n\nimpl Persona {\n    fn new (edad: u32, nombre: String, direccion: Option\u003cString\u003e) -\u003e Persona {\n        Persona {\n            edad,\n            nombre,\n            direccion,\n        }\n    }\n\n    fn to_string (\u0026self) -\u003e String {\n        let direction_str = if let Some(dir) = \u0026self.direccion{\n            dir.as_str()\n        } else {\n            \"None\"\n        };\n\n        format! (\"Name: {}, age: {}, direction: {}\", self.nombre, self.edad, direction_str)\n    }\n\n    fn obtener_edad (\u0026self) -\u003e u32 {\n        self.edad\n    }\n\n    fn actualizar_direccion (\u0026mut self, new_direction: Option\u003cString\u003e){\n        self.direccion = new_direction;\n    }\n\n}\n\n//# [should_panic]\n# [test]\nfn tester(){\n    let mut me_without_direction = Persona::new (19, String::from(\"Julieta\"), None);\n    let mut me_with_direction = Persona::new (19, String::from(\"Julieta\"), Some (String::from(\"Salto\")));\n\n    let message1 = me_with_direction.to_string();\n    //println!(\"{}\", message1); \n    println!(\"{}\", me_without_direction.to_string());\n\n    assert_eq!(me_with_direction.obtener_edad(), 19);\n\n    me_with_direction.actualizar_direccion(Some(String::from(\"La Plata/Salto\")));\n    println!(\"{}\", me_with_direction.to_string());\n}","traces":[{"line":8,"address":[3281168],"length":1,"stats":{"Line":1}},{"line":16,"address":[3281232],"length":1,"stats":{"Line":1}},{"line":17,"address":[3281261],"length":1,"stats":{"Line":1}},{"line":18,"address":[3281319],"length":1,"stats":{"Line":1}},{"line":20,"address":[3281336],"length":1,"stats":{"Line":1}},{"line":23,"address":[3281361],"length":1,"stats":{"Line":1}},{"line":26,"address":[3281584],"length":1,"stats":{"Line":1}},{"line":27,"address":[3281589],"length":1,"stats":{"Line":1}},{"line":30,"address":[3281665,3281600],"length":1,"stats":{"Line":1}},{"line":31,"address":[3281700,3281618],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej02.rs"],"content":"struct Rectangulo {\n    longitud: f64,\n    ancho: f64,\n}\n\nimpl Rectangulo {\n\n    fn new (ancho: f64, longitud: f64) -\u003e Rectangulo {\n        Rectangulo{\n            longitud,\n            ancho,\n        }\n    }\n\n    fn calcular_area (\u0026self) -\u003e f64 {\n        self.longitud * self.ancho\n    }\n\n    fn calcular_perimetro (\u0026self) -\u003e f64 {\n        2.0 * (self.longitud + self.ancho)\n    }\n\n    fn es_cuadrado (\u0026self) -\u003e bool {\n        self.longitud == self.ancho\n    }\n}\n\n//#[should_panic]\n#[test]\nfn tester() {\n    let rectangle = Rectangulo::new(2.0, 2.0);\n    assert_eq!(rectangle.calcular_area(), 4.0);\n    assert_eq!(rectangle.calcular_perimetro(), 8.0);\n    assert_eq!(rectangle.es_cuadrado(), true);\n}","traces":[{"line":8,"address":[3125056],"length":1,"stats":{"Line":1}},{"line":15,"address":[3125088],"length":1,"stats":{"Line":1}},{"line":16,"address":[3125093],"length":1,"stats":{"Line":1}},{"line":19,"address":[3125104],"length":1,"stats":{"Line":1}},{"line":20,"address":[3125109],"length":1,"stats":{"Line":1}},{"line":23,"address":[3125136],"length":1,"stats":{"Line":1}},{"line":24,"address":[3125141],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej03.rs"],"content":"use serde::{Serialize, Deserialize};\n#[derive(Clone, Serialize, Deserialize)]\npub struct Fecha {\n    pub dia: u32,\n    pub mes: u32,\n    pub año: u32,\n}\n\nimpl Fecha {\n    pub fn new (dia: u32, mes: u32, año: u32) -\u003e Fecha {\n        Fecha {\n            dia,\n            mes,\n            año,\n        }\n    }\n\n    fn es_bisiesto (\u0026self) -\u003e bool {\n        // A year is a leap year if:\n        // 1. It is divisible by 4, and\n        // 2. It is not divisible by 100, unless it is also divisible by 400.\n        self.año % 4 == 0 \u0026\u0026 self.año % 100 != 0 || self.año % 400 == 0\n    }\n\n    fn es_fecha_valida (\u0026self) -\u003e bool {\n        let days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n        if self.mes \u003c 1 || self.mes \u003e 12 { \n            return false;\n        }\n\n        let mut max_days = days_in_month[self.mes as usize];\n\n        if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n            max_days = 29;\n        }\n\n        self.dia \u003e= 1 \u0026\u0026 self.dia \u003c= max_days\n    }\n\n    pub fn sumar_dias (\u0026mut self, mut days: u32) {\n        let days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let mut days_in_current_month = days_in_month[self.mes as usize];\n\n        if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n            days_in_current_month = 29;\n        }\n\n        //Calculate the remaining days in the current month.\n        let mut remaining_days_in_month = days_in_current_month - self.dia;\n\n        while days \u003e remaining_days_in_month {\n            days -= remaining_days_in_month + 1; //+1 ensures that the current day is included when transitioning to the next month.\n\n            self.dia = 1; //Move to the next month.\n            self.mes += 1;\n\n            if self.mes \u003e 12 {\n                self.año += 1;\n                self.mes = 1;\n            }\n\n            //Recalculate the days in the current month.\n            days_in_current_month = days_in_month[self.mes as usize];\n            if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n                days_in_current_month = 29;\n            } \n\n            remaining_days_in_month = days_in_current_month - self.dia;\n        }\n        self.dia += days;  \n    }\n\n    fn restar_dias (\u0026mut self, mut days: u32) {\n        let days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let mut days_in_current_month = days_in_month[self.mes as usize];\n\n        if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n            days_in_current_month = 29;\n        }\n\n        while days \u003e= self.dia { // While the number of days to subtract is greater than or equal to the current day.\n            days -= self.dia; \n\n            self.mes -= 1;\n            if self.mes \u003c 1 {\n                self.año -= 1;\n                self.mes = 12;\n            }   \n\n            // Recalculate the days in the current month.\n            days_in_current_month = days_in_month[self.mes as usize];\n            if self.mes == 2 \u0026\u0026 self.es_bisiesto() {\n                days_in_current_month = 29;\n            } \n\n            self.dia = days_in_current_month; // Move to the end of the previous month.\n        }\n\n        self.dia -= days; // Subtract the remaining days.\n\n    }\n\n    pub fn es_mayor (\u0026self, other: \u0026Fecha) -\u003e bool { //Retorna true si la fecha que recibí es mayor.\n\n        //First check the year.\n        if other.año \u003c self.año {\n            return true;\n        } else if other.año \u003e self.año {\n            return false;\n        }\n\n        //Check month.\n        if other.mes \u003c self.mes {\n            return true;\n        } else if other.mes \u003e self.mes {\n            return false;\n        }\n\n        //If months are equal, compare day.\n        other.dia \u003c self.dia\n    }\n}\n\n\n\n#[cfg(test)]\nmod tests{\n    use super::*;\n\n    #[test]\n    fn test_es_fecha_valida() {\n        let mut date1 = Fecha {\n            dia: 12,\n            mes: 5,\n            año: 2006,\n        };\n        assert_eq!(date1.es_fecha_valida(), true);\n\n        let mut date2 = Fecha::new(21, 13, 2024);\n        assert_eq!(date2.es_fecha_valida(), false);\n    }\n\n    #[test]\n    fn test_es_bisiesto() {\n        let mut date1 = Fecha {\n            dia: 12,\n            mes: 5,\n            año: 2006,\n        };\n        assert_eq!(date1.es_bisiesto(), false);\n\n        let mut date2 = Fecha::new(21, 12, 2024);\n        assert_eq!(date2.es_bisiesto(), true);\n    }\n\n    #[test]\n    fn test_sumar_dias() {\n        let mut date1 = Fecha {\n            dia: 1,\n            mes: 5,\n            año: 2006,\n        };\n\n        date1.sumar_dias(0);\n        assert_eq!(date1.dia, 1);\n\n        date1.sumar_dias(31); //Se pasa de mes.\n        assert_eq!(date1.dia, 1);\n        assert_eq!(date1.mes, 6);\n\n        date1.sumar_dias(250); //se pasa de año. (Quedaría en Feb 6 2007).\n        assert_eq!(date1.dia, 6);\n        assert_eq!(date1.mes, 2);\n        assert_eq!(date1.año, 2007);\n    }\n\n    #[test]\n    fn test_restar_dias() {\n        let mut date1 = Fecha {\n            dia: 10,\n            mes: 5,\n            año: 2006,\n        };\n\n        date1.restar_dias(5); //Solo cambia el día.\n        assert_eq!(date1.dia, 5);\n\n        date1.restar_dias(10); //Quedaría en 25/04/2006\n        assert_eq!(date1.dia, 25);\n        assert_eq!(date1.mes, 4);\n        assert_eq!(date1.año, 2006);\n\n        date1.restar_dias(200); //07/10/2005\n        assert_eq!(date1.dia, 7);\n        assert_eq!(date1.mes, 10);\n        assert_eq!(date1.año, 2005);\n    }\n\n    #[test]\n    fn test_es_mayor() {\n        let date1= Fecha::new(12, 5, 2006);\n        let date2= Fecha::new(31, 12, 2006);\n        let date3= Fecha::new(1, 1, 2005);\n\n        assert_eq!(date1.es_mayor(\u0026date2), false);\n        assert_eq!(date1.es_mayor(\u0026date3), true);\n    }\n\n\n}\n","traces":[{"line":10,"address":[2736720],"length":1,"stats":{"Line":1}},{"line":18,"address":[2736752],"length":1,"stats":{"Line":1}},{"line":22,"address":[2736762],"length":1,"stats":{"Line":1}},{"line":25,"address":[2736848],"length":1,"stats":{"Line":1}},{"line":26,"address":[2736862],"length":1,"stats":{"Line":1}},{"line":28,"address":[2736966],"length":1,"stats":{"Line":1}},{"line":29,"address":[2736983],"length":1,"stats":{"Line":1}},{"line":32,"address":[2737040,2736998],"length":1,"stats":{"Line":1}},{"line":34,"address":[2737028,2737063,2737092],"length":1,"stats":{"Line":1}},{"line":35,"address":[2737084],"length":1,"stats":{"Line":0}},{"line":38,"address":[2737077,2737094],"length":1,"stats":{"Line":1}},{"line":41,"address":[2737136],"length":1,"stats":{"Line":1}},{"line":42,"address":[2737160],"length":1,"stats":{"Line":1}},{"line":43,"address":[2737309,2737264],"length":1,"stats":{"Line":1}},{"line":45,"address":[2737374,2737332,2737296],"length":1,"stats":{"Line":1}},{"line":46,"address":[2737366],"length":1,"stats":{"Line":0}},{"line":50,"address":[2737380,2737386,2737346],"length":1,"stats":{"Line":2}},{"line":52,"address":[2737384,2737399,2737779],"length":1,"stats":{"Line":3}},{"line":53,"address":[2737431,2737552,2737485],"length":1,"stats":{"Line":2}},{"line":55,"address":[2737529],"length":1,"stats":{"Line":1}},{"line":56,"address":[2737574,2737585,2737535],"length":1,"stats":{"Line":2}},{"line":58,"address":[2737577,2737658],"length":1,"stats":{"Line":2}},{"line":59,"address":[2737660,2737624],"length":1,"stats":{"Line":1}},{"line":60,"address":[2737651],"length":1,"stats":{"Line":1}},{"line":64,"address":[2737683,2737704,2737603],"length":1,"stats":{"Line":2}},{"line":65,"address":[2737691,2737769,2737727],"length":1,"stats":{"Line":2}},{"line":66,"address":[2737761],"length":1,"stats":{"Line":0}},{"line":69,"address":[2737784,2737741,2737775],"length":1,"stats":{"Line":2}},{"line":71,"address":[2737458,2737414,2737468],"length":1,"stats":{"Line":2}},{"line":74,"address":[2737808],"length":1,"stats":{"Line":1}},{"line":75,"address":[2737826],"length":1,"stats":{"Line":1}},{"line":76,"address":[2737975,2737930],"length":1,"stats":{"Line":1}},{"line":78,"address":[2737962,2737998,2738030],"length":1,"stats":{"Line":1}},{"line":79,"address":[2738022],"length":1,"stats":{"Line":0}},{"line":82,"address":[2738340,2738012],"length":1,"stats":{"Line":2}},{"line":83,"address":[2738143,2738120,2738062],"length":1,"stats":{"Line":2}},{"line":85,"address":[2738165,2738124,2738176],"length":1,"stats":{"Line":2}},{"line":86,"address":[2738251,2738168],"length":1,"stats":{"Line":2}},{"line":87,"address":[2738215,2738253],"length":1,"stats":{"Line":1}},{"line":88,"address":[2738244],"length":1,"stats":{"Line":1}},{"line":92,"address":[2738194,2738276,2738297],"length":1,"stats":{"Line":2}},{"line":93,"address":[2738353,2738284,2738320],"length":1,"stats":{"Line":2}},{"line":94,"address":[2738345],"length":1,"stats":{"Line":0}},{"line":97,"address":[2738334],"length":1,"stats":{"Line":1}},{"line":100,"address":[2738091,2738098,2738037],"length":1,"stats":{"Line":2}},{"line":104,"address":[2738368],"length":1,"stats":{"Line":1}},{"line":107,"address":[2738388],"length":1,"stats":{"Line":1}},{"line":108,"address":[2738416],"length":1,"stats":{"Line":1}},{"line":109,"address":[2738406],"length":1,"stats":{"Line":1}},{"line":110,"address":[2738443],"length":1,"stats":{"Line":0}},{"line":114,"address":[2738433],"length":1,"stats":{"Line":1}},{"line":115,"address":[2738470],"length":1,"stats":{"Line":0}},{"line":116,"address":[2738460],"length":1,"stats":{"Line":1}},{"line":117,"address":[2738502],"length":1,"stats":{"Line":1}},{"line":121,"address":[2738487],"length":1,"stats":{"Line":2}}],"covered":48,"coverable":55},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej04.rs"],"content":"struct Triangulo {\n    lado1: f64,\n    lado2: f64,\n    lado3: f64,\n}\n\nimpl Triangulo {\n    fn new (lado1: f64, lado2: f64, lado3: f64) -\u003e Triangulo {\n        Triangulo { \n            lado1,\n            lado2,\n            lado3,\n        }\n    }\n\n    fn determinar_tipo (\u0026self) -\u003e String {\n        if self.lado1 == self.lado2 \u0026\u0026 self.lado2 == self.lado3 {\n            String::from(\"Equilateral\")\n        } else {\n            if (self.lado1 == self.lado2 \u0026\u0026 self.lado2 != self.lado3) || (self.lado1 == self.lado3 \u0026\u0026 self.lado3 != self.lado2) || (self.lado2 == self.lado3 \u0026\u0026 self.lado2 != self.lado1){\n                String::from(\"Isosceles\")\n            } else {\n                String::from(\"Scalene\")\n            }\n        }\n    }\n\n    fn calcular_area (\u0026self) -\u003e f64 {\n        let s = (self.lado1 + self.lado2 + self.lado3) / 2.0; // Semi-perimeter\n        let area = (s * (s - self.lado1) * (s - self.lado2) * (s - self.lado3)).sqrt(); // Heron's formula\n        area\n    }\n\n    fn calcular_perimetro (\u0026self) -\u003e f64 {\n        self.lado1 + self.lado2 + self.lado3\n    }\n}\n\n//#[should_panic]\n#[test]\nfn tester() {\n    let triangle = Triangulo::new(2.0, 2.0, 2.0);\n    assert_eq!(triangle.determinar_tipo(), String::from(\"Equilateral\"));\n    assert_eq!(triangle.calcular_perimetro(), 6.0);\n\n}","traces":[{"line":8,"address":[2843872],"length":1,"stats":{"Line":1}},{"line":16,"address":[2843920],"length":1,"stats":{"Line":1}},{"line":17,"address":[2843984,2843944],"length":1,"stats":{"Line":2}},{"line":18,"address":[2844003],"length":1,"stats":{"Line":1}},{"line":20,"address":[2844095,2844161,2843964,2844030],"length":1,"stats":{"Line":0}},{"line":21,"address":[2844071],"length":1,"stats":{"Line":0}},{"line":23,"address":[2844137],"length":1,"stats":{"Line":0}},{"line":28,"address":[2844192],"length":1,"stats":{"Line":0}},{"line":29,"address":[2844200],"length":1,"stats":{"Line":0}},{"line":30,"address":[2844232],"length":1,"stats":{"Line":0}},{"line":34,"address":[2844288],"length":1,"stats":{"Line":1}},{"line":35,"address":[2844293],"length":1,"stats":{"Line":1}}],"covered":6,"coverable":12},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej05.rs"],"content":"struct Producto {\n    nombre: String,\n    precio_bruto: f64,\n    id: u32,\n}\n\nimpl Producto {\n    fn new(nombre: String, precio_bruto: f64, id: u32) -\u003e Producto {\n        Producto {\n            nombre,\n            precio_bruto,\n            id,\n        }\n    }\n\n    fn calcular_impuestos(\u0026self, tax_percentage: f64) -\u003e f64 {\n        (tax_percentage/100.0)/self.precio_bruto\n    }\n\n    fn aplicar_descuento(\u0026self, discount_percentage: f64) -\u003e f64 {\n        (discount_percentage/100.0)/self.precio_bruto\n    }\n\n    fn calcular_precio_total(\u0026self, tax_percentage: Option\u003cf64\u003e, discount_percentage: Option\u003cf64\u003e) -\u003e f64 {\n        let tax = tax_percentage.map(|t| t/100.0).unwrap_or(0.0); \n        let discount= discount_percentage.map(|d| d/100.0).unwrap_or(0.0);\n        self.precio_bruto+tax-discount\n    }\n}\n\n#[cfg(test)]\nmod tests{\n    use super::*;\n\n    #[test]\n    fn test_calculate_taxes() {\n        let product= Producto::new(String::from(\"Agua.\"), 500.0, 123);\n        assert_eq!(product.calcular_impuestos(100.0), 0.002);\n    }\n\n    #[test]\n    fn test_apply_discount() {\n        let product= Producto::new(String::from(\"Agua.\"), 500.0, 123);\n        assert_eq!(product.aplicar_descuento(0.0), 0.0);\n    }\n\n    #[test]\n    fn test_total_price() {\n        let product= Producto::new(String::from(\"Agua.\"), 500.0, 123);\n        assert_eq!(product.calcular_precio_total(None, None), 500.0);\n        assert_eq!(product.calcular_precio_total(Some(500.0), Some(250.0)),502.5);\n    }\n\n}\n\n\n\n","traces":[{"line":8,"address":[3014656],"length":1,"stats":{"Line":3}},{"line":16,"address":[3014704],"length":1,"stats":{"Line":1}},{"line":17,"address":[3014715],"length":1,"stats":{"Line":1}},{"line":20,"address":[3014736],"length":1,"stats":{"Line":1}},{"line":21,"address":[3014747],"length":1,"stats":{"Line":1}},{"line":24,"address":[3014768],"length":1,"stats":{"Line":1}},{"line":25,"address":[3002448,3002454],"length":1,"stats":{"Line":3}},{"line":26,"address":[3002480,3002486],"length":1,"stats":{"Line":3}},{"line":27,"address":[3014906],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":9},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej07.rs"],"content":"#[derive(Clone)]\n\nenum Color {\n    ROJO,\n    VERDE, \n    AZUL,\n    AMARILLO,\n    BLANCO,\n    NEGRO,\n}\n#[derive(Clone)]\nstruct Auto {\n    color: Color,\n    marca: String,\n    modelo: String,\n    precio_bruto: f64,\n    año: u32,\n}\n\nstruct ConsecionarioAuto {\n    nombre: String,\n    direccion: String,\n    x: u32,\n    autos: Vec\u003cAuto\u003e,\n}\n\n\n\npub fn compare_colors(color1: \u0026Color, color2: \u0026Color) -\u003e bool {\n    match(color1, color2) {\n        (Color::AMARILLO, Color::AMARILLO) =\u003e true,\n        (Color::AZUL, Color::AZUL) =\u003e true,\n        (Color::VERDE, Color::VERDE) =\u003e true,\n        (Color::ROJO, Color::ROJO) =\u003e true,\n        (Color::NEGRO, Color::NEGRO) =\u003e true,\n        (Color::BLANCO, Color::BLANCO) =\u003e true,\n        _ =\u003e false, //If the variants are different, they are not equal\n    }\n}\n\npub fn compare (auto1: \u0026Auto, auto2: \u0026Auto) -\u003e bool {\n    auto1.año == auto2.año \u0026\u0026\n    auto1.marca == auto2.marca \u0026\u0026\n    auto1.modelo == auto2.modelo \u0026\u0026\n    auto1.precio_bruto == auto2.precio_bruto \u0026\u0026\n    compare_colors(\u0026auto1.color, \u0026auto2.color)\n\n}\n\nimpl ConsecionarioAuto {\n    fn new(nombre: String, direccion: String, x: u32) -\u003e ConsecionarioAuto {\n        ConsecionarioAuto {\n            nombre,\n            direccion,\n            x,\n            autos: Vec::new(),\n        }\n    }\n\n    fn agregar_auto(\u0026mut self, auto: \u0026Auto) -\u003e bool {\n        if self.autos.len()+1 \u003c= self.x.try_into().unwrap() {\n            self.autos.push(auto.clone());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    fn eliminar_auto(\u0026mut self, auto: \u0026Auto) {\n        //Find the car I want to delete in the vec.\n        let mut index_car_delete= -1;\n        for i in 0.. self.autos.len() {\n            if compare(\u0026self.autos[i], \u0026auto) {\n                index_car_delete= i as i32;\n                break;\n            }  \n        }\n        //Delete the car.\n        if index_car_delete != -1 { //If I found the car to delete.\n            self.autos.remove(index_car_delete as usize);\n        }\n    }\n\n    fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\n        for car in self.autos.iter() {\n            if compare(\u0026car, \u0026auto) {\n                return Some(car);\n            }\n        }\n        None //If I didn't find it, return nothing (None).\n    }\n}\n\nimpl Auto {\n    fn new(marca: String, modelo: String, precio_bruto: f64, año: u32, color: Color ) -\u003e Auto {\n        Auto {\n            marca,\n            modelo,\n            precio_bruto,\n            año,\n            color,\n        }\n    }\n\n    fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut precio_final= self.precio_bruto;\n\n        //Check first condition (color).\n        let es_primario = match self.color {\n            Color::AMARILLO | Color::AZUL | Color::ROJO =\u003e true,\n            _ =\u003e false,\n        };\n\n        if es_primario {\n            precio_final += (self.precio_bruto * 25.0)/100.0; //+25%.\n        } else {\n            precio_final -= (10.0*self.precio_bruto)/100.0; //-10%.\n        }\n\n        //Check second condition (brand).\n        if self.marca == \"BMW\" {\n            precio_final += (self.precio_bruto * 15.0)/100.0; //+15%.\n        }\n\n        //Check third condition (year).\n        if self.año \u003c 2000 {\n            precio_final -= (self.precio_bruto * 5.0)/100.0; //-5%.\n        }\n\n        precio_final\n    }\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_auto() {\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3);\n\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n        let auto4= Auto::new(String::from(\"Ferrari\"), String::from(\"modelo R\"), 1000.0, 2015, Color::ROJO);\n\n        concesionario.agregar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 1); //Added only 1 element.\n\n        //Fill all available space.\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.agregar_auto(\u0026auto3);\n        assert_eq!(concesionario.autos.len(), 3);\n\n        //Try to add one more.\n        assert_eq!(concesionario.agregar_auto(\u0026auto4), false);\n    }\n\n    #[test]\n    fn testear_eliminar_auto() {\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3);\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n\n        //First I try to delete a car from an empty list.\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //Passed. Nothing changed.\n\n        //Add cars to delete.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //yes.\n\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 1);\n    }\n    \n    #[test]\n    fn testear_buscar_auto() {\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3);\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n\n\n        //Try to find a car in an empty list.\n        assert!(concesionario.buscar_auto(\u0026auto1).is_none());\n\n        //Find a car that exists.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        assert!(concesionario.buscar_auto(\u0026auto2).is_some());\n\n        //Find a car that doesn't exist.\n        assert!(concesionario.buscar_auto(\u0026auto3).is_none());\n    }\n\n    #[test]\n    fn testear_calcular_precio() {\n        //Test brand (and not primary color).\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n        let auto2= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n\n        assert_eq!(auto1.calcular_precio(), 1050.0); \n        assert_eq!(auto2.calcular_precio(), 900.0);\n\n        //Test if primary color.\n        let auto3= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::AMARILLO);\n        assert_eq!(auto3.calcular_precio(), 1250.0);\n        \n        //Test year (withouth primary color).\n        let auto4= Auto::new(String::from(\"Cronos\"), String::from(\"modelo 1\"), 1000.0, 1999, Color::BLANCO);\n        assert_eq!(auto4.calcular_precio(), 850.0);\n    }\n\n}","traces":[{"line":29,"address":[3072966,3072912],"length":1,"stats":{"Line":1}},{"line":30,"address":[3072922,3072968],"length":1,"stats":{"Line":1}},{"line":41,"address":[3073120],"length":1,"stats":{"Line":1}},{"line":42,"address":[3073151,3073143],"length":1,"stats":{"Line":2}},{"line":43,"address":[3073167],"length":1,"stats":{"Line":1}},{"line":44,"address":[3073187],"length":1,"stats":{"Line":1}},{"line":45,"address":[3073215],"length":1,"stats":{"Line":1}},{"line":46,"address":[3073238],"length":1,"stats":{"Line":1}},{"line":51,"address":[3073494,3073280,3073516],"length":1,"stats":{"Line":1}},{"line":56,"address":[3073344],"length":1,"stats":{"Line":1}},{"line":60,"address":[3073536],"length":1,"stats":{"Line":1}},{"line":61,"address":[3073560],"length":1,"stats":{"Line":1}},{"line":62,"address":[3073659],"length":1,"stats":{"Line":1}},{"line":63,"address":[3073698],"length":1,"stats":{"Line":1}},{"line":65,"address":[3073642],"length":1,"stats":{"Line":1}},{"line":69,"address":[3073728],"length":1,"stats":{"Line":1}},{"line":71,"address":[3073753],"length":1,"stats":{"Line":1}},{"line":72,"address":[3073793,3073761],"length":1,"stats":{"Line":2}},{"line":73,"address":[3073848],"length":1,"stats":{"Line":1}},{"line":74,"address":[3073897],"length":1,"stats":{"Line":1}},{"line":79,"address":[3073883],"length":1,"stats":{"Line":1}},{"line":80,"address":[3073916],"length":1,"stats":{"Line":1}},{"line":84,"address":[3073968],"length":1,"stats":{"Line":1}},{"line":85,"address":[3073981,3074022],"length":1,"stats":{"Line":2}},{"line":86,"address":[3074075],"length":1,"stats":{"Line":1}},{"line":87,"address":[3074114],"length":1,"stats":{"Line":1}},{"line":90,"address":[3074095],"length":1,"stats":{"Line":1}},{"line":95,"address":[3074128],"length":1,"stats":{"Line":1}},{"line":105,"address":[3074208],"length":1,"stats":{"Line":1}},{"line":106,"address":[3074221],"length":1,"stats":{"Line":1}},{"line":109,"address":[3074232],"length":1,"stats":{"Line":1}},{"line":110,"address":[3074272],"length":1,"stats":{"Line":1}},{"line":111,"address":[3074265],"length":1,"stats":{"Line":1}},{"line":114,"address":[3074277,3074329],"length":1,"stats":{"Line":2}},{"line":115,"address":[3074335],"length":1,"stats":{"Line":1}},{"line":117,"address":[3074288],"length":1,"stats":{"Line":1}},{"line":121,"address":[3074448,3074376],"length":1,"stats":{"Line":2}},{"line":122,"address":[3074411],"length":1,"stats":{"Line":1}},{"line":126,"address":[3074506,3074396],"length":1,"stats":{"Line":2}},{"line":127,"address":[3074465],"length":1,"stats":{"Line":1}},{"line":130,"address":[3074450],"length":1,"stats":{"Line":1}}],"covered":41,"coverable":41},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej08.rs"],"content":"#[derive(Clone)]\nenum Genero {\n    ROCK,\n    POP,\n    JAZZ,\n    RAP,\n    OTROS,\n}\n\n#[derive(Clone)]\nstruct Cancion {\n    titulo: String,\n    artista: String,\n    genero: Genero,\n}\n\nstruct PlayList {\n    nombre: String,\n    canciones: Vec\u003cCancion\u003e,\n}\n\nimpl Cancion {\n    fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\n        Cancion {\n            titulo,\n            artista,\n            genero,\n        }\n    }\n}\n\npub fn compare_genre(genero1: \u0026Genero, genero2: \u0026Genero) -\u003e bool {\n    match (genero1, genero2) {\n        (Genero::JAZZ, Genero::JAZZ) =\u003e true,\n        (Genero::ROCK, Genero::ROCK) =\u003e true,\n        (Genero::RAP, Genero::RAP) =\u003e true,\n        (Genero::POP, Genero::POP) =\u003e true,\n        (Genero::OTROS, Genero::OTROS) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare (cancion1: \u0026Cancion, cancion2: \u0026Cancion) -\u003e bool {\n    cancion1.artista == cancion2.artista \u0026\u0026\n    cancion1.titulo == cancion2.titulo \u0026\u0026\n    compare_genre(\u0026cancion1.genero, \u0026cancion2.genero)\n\n}\n\nimpl PlayList {\n    fn new(nombre: String) -\u003e PlayList {\n        PlayList {\n            nombre,\n            canciones: Vec::new(),\n        }\n    }\n\n    fn agregar_cancion(\u0026mut self, cancion: \u0026Cancion) {\n        self.canciones.push(cancion.clone());\n    }\n\n    fn eliminar_cancion(\u0026mut self, cancion: \u0026Cancion) {\n        //Find the song I want to delete in the vec.\n        let mut index_song_delete= -1;\n        for i in 0.. self.canciones.len() {\n            if compare(\u0026self.canciones[i], \u0026cancion) {\n                index_song_delete= i as i32;\n                break;\n            }  \n        }\n        //Delete the car.\n        if index_song_delete != -1 { //If I found the car to delete.\n            self.canciones.remove(index_song_delete as usize);\n        }\n    }\n\n    fn mover_cancion(\u0026mut self, cancion: \u0026Cancion, posicion_nueva: u32){\n        if posicion_nueva \u003c self.canciones.len() as u32 {\n\n            //Search song in the playlist.\n            let mut song_index:i32= -1;\n            for i in 0..self.canciones.len() {\n                if compare(\u0026self.canciones[i], \u0026cancion) {\n                    song_index= i as i32;\n                    break;\n                }\n            }\n\n            if song_index != -1 { //If I found the song.\n                //Move the song to the new position.\n                let song = self.canciones.remove(song_index as usize);\n                self.canciones.insert(posicion_nueva as usize, song);\n            }\n        }\n    }\n\n    fn buscar_cancion_por_nombre(\u0026self, nombre: String) -\u003e Option\u003cCancion\u003e {\n        for song in self.canciones.iter() {\n            if (song.titulo == nombre) {\n                return Some(song.clone());\n            }\n        }\n        None\n    }\n\n    fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_genero= Vec::new();\n\n        for song in self.canciones.iter() {\n            if compare_genre(\u0026song.genero, \u0026genero) {\n                canciones_genero.push(song.clone());\n            }\n        }\n        canciones_genero\n    }\n\n    fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_artista= Vec::new();\n\n        for song in self.canciones.iter() {\n            if song.artista == artista {\n                canciones_artista.push(song.clone());\n            }\n        }\n\n        canciones_artista\n    }\n\n    fn modificar_titulo_playlist(\u0026mut self, titulo_nuevo: String) {\n        self.nombre= titulo_nuevo;\n    }\n\n    fn eliminar_todas_las_canciones(\u0026mut self) {\n        self.canciones.clear();\n    }\n }\n\n\n #[cfg(test)]\n\n mod test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        assert_eq!(playlist.canciones.len(), 3);\n    }\n\n    #[test]\n    fn testear_eliminar_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        \n        playlist.eliminar_cancion(\u0026cancion1); //Delete just 1 song.\n        assert_eq!(playlist.canciones.len(), 1);\n\n        //Try to delete a song that is not in the playlist.\n        playlist.eliminar_cancion(\u0026cancion3);\n        assert_eq!(playlist.canciones.len(), 1); //lenght shouldn't change.\n    }\n\n    #[test]\n    fn testear_buscar_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n\n        playlist.agregar_cancion(\u0026cancion1);\n\n        //Search for a song that is in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion1\")).is_some());\n\n        //Search for a song that is not in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion10\")).is_none());\n    }\n\n    #[test]\n    fn testear_eliminar_canciones() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        playlist.eliminar_todas_las_canciones();\n        assert_eq!(playlist.canciones.len(), 0);\n    }\n\n    #[test]\n    fn testear_mover_cancion() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); //Originally in pos 0 (in playlist).\n        playlist.agregar_cancion(\u0026cancion2); //Originally in pos 1 (in playlist).\n        playlist.agregar_cancion(\u0026cancion3); //Originally in pos 2 (in playlist).\n\n        //Check that.\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\"));\n\n        //Move a song that is in the playlist.\n        playlist.mover_cancion(\u0026cancion2, 2);\n        assert_eq!(playlist.canciones[2].titulo, String::from(\"Cancion2\"));\n\n        //Move a song that is not in the playlist.\n        playlist.mover_cancion(\u0026cancion4, 0);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n\n        //Move a song that is in the playlist to a non existing position.\n        playlist.mover_cancion(\u0026cancion1, 3);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n    }\n\n    #[test]\n    fn testear_cambiar_nombre_playlist() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        //Check that.\n        assert_eq!(playlist.nombre, String::from(\"Chill music\"));\n        \n        //Change the name.\n        playlist.modificar_titulo_playlist(String::from(\"Nombre nuevo\"));\n        assert_eq!(playlist.nombre, String::from(\"Nombre nuevo\"));\n    }\n\n    #[test]\n    fn testear_canciones_mismo_genero() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 jazz songs.\n        let mut jazz_songs: Vec\u003cCancion\u003e;\n        jazz_songs= playlist.obtener_canciones_por_genero(Genero::JAZZ);\n        assert_eq!(jazz_songs.len(), 2);\n\n        //Try with a genre that is not in the playlist.\n        let mut pop_songs= playlist.obtener_canciones_por_genero(Genero::POP);\n        assert_eq!(pop_songs.len(), 0);\n    }\n\n    #[test]\n    fn testear_canciones_mismo_artista() {\n        let mut playlist= PlayList::new(String::from(\"Chill music\"));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 pepa songs.\n        let mut pepa_songs: Vec\u003cCancion\u003e;\n        pepa_songs= playlist.obtener_canciones_por_artista(String::from(\"pepa\"));\n        assert_eq!(pepa_songs.len(), 2);\n\n        //Try with an artist that is not in the playlist.\n        let mut titi_songs= playlist.obtener_canciones_por_artista(String::from(\"titi\"));\n        assert_eq!(titi_songs.len(), 0);\n    }\n }","traces":[{"line":23,"address":[2866368],"length":1,"stats":{"Line":2}},{"line":32,"address":[2866432,2866486],"length":1,"stats":{"Line":1}},{"line":33,"address":[2866442,2866488],"length":1,"stats":{"Line":2}},{"line":43,"address":[2866608],"length":1,"stats":{"Line":1}},{"line":44,"address":[2866631,2866648],"length":1,"stats":{"Line":2}},{"line":45,"address":[2866664],"length":1,"stats":{"Line":1}},{"line":46,"address":[2866684],"length":1,"stats":{"Line":1}},{"line":51,"address":[2866720,2866861],"length":1,"stats":{"Line":1}},{"line":54,"address":[2866755],"length":1,"stats":{"Line":1}},{"line":58,"address":[2866880],"length":1,"stats":{"Line":2}},{"line":59,"address":[2866894],"length":1,"stats":{"Line":3}},{"line":62,"address":[2866944],"length":1,"stats":{"Line":1}},{"line":64,"address":[2866966],"length":1,"stats":{"Line":1}},{"line":65,"address":[2867006,2866974],"length":1,"stats":{"Line":2}},{"line":66,"address":[2867060],"length":1,"stats":{"Line":1}},{"line":67,"address":[2867108],"length":1,"stats":{"Line":1}},{"line":72,"address":[2867095],"length":1,"stats":{"Line":1}},{"line":73,"address":[2867127],"length":1,"stats":{"Line":1}},{"line":77,"address":[2867168],"length":1,"stats":{"Line":1}},{"line":78,"address":[2867204],"length":1,"stats":{"Line":1}},{"line":81,"address":[2867234],"length":1,"stats":{"Line":1}},{"line":82,"address":[2867274,2867242],"length":1,"stats":{"Line":2}},{"line":83,"address":[2867328],"length":1,"stats":{"Line":1}},{"line":84,"address":[2867380],"length":1,"stats":{"Line":1}},{"line":89,"address":[2867363],"length":1,"stats":{"Line":1}},{"line":91,"address":[2867391],"length":1,"stats":{"Line":1}},{"line":92,"address":[2867426],"length":1,"stats":{"Line":1}},{"line":97,"address":[2867456,2867833],"length":1,"stats":{"Line":1}},{"line":98,"address":[2867499,2867571],"length":1,"stats":{"Line":2}},{"line":99,"address":[2867769,2867712],"length":1,"stats":{"Line":2}},{"line":100,"address":[2867790],"length":1,"stats":{"Line":1}},{"line":103,"address":[2867733],"length":1,"stats":{"Line":1}},{"line":106,"address":[2868268,2867856,2868262],"length":1,"stats":{"Line":1}},{"line":107,"address":[2867897],"length":1,"stats":{"Line":1}},{"line":109,"address":[2867907,2867975],"length":1,"stats":{"Line":2}},{"line":110,"address":[2868130,2868201],"length":1,"stats":{"Line":2}},{"line":111,"address":[2868223],"length":1,"stats":{"Line":1}},{"line":114,"address":[2868160],"length":1,"stats":{"Line":1}},{"line":117,"address":[2868744,2868288],"length":1,"stats":{"Line":1}},{"line":118,"address":[2868328],"length":1,"stats":{"Line":1}},{"line":120,"address":[2868381,2868446],"length":1,"stats":{"Line":2}},{"line":121,"address":[2868683,2868606],"length":1,"stats":{"Line":2}},{"line":122,"address":[2868705],"length":1,"stats":{"Line":1}},{"line":126,"address":[2868631],"length":1,"stats":{"Line":1}},{"line":129,"address":[2868768,2868828],"length":1,"stats":{"Line":1}},{"line":130,"address":[2868863,2868786],"length":1,"stats":{"Line":2}},{"line":133,"address":[2868896],"length":1,"stats":{"Line":1}},{"line":134,"address":[2868901],"length":1,"stats":{"Line":1}}],"covered":48,"coverable":48},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej09.rs"],"content":"use std::collections::VecDeque;\nuse crate::tp03::ej03::Fecha;\n\n\n\n#[derive(Clone)]\nenum TipoAnimal {\n    PERRO,\n    GATO,\n    CABALLO,\n    OTROS,\n}\n\nstruct Veterinaria {\n    nombre: String,\n    direccion: String,\n    id: i32,\n    atenciones: VecDeque\u003cAtencion\u003e,\n    atenciones_realizadas: Vec\u003cAtencion\u003e,\n}\n\n#[derive(Clone)]\nstruct Atencion {\n    mascota: Mascota,\n    diagnostico_final: String,\n    tratamiento: String,\n    fecha: Option\u003cFecha\u003e,\n}\n\n#[derive(Clone)]\nstruct Mascota {\n    nombre: String,\n    edad: String,\n    tipo: TipoAnimal,\n    dueño: Dueño,\n}\n\n#[derive(Clone)]\nstruct Dueño {\n    nombre: String,\n    direccion: String,\n    telefono: u32,\n}\n\npub fn compare_owners(owner1: \u0026Dueño, owner2: \u0026Dueño) -\u003e bool {\n    owner1.direccion == owner2.direccion \u0026\u0026\n    owner1.nombre == owner2.nombre \u0026\u0026\n    owner1.telefono == owner2.telefono\n}\n\npub fn compare_type(type1: \u0026TipoAnimal, type2: \u0026TipoAnimal)  -\u003e bool{\n    match (type1, type2) {\n        (TipoAnimal::CABALLO, TipoAnimal::CABALLO) =\u003e true,\n        (TipoAnimal::PERRO, TipoAnimal::PERRO) =\u003e true,\n        (TipoAnimal::GATO, TipoAnimal::GATO) =\u003e true,\n        (TipoAnimal::OTROS, TipoAnimal::OTROS) =\u003e true,\n        _ =\u003e false, \n    }\n}\n\npub fn compare_pets (mascota1: \u0026Mascota, mascota2: \u0026Mascota) -\u003e bool {\n    compare_owners(\u0026mascota1.dueño, \u0026mascota2.dueño) \u0026\u0026\n    mascota1.edad == mascota2.edad \u0026\u0026\n    mascota1.nombre == mascota2.nombre \u0026\u0026\n    compare_type(\u0026mascota1.tipo, \u0026mascota2.tipo)\n}\n\nfn compare_fecha(fecha1: \u0026Option\u003cFecha\u003e, fecha2: \u0026Option\u003cFecha\u003e) -\u003e bool {\n    match (fecha1, fecha2) {\n        (Some(f1), Some(f2)) =\u003e f1.dia == f2.dia \u0026\u0026 f1.mes == f2.mes \u0026\u0026 f1.año == f2.año,\n        (None, None) =\u003e true, // Ambas son None → consideradas iguales\n        _ =\u003e false,           // Una tiene valor y la otra no → distintas\n    }\n}\n\n\n\npub fn compare_atencion(atencion1: \u0026Atencion, atencion2: \u0026Atencion) -\u003e bool {\n    atencion1.diagnostico_final == atencion2.diagnostico_final \u0026\u0026\n    compare_fecha(\u0026atencion1.fecha, \u0026atencion2.fecha) \u0026\u0026\n    atencion1.tratamiento == atencion2.tratamiento \u0026\u0026\n    compare_pets(\u0026atencion1.mascota, \u0026atencion2.mascota)\n}\n\nimpl Veterinaria {\n    fn new(nombre: String, direccion: String, id: i32) -\u003e Veterinaria {\n        Veterinaria {\n            nombre,\n            direccion,\n            id,\n            atenciones: VecDeque::new(),\n            atenciones_realizadas: Vec::new(),\n        }\n    }\n\n    fn agregar_nueva_mascota(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion = Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_back(nueva_atencion);\n    }\n\n    fn agregar_mascota_maxima_prioridad(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion= Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_front(nueva_atencion);\n    }\n\n    fn atender_mascota(\u0026mut self) -\u003e Option\u003cMascota\u003e{\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            return Some(mascota_atendida.mascota);\n        } \n        None\n    }\n\n    fn eliminar_mascota(\u0026mut self, mascota: Mascota) {\n        //Find pet.\n        let mut indice_mascota_retirada:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_pets(\u0026self.atenciones[i].mascota,\u0026 mascota) {\n                indice_mascota_retirada= i as i32;\n                break;\n            }\n        }\n        //Delete pet.\n        if indice_mascota_retirada != -1 { //If I found the pet.\n            self.atenciones.remove(indice_mascota_retirada as usize);\n        }\n    }\n\n    fn registrar_atencion(\u0026mut self, tratamiento: String, diagnostico: String, fecha: Option\u003cFecha\u003e) {\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            let atencion_hecha= Atencion {\n                mascota: mascota_atendida.mascota,\n                diagnostico_final: diagnostico,\n                tratamiento: tratamiento,\n                fecha,\n            };\n\n            self.atenciones_realizadas.push(atencion_hecha);\n        };\n    }\n\n    fn buscar_atencion(\u0026self, nombre_mascota: String, nombre_dueño: String, telefono: u32) -\u003e Option\u003cAtencion\u003e {\n        for atencion in self.atenciones.iter() {\n            if atencion.mascota.nombre == nombre_mascota \u0026\u0026 atencion.mascota.dueño.nombre == nombre_dueño \u0026\u0026 atencion.mascota.dueño.telefono == telefono {\n                return Some(atencion.clone());\n            }\n        }\n        None\n    }\n\n    fn modificar_diagnostico(\u0026mut self, diagnostico_nuevo: String, atencion: \u0026Atencion) {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n        //Modify diagnostic.\n        if indice_atencion!= -1 { //If I found the attention.\n            self.atenciones[indice_atencion as usize].diagnostico_final = diagnostico_nuevo;\n        }\n    }\n\n    fn modificar_fecha(\u0026mut self, fecha_nueva: Option\u003cFecha\u003e, atencion: \u0026Atencion) {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 { \n            self.atenciones[indice_atencion as usize].fecha = fecha_nueva;\n        }\n    }\n\n    fn eliminar_atencion (\u0026mut self, atencion: \u0026Atencion) {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 {\n            self.atenciones.remove(indice_atencion as usize);\n        }\n    }\n}\n\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tp03::ej03::Fecha;\n\n    fn crear_dueño() -\u003e Dueño {\n        Dueño {\n            nombre: String::from(\"Juan Perez\"),\n            direccion: String::from(\"Calle Falsa 123\"),\n            telefono: 12345678,\n        }\n    }\n\n    fn crear_mascota(nombre: \u0026str, tipo: TipoAnimal) -\u003e Mascota {\n        Mascota {\n            nombre: String::from(nombre),\n            edad: String::from(\"5\"),\n            tipo,\n            dueño: crear_dueño(),\n        }\n    }\n\n    fn crear_fecha() -\u003e Option\u003cFecha\u003e {\n        Some(Fecha { dia: 1, mes: 1, año: 2024 })\n    }\n\n    #[test]\n    fn test_agregar_nueva_mascota() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 1\"), String::from(\"Arg\"), 1);\n        let mascota = crear_mascota(\"Firulais\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        assert_eq!(vet.atenciones.len(), 1);\n    }\n\n    #[test]\n    fn test_agregar_mascota_maxima_prioridad() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 2\"), String::from(\"Arg \"), 2);\n        let m1 = crear_mascota(\"Gato\", TipoAnimal::GATO);\n        let m2 = crear_mascota(\"Caballo\", TipoAnimal::CABALLO);\n\n        vet.agregar_nueva_mascota(m1.clone(), crear_fecha());\n        vet.agregar_mascota_maxima_prioridad(m2.clone(), crear_fecha());\n\n        assert_eq!(vet.atenciones.front().unwrap().mascota.nombre, \"Caballo\");\n    }\n\n    #[test]\n    fn test_atender_mascota() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 3\"), String::from(\"Arg\"), 3);\n        let mascota = crear_mascota(\"Toby\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        let atendido = vet.atender_mascota();\n\n        assert!(atendido.is_some());\n        assert_eq!(atendido.unwrap().nombre, \"Toby\");\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_registrar_atencion() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 4\"), String::from(\"Arg\"), 4);\n        let mascota = crear_mascota(\"Rex\", TipoAnimal::PERRO);\n        let fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        vet.registrar_atencion(String::from(\"Antibióticos\"), String::from(\"Infección\"), fecha.clone());\n\n        assert_eq!(vet.atenciones.len(), 0);\n        assert_eq!(vet.atenciones_realizadas.len(), 1);\n        let atendida = \u0026vet.atenciones_realizadas[0];\n        assert_eq!(atendida.mascota.nombre, \"Rex\");\n        assert_eq!(atendida.tratamiento, \"Antibióticos\");\n        assert_eq!(atendida.diagnostico_final, \"Infección\");\n        assert!(compare_fecha(\u0026atendida.fecha, \u0026fecha));\n    }\n\n    #[test]\n    fn test_eliminar_mascota() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 5\"), String::from(\"Zoológico\"), 5);\n        let mascota = crear_mascota(\"Milo\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        assert_eq!(vet.atenciones.len(), 1);\n\n        vet.eliminar_mascota(mascota);\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_buscar_atencion() {\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6);\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        let resultado = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert!(resultado.is_some());\n        assert_eq!(resultado.unwrap().mascota.nombre, \"Rocky\");\n    }\n}\n\n\n","traces":[{"line":45,"address":[3080000],"length":1,"stats":{"Line":1}},{"line":46,"address":[3080023,3080040],"length":1,"stats":{"Line":1}},{"line":47,"address":[3080056],"length":1,"stats":{"Line":1}},{"line":48,"address":[3080076],"length":1,"stats":{"Line":1}},{"line":51,"address":[3080112,3080166],"length":1,"stats":{"Line":1}},{"line":52,"address":[3080168,3080122],"length":1,"stats":{"Line":1}},{"line":61,"address":[3080272],"length":1,"stats":{"Line":1}},{"line":62,"address":[3080295,3080312],"length":1,"stats":{"Line":1}},{"line":63,"address":[3080328],"length":1,"stats":{"Line":1}},{"line":64,"address":[3080356],"length":1,"stats":{"Line":1}},{"line":65,"address":[3080376],"length":1,"stats":{"Line":1}},{"line":68,"address":[3080416],"length":1,"stats":{"Line":1}},{"line":69,"address":[3080426],"length":1,"stats":{"Line":1}},{"line":70,"address":[3080495,3080556],"length":1,"stats":{"Line":1}},{"line":72,"address":[3080549],"length":1,"stats":{"Line":0}},{"line":78,"address":[3080608],"length":1,"stats":{"Line":0}},{"line":79,"address":[3080648,3080631],"length":1,"stats":{"Line":0}},{"line":80,"address":[3080664],"length":1,"stats":{"Line":0}},{"line":81,"address":[3080698],"length":1,"stats":{"Line":0}},{"line":82,"address":[3080732],"length":1,"stats":{"Line":0}},{"line":86,"address":[3080768,3081076,3081098],"length":1,"stats":{"Line":3}},{"line":91,"address":[3080835],"length":1,"stats":{"Line":3}},{"line":92,"address":[3080888],"length":1,"stats":{"Line":3}},{"line":96,"address":[3081120,3081518],"length":1,"stats":{"Line":4}},{"line":99,"address":[3081235],"length":1,"stats":{"Line":5}},{"line":100,"address":[3081290],"length":1,"stats":{"Line":5}},{"line":104,"address":[3081489],"length":1,"stats":{"Line":6}},{"line":107,"address":[3081950,3081552],"length":1,"stats":{"Line":1}},{"line":110,"address":[3081667],"length":1,"stats":{"Line":1}},{"line":111,"address":[3081722],"length":1,"stats":{"Line":1}},{"line":115,"address":[3081921],"length":1,"stats":{"Line":1}},{"line":118,"address":[3082409,3081984,3082415],"length":1,"stats":{"Line":1}},{"line":119,"address":[3082008],"length":1,"stats":{"Line":1}},{"line":120,"address":[3082091],"length":1,"stats":{"Line":1}},{"line":122,"address":[3082319],"length":1,"stats":{"Line":0}},{"line":125,"address":[3082781,3082432],"length":1,"stats":{"Line":1}},{"line":127,"address":[3082457],"length":1,"stats":{"Line":1}},{"line":128,"address":[3082523,3082465],"length":1,"stats":{"Line":2}},{"line":129,"address":[3082690,3082648],"length":1,"stats":{"Line":2}},{"line":130,"address":[3082719],"length":1,"stats":{"Line":1}},{"line":135,"address":[3082671],"length":1,"stats":{"Line":1}},{"line":136,"address":[3082748],"length":1,"stats":{"Line":1}},{"line":140,"address":[3083674,3082800,3083547],"length":1,"stats":{"Line":1}},{"line":141,"address":[3082929,3082840],"length":1,"stats":{"Line":2}},{"line":143,"address":[3083013],"length":1,"stats":{"Line":1}},{"line":149,"address":[3083374],"length":1,"stats":{"Line":1}},{"line":153,"address":[3084234,3083712],"length":1,"stats":{"Line":1}},{"line":154,"address":[3083760,3083827],"length":1,"stats":{"Line":2}},{"line":155,"address":[3083976,3084090],"length":1,"stats":{"Line":2}},{"line":156,"address":[3084168],"length":1,"stats":{"Line":1}},{"line":159,"address":[3084007],"length":1,"stats":{"Line":0}},{"line":162,"address":[3084935,3084256],"length":1,"stats":{"Line":0}},{"line":164,"address":[3084286],"length":1,"stats":{"Line":0}},{"line":165,"address":[3084318,3084380],"length":1,"stats":{"Line":0}},{"line":166,"address":[3084517,3084554],"length":1,"stats":{"Line":0}},{"line":167,"address":[3084588],"length":1,"stats":{"Line":0}},{"line":172,"address":[3084540,3084887],"length":1,"stats":{"Line":0}},{"line":173,"address":[3084913,3084623],"length":1,"stats":{"Line":0}},{"line":177,"address":[3084976],"length":1,"stats":{"Line":0}},{"line":179,"address":[3085000],"length":1,"stats":{"Line":0}},{"line":180,"address":[3085008],"length":1,"stats":{"Line":0}},{"line":181,"address":[3085091],"length":1,"stats":{"Line":0}},{"line":182,"address":[3085139],"length":1,"stats":{"Line":0}},{"line":187,"address":[3085202,3085126],"length":1,"stats":{"Line":0}},{"line":188,"address":[3085155],"length":1,"stats":{"Line":0}},{"line":192,"address":[3085216],"length":1,"stats":{"Line":0}},{"line":194,"address":[3085241],"length":1,"stats":{"Line":0}},{"line":195,"address":[3085249,3085281],"length":1,"stats":{"Line":0}},{"line":196,"address":[3085336],"length":1,"stats":{"Line":0}},{"line":197,"address":[3085385],"length":1,"stats":{"Line":0}},{"line":202,"address":[3085371],"length":1,"stats":{"Line":0}},{"line":203,"address":[3085404],"length":1,"stats":{"Line":0}}],"covered":43,"coverable":72},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","ej10.rs"],"content":"use std::collections::HashMap;\nuse crate::tp03::ej03::Fecha;\n\n#[derive(Clone)]\nenum Genero {\n    Novela,\n    Infantil,\n    Tecnico,\n    Otros\n}\n\n#[derive(Clone)]\nenum EstadoPrestamo {\n    Devuelto,\n    EnPrestamo,\n}\n\n#[derive(Clone)]\nstruct Biblioteca {\n    nombre: String,\n    direccion: String,\n    libros: HashMap\u003cu32, Libro\u003e, //Key: ISBN.\n    prestamos: Vec\u003cPrestamo\u003e,\n}\n\n#[derive(Clone)]\nstruct Libro {\n    isbn: u32,\n    titulo: String,\n    copias_disponiles: u32,\n    autor: String,\n    numero_paginas: u32,\n    genero: Genero,\n}\n\n#[derive(Clone)]\nstruct Prestamo {\n    isbn_libro: u32,\n    cliente: Cliente,\n    fecha_vencimiento: Fecha,\n    fecha_devolucion: Fecha, \n    estado: EstadoPrestamo,\n}\n\n#[derive(Clone)]\nstruct Cliente {\n    nombre: String,\n    telefono: u32,\n    correo: String,\n}\n\npub fn no_devolvio (estado: \u0026EstadoPrestamo) -\u003e bool {\n    match estado {\n        (EstadoPrestamo::EnPrestamo) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare_clientes (cliente1: \u0026Cliente, cliente2: \u0026Cliente) -\u003e bool {\n    cliente1.nombre == cliente2.nombre \u0026\u0026\n    cliente1.correo == cliente2.correo \u0026\u0026\n    cliente1.telefono == cliente2.telefono\n}\n\nimpl Biblioteca {\n    fn obtener_cantidad_copias (\u0026self, libro: \u0026Libro) -\u003e u32 {\n        if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            return book.copias_disponiles;\n        } else {\n            return 0;\n        } \n    }\n\n    fn decrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) {\n        if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n            book.copias_disponiles -= 1;\n        }\n    }\n\n    fn incrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) {\n        if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n            book.copias_disponiles += 1;            \n        }\n    }\n\n    fn contar_prestamos_cliente (\u0026self, cliente: \u0026Cliente) -\u003e u32 {\n        let mut cant_prestamos= 0;\n\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) {\n                cant_prestamos += 1;\n            }\n        }\n        cant_prestamos\n    }\n\n    fn realizar_prestamo (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e bool {\n        //Check if the book exists and has available copies.\n        let okay_prestamo = if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            book.copias_disponiles \u003e= 1\n        } else {\n            false\n        };\n\n        //Check if the client has fewer than 5 loans.\n        if okay_prestamo \u0026\u0026 self.contar_prestamos_cliente(cliente) \u003c 5 {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles -= 1;\n                return true;\n            }\n        }\n        false\n    }\n\n\n    fn prestamos_vencer(\u0026self, cant_dias: u32, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut fecha_limite = fecha_actual.clone();\n        fecha_limite.sumar_dias(cant_dias);\n\n        let mut lista_prestamos_vencer = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            let fecha_igual = prestamo.fecha_vencimiento.dia == fecha_actual.dia \u0026\u0026\n                          prestamo.fecha_vencimiento.mes == fecha_actual.mes \u0026\u0026\n                          prestamo.fecha_vencimiento.año == fecha_actual.año;\n\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_limite) \u0026\u0026  // fecha_vencimiento \u003c= fecha_limite\n            (prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual) || fecha_igual)  // fecha_vencimiento \u003e= fecha_actual\n            {\n                lista_prestamos_vencer.push(prestamo.clone());\n            }\n        }\n         lista_prestamos_vencer    \n    }\n\n    fn prestamos_vencidos(\u0026self, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut lista_prestamos_vencidos = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual)\n            {\n                lista_prestamos_vencidos.push(prestamo.clone());\n            }\n        }\n        lista_prestamos_vencidos \n    }\n\n    fn buscar_prestamo (\u0026self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Option\u003cPrestamo\u003e {\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                return Some(prestamo.clone());\n            }\n        }\n        None\n    }\n\n    fn devolver_libro (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) {\n        for prestamo in self.prestamos.iter_mut() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                prestamo.estado= EstadoPrestamo::Devuelto;\n                if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                    book.copias_disponiles += 1;                    \n                }\n                break;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_obtener_cant_copias_libro() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n    \n        //Insertar libro.\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        let copias = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias, 7);\n    \n        //Libro no existente debe devolver 0\n        let libro_inexistente = Libro {\n            isbn: 999,\n            titulo: \"No existe\".to_string(),\n            copias_disponiles: 0,\n            autor: \"\".to_string(),\n            numero_paginas: 0,\n            genero: Genero::Otros,\n        };\n        let copias_inexistente = biblioteca.obtener_cantidad_copias(\u0026libro_inexistente);\n        assert_eq!(copias_inexistente, 0);\n    }\n\n    #[test]\n    fn test_decrementar_copias() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.decrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 6);\n        \n    }\n\n    #[test]\n    fn test_incrementar_copias() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.incrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 8);\n        \n    }\n\n    #[test]\n    fn test_contar_prestamos_cliente() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n        let prestamo2 = Prestamo {\n            isbn_libro: libro2.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n    \n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1, prestamo2],\n        };\n    \n        let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\n        assert_eq!(cantidad, 2);\n    }\n\n    #[test]\n    fn test_realizar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            correo: \"juan@mail.com\".to_string(),\n        };\n    \n        let libro = Libro {\n            isbn: 101,\n            titulo: \"Libro Test\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor Test\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Test\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n        };\n    \n        biblioteca.libros.insert(libro.isbn, libro.clone());\n    \n        // Cliente sin préstamos previos, debería poder tomar prestado\n        let exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(exito);\n    \n        // Copias deberían reducirse en 1\n        let copias_restantes = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_restantes, libro.copias_disponiles - 1);\n    \n        // Simulamos que el cliente ya tiene 5 préstamos\n        for _ in 0..5 {\n            biblioteca.prestamos.push(Prestamo {\n                isbn_libro: 999, // libro cualquiera\n                cliente: cliente.clone(),\n                fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n                fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n                estado: EstadoPrestamo::EnPrestamo,\n            });\n        }\n    \n        // Ahora no debería permitir más préstamos\n        let no_exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(!no_exito);\n    \n        // Copias no deberían cambiar porque no se hizo el préstamo\n        let copias_final = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_final, libro.copias_disponiles - 1);\n    }\n\n    #[test]\n    fn test_prestamos_a_vencer () {\n        let fecha_actual = Fecha { dia: 10, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n            nombre: \"Luis\".to_string(),\n            telefono: 5551234,\n            correo: \"luis@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"Libro de prueba\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n\n         // Préstamo que vence dentro de 5 días (día 14)\n        let prestamo_proximo = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 14, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo que vence después de 10 días (día 22)\n        let prestamo_lejano = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 22, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo ya devuelto, no debería aparecer\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 12, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 11, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo_proximo.clone(), prestamo_lejano, prestamo_devuelto],\n        };\n\n        let prestamos_vencer = biblioteca.prestamos_vencer(5, \u0026fecha_actual);\n\n        // Sólo debería contener el préstamo que vence dentro de 5 días y está activo\n        assert_eq!(prestamos_vencer.len(), 1);\n\n    }\n\n    #[test]\n    fn test_prestamos_vencidos() {\n        let fecha_actual = Fecha { dia: 15, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n          nombre: \"Carlos\".to_string(),\n          telefono: 123456,\n          correo: \"carlos@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 1,\n            titulo: \"Libro X\".to_string(),\n            copias_disponiles: 1,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n\n        let prestamo_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_no_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 20, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 5, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 6, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblio Test\".to_string(),\n            direccion: \"Dirección\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![\n                prestamo_vencido.clone(),\n                prestamo_no_vencido,\n                prestamo_devuelto,\n            ],\n        };\n\n        let vencidos = biblioteca.prestamos_vencidos(\u0026fecha_actual);\n\n        assert_eq!(vencidos.len(), 1);\n    }\n\n    #[test]\n    fn test_buscar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1],\n        };\n    \n        assert!(biblioteca.buscar_prestamo(\u0026libro1, \u0026cliente).is_some());\n\n        //Busco uno que no exista;\n        assert!(biblioteca.buscar_prestamo(\u0026libro2, \u0026cliente).is_none())\n    }\n\n    #[test]\n    fn test_devolver_libro() {\n        let cliente = Cliente {\n            nombre: \"Roberto\".to_string(),\n            telefono: 555123789,\n            correo: \"roberto@mail.com\".to_string(),\n        };\n    \n        \n        let mut libro = Libro {\n            isbn: 42,\n            titulo: \"pepe\".to_string(),\n            copias_disponiles: 5,  // Inicialmente hay 5 copias\n            autor: \"Autor\".to_string(),\n            numero_paginas: 300,\n            genero: Genero::Novela,\n        };\n    \n        \n        let prestamo = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 15, mes: 6, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },  // Aún no devuelto\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n        \n        let mut biblioteca = Biblioteca {\n            nombre: \"biblioteca\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo],\n        };\n\n        biblioteca.libros.insert(libro.isbn.clone(), libro.clone());\n        biblioteca.devolver_libro(\u0026libro, \u0026cliente);//Lo devuelvo.\n        let libro_devuelto = biblioteca.buscar_prestamo(\u0026libro, \u0026cliente);\n        let esta_devuelto = {\n            match libro_devuelto.unwrap().estado {\n                (EstadoPrestamo::Devuelto) =\u003e true,\n                _ =\u003e false,\n                \n            }\n        };\n\n        //println!(\"{}\", biblioteca.libros.len());\n        let updated_book = biblioteca.libros.get(\u0026libro.isbn.clone());\n        libro = updated_book.unwrap().clone();\n        assert_eq!(libro.copias_disponiles, 6); //Ok.\n\n        \n    }\n}","traces":[{"line":52,"address":[3152752],"length":1,"stats":{"Line":1}},{"line":53,"address":[3152757],"length":1,"stats":{"Line":1}},{"line":59,"address":[3152784],"length":1,"stats":{"Line":1}},{"line":60,"address":[3152816,3152807],"length":1,"stats":{"Line":1}},{"line":61,"address":[3152832],"length":1,"stats":{"Line":1}},{"line":62,"address":[3152860],"length":1,"stats":{"Line":1}},{"line":66,"address":[3152896],"length":1,"stats":{"Line":1}},{"line":67,"address":[3152910],"length":1,"stats":{"Line":2}},{"line":68,"address":[3152966],"length":1,"stats":{"Line":2}},{"line":70,"address":[3152975],"length":1,"stats":{"Line":1}},{"line":74,"address":[3152992],"length":1,"stats":{"Line":1}},{"line":75,"address":[3153006,3153103],"length":1,"stats":{"Line":2}},{"line":76,"address":[3153100,3153105,3153067],"length":1,"stats":{"Line":2}},{"line":80,"address":[3153120],"length":1,"stats":{"Line":1}},{"line":81,"address":[3153229,3153134],"length":1,"stats":{"Line":2}},{"line":82,"address":[3153231,3153226,3153195],"length":1,"stats":{"Line":2}},{"line":86,"address":[3153248],"length":1,"stats":{"Line":1}},{"line":87,"address":[3153262],"length":1,"stats":{"Line":1}},{"line":89,"address":[3153311,3153270],"length":1,"stats":{"Line":2}},{"line":90,"address":[3153413,3153364],"length":1,"stats":{"Line":2}},{"line":91,"address":[3153415,3153389],"length":1,"stats":{"Line":1}},{"line":94,"address":[3153380],"length":1,"stats":{"Line":1}},{"line":97,"address":[3153440],"length":1,"stats":{"Line":1}},{"line":99,"address":[3153474,3153543],"length":1,"stats":{"Line":2}},{"line":100,"address":[3153530],"length":1,"stats":{"Line":1}},{"line":102,"address":[3153545],"length":1,"stats":{"Line":0}},{"line":106,"address":[3153577,3153550],"length":1,"stats":{"Line":2}},{"line":107,"address":[3153597],"length":1,"stats":{"Line":1}},{"line":108,"address":[3153692,3153657],"length":1,"stats":{"Line":1}},{"line":109,"address":[3153685],"length":1,"stats":{"Line":1}},{"line":112,"address":[3153557],"length":1,"stats":{"Line":1}},{"line":116,"address":[3153728,3154363,3154357],"length":1,"stats":{"Line":1}},{"line":117,"address":[3153774],"length":1,"stats":{"Line":1}},{"line":118,"address":[3153806],"length":1,"stats":{"Line":1}},{"line":120,"address":[3153819],"length":1,"stats":{"Line":1}},{"line":122,"address":[3153900,3153829],"length":1,"stats":{"Line":2}},{"line":123,"address":[3154122,3154055],"length":1,"stats":{"Line":2}},{"line":124,"address":[3154137],"length":1,"stats":{"Line":0}},{"line":125,"address":[3154155],"length":1,"stats":{"Line":0}},{"line":127,"address":[3154183],"length":1,"stats":{"Line":1}},{"line":128,"address":[3154216],"length":1,"stats":{"Line":1}},{"line":129,"address":[3154258],"length":1,"stats":{"Line":1}},{"line":131,"address":[3154315],"length":1,"stats":{"Line":1}},{"line":134,"address":[3154079],"length":1,"stats":{"Line":1}},{"line":137,"address":[3154384,3154823,3154829],"length":1,"stats":{"Line":1}},{"line":138,"address":[3154424],"length":1,"stats":{"Line":1}},{"line":140,"address":[3154434,3154502],"length":1,"stats":{"Line":2}},{"line":141,"address":[3154723,3154657],"length":1,"stats":{"Line":2}},{"line":142,"address":[3154737],"length":1,"stats":{"Line":1}},{"line":144,"address":[3154784],"length":1,"stats":{"Line":1}},{"line":147,"address":[3154682],"length":1,"stats":{"Line":1}},{"line":150,"address":[3154848],"length":1,"stats":{"Line":1}},{"line":151,"address":[3154945,3154904],"length":1,"stats":{"Line":2}},{"line":152,"address":[3155005,3155061],"length":1,"stats":{"Line":2}},{"line":153,"address":[3155073],"length":1,"stats":{"Line":1}},{"line":156,"address":[3155026],"length":1,"stats":{"Line":1}},{"line":159,"address":[3155120],"length":1,"stats":{"Line":1}},{"line":160,"address":[3155149,3155190],"length":1,"stats":{"Line":2}},{"line":161,"address":[3155279,3155248],"length":1,"stats":{"Line":2}},{"line":162,"address":[3155302],"length":1,"stats":{"Line":1}},{"line":163,"address":[3155317,3155403],"length":1,"stats":{"Line":2}},{"line":164,"address":[3155408,3155377],"length":1,"stats":{"Line":1}}],"covered":59,"coverable":62},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","julieta_murias_v1.rs"],"content":"struct Examen {\n    nombre_materia: String,\n    nota: f64,\n}\n\nstruct Estudiante {\n    nombre: String,\n    id: i32,\n    examenes: Vec\u003cExamen\u003e,\n\n}\n\nstruct Informe {\n    nombre: String,\n    id: i32,\n    cant_examenes_rendidos: u32,\n    promedio: f64,\n    nota_baja: f64,\n    materia_baja: String,\n    nota_alta: f64,\n    materia_alta: String,\n}\n\npub fn obtener_materia_calificacion_alta(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más alta y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay.\");\n    }\n\n    let mut nota_mas_alta = f64::MIN;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() {\n        if examen.nota \u003e nota_mas_alta {\n            nota_mas_alta= examen.nota;\n            materia= examen.nombre_materia.clone();\n\n        }\n    }\n\n    materia\n}\n\npub fn obtener_materia_calificacion_baja(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más baja y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay\");\n    }\n\n    let mut nota_mas_baja = f64::MAX;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() { //Busco el examen con menor nota.\n        if examen.nota \u003c nota_mas_baja {\n            nota_mas_baja= examen.nota; //Actualizo.\n            materia= examen.nombre_materia.clone();\n        }\n    }\n\n    materia\n}\n\n\n\nimpl Examen {\n    fn new(nombre_materia: String, nota: f64) -\u003e Examen {\n        Examen {\n            nombre_materia,\n            nota,\n        }\n    }\n}\n\nimpl Estudiante {\n    fn new(nombre: String, id: i32) -\u003e Estudiante {\n        Estudiante {\n            nombre,\n            id,\n            examenes: Vec::new(),\n        }\n    }\n\n    fn obtener_promedio(\u0026self) -\u003e f64 {\n        let total_notas= self.examenes.len();\n        \n        if total_notas \u003e 0 {\n            let mut suma_notas= 0.0;\n            for examen in self.examenes.iter(){\n                suma_notas+= examen.nota;\n            }\n            return suma_notas/total_notas as f64;\n        }\n\n        0.0\n         \n     }\n\n     fn obtener_calificacion_mas_alta(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_alta = f64::MIN;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003e nota_mas_alta {\n                nota_mas_alta= examen.nota;\n            }\n        }\n\n        nota_mas_alta\n     }\n\n     fn obtener_calificacion_mas_baja(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_baja = f64::MAX;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003c nota_mas_baja {\n                nota_mas_baja= examen.nota;\n            }\n        }\n\n        nota_mas_baja\n     }\n\n     fn generar_informe (\u0026self) -\u003e Option\u003cInforme\u003e {\n        if self.examenes.len() == 0 {\n            return None; //Si no tiene notas devuelvo nada.\n        } else {\n            let informe = Informe { //Creo el informe y le aigno los campos.\n                nombre : self.nombre.clone(), \n                id: self.id,\n                cant_examenes_rendidos: self.examenes.len() as u32 -1,\n                promedio: self.obtener_promedio(),\n                nota_alta: self.obtener_calificacion_mas_alta(),\n                nota_baja: self.obtener_calificacion_mas_baja(),\n                materia_baja: obtener_materia_calificacion_baja(\u0026self.examenes),\n                materia_alta: obtener_materia_calificacion_alta(\u0026self.examenes),\n            };\n\n            return Some(informe); //Returno el Option con el informe.\n        }\n\n     }\n\n     \n\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n\n    #[test]\n    fn test_materias_asociadas_a_notas() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let materia1= obtener_materia_calificacion_alta(\u0026student.examenes);\n        assert_eq!(materia1, String::from(\"inglés\"));\n\n        let materia2 = obtener_materia_calificacion_baja(\u0026student.examenes);\n        assert_eq!(materia2, String::from(\"cadp\"));\n\n    }\n\n    #[test]\n    fn test_entregable1() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let informe1 = student.generar_informe();\n        assert!(informe1.is_some()); //pruebo con un estudiante que sí tenga informe.\n\n\n        let mut student= Estudiante::new(String::from(\"Pepe\"), 123);\n        let informe2 = student.generar_informe();\n        assert!(informe2.is_none()); //Pruebo con un estudiante que no tenga informe.\n\n    }\n\n\n    #[test]\n    fn test_promedio() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_promedio(), 9.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_promedio(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_alta() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_alta(), 10.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_alta(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_baja() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_baja(), 8.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_baja(), 0.0);\n    }\n}\n\n","traces":[{"line":24,"address":[3111947,3111392,3111953],"length":1,"stats":{"Line":1}},{"line":26,"address":[3111430],"length":1,"stats":{"Line":1}},{"line":27,"address":[3111446],"length":1,"stats":{"Line":0}},{"line":30,"address":[3111475],"length":1,"stats":{"Line":1}},{"line":31,"address":[3111480],"length":1,"stats":{"Line":1}},{"line":33,"address":[3111588,3111507],"length":1,"stats":{"Line":2}},{"line":34,"address":[3111942,3111736],"length":1,"stats":{"Line":2}},{"line":35,"address":[3111791],"length":1,"stats":{"Line":1}},{"line":36,"address":[3111837,3111802],"length":1,"stats":{"Line":1}},{"line":41,"address":[3111756],"length":1,"stats":{"Line":1}},{"line":44,"address":[3112533,3112527,3111968],"length":1,"stats":{"Line":1}},{"line":46,"address":[3112006],"length":1,"stats":{"Line":1}},{"line":47,"address":[3112022],"length":1,"stats":{"Line":0}},{"line":50,"address":[3112051],"length":1,"stats":{"Line":1}},{"line":51,"address":[3112056],"length":1,"stats":{"Line":1}},{"line":53,"address":[3112083,3112164],"length":1,"stats":{"Line":2}},{"line":54,"address":[3112312,3112522],"length":1,"stats":{"Line":2}},{"line":55,"address":[3112371],"length":1,"stats":{"Line":1}},{"line":56,"address":[3112417,3112382],"length":1,"stats":{"Line":1}},{"line":60,"address":[3112336],"length":1,"stats":{"Line":1}},{"line":66,"address":[3112560],"length":1,"stats":{"Line":2}},{"line":75,"address":[3112766,3112608],"length":1,"stats":{"Line":1}},{"line":79,"address":[3112652],"length":1,"stats":{"Line":1}},{"line":83,"address":[3112784],"length":1,"stats":{"Line":1}},{"line":84,"address":[3112798],"length":1,"stats":{"Line":1}},{"line":86,"address":[3112817],"length":1,"stats":{"Line":1}},{"line":87,"address":[3112839],"length":1,"stats":{"Line":1}},{"line":88,"address":[3112972,3112902,3112848],"length":1,"stats":{"Line":6}},{"line":89,"address":[3112955],"length":1,"stats":{"Line":2}},{"line":91,"address":[3112979],"length":1,"stats":{"Line":1}},{"line":94,"address":[3112823],"length":1,"stats":{"Line":1}},{"line":98,"address":[3113040],"length":1,"stats":{"Line":1}},{"line":99,"address":[3113054],"length":1,"stats":{"Line":1}},{"line":100,"address":[3113069],"length":1,"stats":{"Line":1}},{"line":103,"address":[3113085],"length":1,"stats":{"Line":1}},{"line":105,"address":[3113153,3113099],"length":1,"stats":{"Line":2}},{"line":106,"address":[3113210,3113254],"length":1,"stats":{"Line":2}},{"line":107,"address":[3113243],"length":1,"stats":{"Line":1}},{"line":111,"address":[3113225],"length":1,"stats":{"Line":1}},{"line":114,"address":[3113264],"length":1,"stats":{"Line":1}},{"line":115,"address":[3113278],"length":1,"stats":{"Line":1}},{"line":116,"address":[3113293],"length":1,"stats":{"Line":1}},{"line":119,"address":[3113309],"length":1,"stats":{"Line":1}},{"line":121,"address":[3113377,3113323],"length":1,"stats":{"Line":2}},{"line":122,"address":[3113434,3113482],"length":1,"stats":{"Line":2}},{"line":123,"address":[3113471],"length":1,"stats":{"Line":1}},{"line":127,"address":[3113453],"length":1,"stats":{"Line":1}},{"line":130,"address":[3113488,3114063,3114069],"length":1,"stats":{"Line":1}},{"line":131,"address":[3113526],"length":1,"stats":{"Line":1}},{"line":132,"address":[3113546],"length":1,"stats":{"Line":1}},{"line":135,"address":[3113566],"length":1,"stats":{"Line":1}},{"line":136,"address":[3113588],"length":1,"stats":{"Line":1}},{"line":137,"address":[3113705,3113673,3113595],"length":1,"stats":{"Line":2}},{"line":138,"address":[3113692],"length":1,"stats":{"Line":1}},{"line":139,"address":[3113730],"length":1,"stats":{"Line":1}},{"line":140,"address":[3113748],"length":1,"stats":{"Line":1}},{"line":141,"address":[3113765],"length":1,"stats":{"Line":1}},{"line":142,"address":[3113789],"length":1,"stats":{"Line":1}},{"line":145,"address":[3114043],"length":1,"stats":{"Line":1}}],"covered":57,"coverable":59},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","julieta_murias_v2.rs"],"content":"struct Examen {\n    nombre_materia: String,\n    nota: f64,\n}\n\nstruct Estudiante {\n    nombre: String,\n    id: i32,\n    examenes: Vec\u003cExamen\u003e,\n\n}\n\nstruct Informe {\n    nombre: String,\n    id: i32,\n    cant_examenes_rendidos: u32,\n    promedio: f64,\n    nota_baja: f64,\n    materia_baja: String,\n    nota_alta: f64,\n    materia_alta: String,\n}\n\npub fn obtener_materia_calificacion_alta(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más alta y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay.\");\n    }\n\n    let mut nota_mas_alta = f64::MIN;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() {\n        if examen.nota \u003e nota_mas_alta {\n            nota_mas_alta= examen.nota;\n            materia= examen.nombre_materia.clone();\n\n        }\n    }\n\n    materia\n}\n\npub fn obtener_materia_calificacion_baja(examenes: \u0026Vec\u003cExamen\u003e) -\u003e String {\n    //función auxiliar que busca la nota más baja y se queda con la materia asociada a ésta.\n    if examenes.len() == 0 {\n        return String::from(\"No hay\");\n    }\n\n    let mut nota_mas_baja = f64::MAX;\n    let mut materia= String::from(\"materia\");\n    \n    for examen in examenes.iter() { //Busco el examen con menor nota.\n        if examen.nota \u003c nota_mas_baja {\n            nota_mas_baja= examen.nota; //Actualizo.\n            materia= examen.nombre_materia.clone();\n        }\n    }\n\n    materia\n}\n\n\n\nimpl Examen {\n    fn new(nombre_materia: String, nota: f64) -\u003e Examen {\n        Examen {\n            nombre_materia,\n            nota,\n        }\n    }\n}\n\nimpl Estudiante {\n    fn new(nombre: String, id: i32) -\u003e Estudiante {\n        Estudiante {\n            nombre,\n            id,\n            examenes: Vec::new(),\n        }\n    }\n\n    fn obtener_promedio(\u0026self) -\u003e f64 {\n        let total_notas= self.examenes.len();\n        \n        if total_notas \u003e 0 {\n            let mut suma_notas= 0.0;\n            for examen in self.examenes.iter(){\n                suma_notas+= examen.nota;\n            }\n            return suma_notas/total_notas as f64;\n        }\n\n        0.0\n         \n     }\n\n     fn obtener_calificacion_mas_alta(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_alta = f64::MIN;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003e nota_mas_alta {\n                nota_mas_alta= examen.nota;\n            }\n        }\n\n        nota_mas_alta\n     }\n\n     fn obtener_calificacion_mas_baja(\u0026self) -\u003e f64 {\n        if self.examenes.len() == 0 {\n            return 0.0;\n        }\n\n        let mut nota_mas_baja = f64::MAX;\n        \n        for examen in self.examenes.iter() {\n            if examen.nota \u003c nota_mas_baja {\n                nota_mas_baja= examen.nota;\n            }\n        }\n\n        nota_mas_baja\n     }\n\n     fn generar_informe (\u0026self) -\u003e Option\u003cInforme\u003e {\n        if self.examenes.len() == 0 {\n            return None; //Si no tiene notas devuelvo nada.\n        } else {\n            let informe = Informe { //Creo el informe y le aigno los campos.\n                nombre : self.nombre.clone(), \n                id: self.id,\n                cant_examenes_rendidos: self.examenes.len() as u32, //Modificación respecto a la versión anterior: le saqué el -1. Ahora devuelve la cantidad correcta de exámenes\n                promedio: self.obtener_promedio(),\n                nota_alta: self.obtener_calificacion_mas_alta(),\n                nota_baja: self.obtener_calificacion_mas_baja(),\n                materia_baja: obtener_materia_calificacion_baja(\u0026self.examenes),\n                materia_alta: obtener_materia_calificacion_alta(\u0026self.examenes),\n            };\n\n            return Some(informe); //Returno el Option con el informe.\n        }\n\n     }\n\n     \n\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n\n    #[test]\n    fn test_materias_asociadas_a_notas() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let materia1= obtener_materia_calificacion_alta(\u0026student.examenes);\n        assert_eq!(materia1, String::from(\"inglés\"));\n\n        let materia2 = obtener_materia_calificacion_baja(\u0026student.examenes);\n        assert_eq!(materia2, String::from(\"cadp\"));\n\n    }\n\n    #[test]\n    fn test_entregable1() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        let informe1 = student.generar_informe();\n        assert!(informe1.is_some()); //pruebo con un estudiante que sí tenga informe.\n\n\n        let mut student= Estudiante::new(String::from(\"Pepe\"), 123);\n        let informe2 = student.generar_informe();\n        assert!(informe2.is_none()); //Pruebo con un estudiante que no tenga informe.\n\n    }\n\n\n    #[test]\n    fn test_promedio() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_promedio(), 9.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_promedio(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_alta() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_alta(), 10.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_alta(), 0.0);\n    }\n\n    #[test]\n    fn test_obtener_calificacion_baja() {\n        let mut student= Estudiante::new(String::from(\"Julieta\"), 123);\n        student.examenes.push(Examen::new(String::from(\"cadp\"), 8.0));\n        student.examenes.push(Examen::new(String::from(\"inglés\"), 10.0));\n\n        assert_eq!(student.obtener_calificacion_mas_baja(), 8.0);\n\n        let mut student2= Estudiante::new(String::from(\"Pepe\"), 999);\n        assert_eq!(student2.obtener_calificacion_mas_baja(), 0.0);\n    }\n}\n\n","traces":[{"line":24,"address":[3004513,3003952,3004507],"length":1,"stats":{"Line":1}},{"line":26,"address":[3003990],"length":1,"stats":{"Line":1}},{"line":27,"address":[3004006],"length":1,"stats":{"Line":0}},{"line":30,"address":[3004035],"length":1,"stats":{"Line":1}},{"line":31,"address":[3004040],"length":1,"stats":{"Line":1}},{"line":33,"address":[3004067,3004148],"length":1,"stats":{"Line":2}},{"line":34,"address":[3004296,3004502],"length":1,"stats":{"Line":2}},{"line":35,"address":[3004351],"length":1,"stats":{"Line":1}},{"line":36,"address":[3004397,3004362],"length":1,"stats":{"Line":1}},{"line":41,"address":[3004316],"length":1,"stats":{"Line":1}},{"line":44,"address":[3004528,3005093,3005087],"length":1,"stats":{"Line":1}},{"line":46,"address":[3004566],"length":1,"stats":{"Line":1}},{"line":47,"address":[3004582],"length":1,"stats":{"Line":0}},{"line":50,"address":[3004611],"length":1,"stats":{"Line":1}},{"line":51,"address":[3004616],"length":1,"stats":{"Line":1}},{"line":53,"address":[3004643,3004724],"length":1,"stats":{"Line":2}},{"line":54,"address":[3005082,3004872],"length":1,"stats":{"Line":2}},{"line":55,"address":[3004931],"length":1,"stats":{"Line":1}},{"line":56,"address":[3004977,3004942],"length":1,"stats":{"Line":1}},{"line":60,"address":[3004896],"length":1,"stats":{"Line":1}},{"line":66,"address":[3005120],"length":1,"stats":{"Line":1}},{"line":75,"address":[3005326,3005168],"length":1,"stats":{"Line":1}},{"line":79,"address":[3005212],"length":1,"stats":{"Line":1}},{"line":83,"address":[3005344],"length":1,"stats":{"Line":1}},{"line":84,"address":[3005358],"length":1,"stats":{"Line":1}},{"line":86,"address":[3005377],"length":1,"stats":{"Line":1}},{"line":87,"address":[3005399],"length":1,"stats":{"Line":1}},{"line":88,"address":[3005532,3005408,3005462],"length":1,"stats":{"Line":3}},{"line":89,"address":[3005515],"length":1,"stats":{"Line":1}},{"line":91,"address":[3005539],"length":1,"stats":{"Line":1}},{"line":94,"address":[3005383],"length":1,"stats":{"Line":1}},{"line":98,"address":[3005600],"length":1,"stats":{"Line":1}},{"line":99,"address":[3005614],"length":1,"stats":{"Line":1}},{"line":100,"address":[3005629],"length":1,"stats":{"Line":1}},{"line":103,"address":[3005645],"length":1,"stats":{"Line":1}},{"line":105,"address":[3005713,3005659],"length":1,"stats":{"Line":2}},{"line":106,"address":[3005770,3005814],"length":1,"stats":{"Line":3}},{"line":107,"address":[3005803],"length":1,"stats":{"Line":1}},{"line":111,"address":[3005785],"length":1,"stats":{"Line":2}},{"line":114,"address":[3005824],"length":1,"stats":{"Line":1}},{"line":115,"address":[3005838],"length":1,"stats":{"Line":1}},{"line":116,"address":[3005853],"length":1,"stats":{"Line":1}},{"line":119,"address":[3005869],"length":1,"stats":{"Line":1}},{"line":121,"address":[3005937,3005883],"length":1,"stats":{"Line":2}},{"line":122,"address":[3005994,3006042],"length":1,"stats":{"Line":2}},{"line":123,"address":[3006031],"length":1,"stats":{"Line":1}},{"line":127,"address":[3006013],"length":1,"stats":{"Line":1}},{"line":130,"address":[3006601,3006607,3006048],"length":1,"stats":{"Line":1}},{"line":131,"address":[3006086],"length":1,"stats":{"Line":1}},{"line":132,"address":[3006106],"length":1,"stats":{"Line":1}},{"line":135,"address":[3006126],"length":1,"stats":{"Line":1}},{"line":136,"address":[3006148],"length":1,"stats":{"Line":1}},{"line":137,"address":[3006155],"length":1,"stats":{"Line":1}},{"line":138,"address":[3006242],"length":1,"stats":{"Line":1}},{"line":139,"address":[3006260],"length":1,"stats":{"Line":1}},{"line":140,"address":[3006278],"length":1,"stats":{"Line":1}},{"line":141,"address":[3006296],"length":1,"stats":{"Line":1}},{"line":142,"address":[3006320],"length":1,"stats":{"Line":1}},{"line":145,"address":[3006581],"length":1,"stats":{"Line":1}}],"covered":57,"coverable":59},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp03","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05;\npub mod julieta_murias_v1;\npub mod ej07;\npub mod ej08;\npub mod ej09;\npub mod ej10;\n\npub mod julieta_murias_v2;","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej01.rs"],"content":"pub trait Primo {\n    fn soy_primo (\u0026self) -\u003e bool;\n}\n\nimpl Primo for i32 {\n\n    fn soy_primo(\u0026self) -\u003e bool {\n        if *self \u003c 2 {\n            return false;\n        }\n        for number in 2..=(*self as f64).sqrt() as i32 {\n            if self % number == 0 {\n                return false;\n            }\n        }\n        true\n    }\n\n}\n\npub fn contar_primos(numeros: \u0026Vec\u003ci32\u003e) -\u003e u32 {    \n    //\u0026\u0026i32 ????\n    numeros.iter().filter(|x| x.soy_primo()).count() as u32\n}\n\n\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn testar_contar_primos() {\n        let numbers:Vec\u003ci32\u003e = vec![1,2,3,4,5,6,7,8,9,10];\n\n        assert_eq!(contar_primos(\u0026numbers), 4);\n    }\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej02.rs"],"content":"#[derive(Clone)]\nstruct Persona \u003c'a\u003e{\n    nombre: \u0026'a str,\n    apellido: \u0026'a str,\n    direccion: \u0026'a str,\n    ciudad: \u0026'a str,\n    salario: f64,\n    edad: u8,\n}\n\n\n//Preg si está bien el uso del trait persona???\ntrait PersonaOps \u003c'a\u003e {\n    fn filtrar_por_salario(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, salario: f64) -\u003e Option\u003cVec\u003cPersona\u003c'a\u003e\u003e\u003e;\n    fn filtrar_por_edad_ciudad(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, edad: u8, ciudad: String) -\u003e Option\u003cVec\u003cPersona\u003c'a\u003e\u003e\u003e;\n    fn todos_viven_en(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool;\n    fn alguno_vive_en(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, ciudad:  \u0026str) -\u003e bool;\n    fn persona_existe(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, persona: \u0026Persona\u003c'a\u003e) -\u003e bool;\n    fn recolectar_edades(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003cVec\u003cu8\u003e\u003e;\n    fn salario_mayor_menor(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e  Option\u003c(\u0026Persona\u003c'a\u003e, \u0026Persona\u003c'a\u003e)\u003e;\n}\n\n\n\nimpl \u003c'a\u003e PersonaOps \u003c'a\u003e for Persona \u003c'a\u003e {\n\n    //Está bien??? Me da muchas dudas la parte de self pq no lo uso nunca \n    \n    fn filtrar_por_salario\u003c'b\u003e (\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'b\u003e\u003e, salario: f64) -\u003e Option\u003cVec\u003cPersona\u003c'b\u003e\u003e\u003e {\n        let people:Vec\u003cPersona\u003e = personas.iter().filter(|p| p.salario \u003e salario).cloned().collect();\n\n        if people.len() == 0 {\n            return None;\n        } else {\n            return Some(people);\n        }\n    }\n\n    fn filtrar_por_edad_ciudad\u003c'c\u003e (\u0026self, personas: \u0026'c Vec\u003cPersona\u003c'c\u003e\u003e, edad: u8, ciudad: String) -\u003e Option\u003cVec\u003cPersona\u003c'c\u003e\u003e\u003e {\n        let people:Vec\u003cPersona\u003e = personas.iter().filter(|p| p.edad \u003e edad \u0026\u0026 p.ciudad == ciudad).cloned().collect();\n\n        if people.len() == 0 {\n            return None;\n        } else {\n            return Some(people);\n        }\n    }\n\n    fn todos_viven_en\u003c'd\u003e (\u0026self, personas: \u0026'd Vec\u003cPersona\u003c'd\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n        if personas.is_empty() {\n            return false;\n        }\n        personas.iter().all(|p| p.ciudad.eq_ignore_ascii_case(\u0026ciudad))\n    }\n\n    fn alguno_vive_en (\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, ciudad: \u0026str) -\u003e bool {\n        if personas.is_empty() {\n            return false;\n        }\n        personas.iter().any(|p| p.ciudad.eq_ignore_ascii_case(\u0026ciudad))\n    }\n\n    fn persona_existe\u003c'e\u003e(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e, persona: \u0026Persona\u003c'e\u003e) -\u003e bool {\n        if personas.is_empty() {\n            return false;\n        }\n        personas.iter().any(|p| compare(p.clone(), persona.clone()))\n    }\n\n    fn recolectar_edades(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        if personas.is_empty() {\n            return None;\n        } else {\n            let edades: Vec\u003cu8\u003e = personas.iter().map(|p| p.edad).collect();\n            return Some(edades);\n        }\n    } \n\n    fn salario_mayor_menor(\u0026self, personas: \u0026'a Vec\u003cPersona\u003c'a\u003e\u003e) -\u003e Option\u003c(\u0026Persona\u003c'a\u003e, \u0026Persona\u003c'a\u003e)\u003e{ //Return a tuple with both people.\n        if personas.is_empty() {\n            return None;\n        } else {\n            let min = personas.iter().min_by(|a, b| {  //a and b are references to the items in the vector.\n                a.salario \n                    .partial_cmp(\u0026b.salario) //Primary comparison.\n                    .unwrap() //Unwrap because .partial_cmp() returns an Option, and I'm sure that there are no Nan values in the data.\n                    .then(b.edad.cmp(\u0026a.edad))  //Tie break. (Second condition; older wins!).\n            });\n            \n            //Same but for max.\n            let max = personas.iter().max_by(|a, b| {\n                a.salario \n                    .partial_cmp(\u0026b.salario)\n                    .unwrap()\n                    .then(b.edad.cmp(\u0026a.edad)) \n            });\n\n            if let (Some(min), Some(max)) = (min, max) {\n                Some((min, max))\n            } else { //Esto está de más????\n                None\n            }\n        }\n    }\n\n    \n}\n\npub fn compare (person1: Persona, person2: Persona) -\u003e bool {\n    person1.nombre == person2.nombre \u0026\u0026\n    person1.apellido == person2.apellido \u0026\u0026\n    person1.direccion.eq_ignore_ascii_case(person2.direccion) \u0026\u0026\n    person1.ciudad.eq_ignore_ascii_case(person2.ciudad) \u0026\u0026\n    person1.edad == person2.edad \u0026\u0026\n    person1.salario == person2.salario\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    fn crear_vector_con_personas\u003c'a\u003e() -\u003e Vec\u003cPersona\u003c'a\u003e\u003e {\n        vec![\n            Persona {\n                nombre: \"Juli\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 19,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Pepe\",\n                apellido: \"P\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 20,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Nombre\",\n                apellido: \"N\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 60,\n                salario: 50000.0,\n            },\n            Persona {\n                nombre: \"Jorgito\",\n                apellido: \"J\",\n                direccion: \"Arg\",\n                ciudad: \"Bs As\",\n                edad: 35,\n                salario: 45000.0,\n            },\n            Persona {\n                nombre: \"Benja\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 25,\n                salario: 60000.0,\n            },\n        ]\n    }\n\n\n    #[test]\n    fn test_filtrar_por_salario() {\n        let personas= crear_vector_con_personas();\n        let personas_inexistentes:Vec\u003cPersona\u003e = vec![];\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n        let filtrados = persona.filtrar_por_salario(\u0026personas, 10000.0);\n        //There should be 3 people in filtrados.\n        \n        assert!(filtrados.is_some());\n        assert_eq!(filtrados.as_ref().unwrap().len(), 3);\n        assert_ne!(filtrados.as_ref().unwrap().len(), 5);\n\n\n        //Test with the empty vec.\n        let filtrados_vacios = persona.filtrar_por_salario(\u0026personas_inexistentes, 10000.0);\n        assert!(filtrados_vacios.is_none());\n    }\n\n    #[test]\n    fn test_filtrar_por_edad_ciudad() {\n        let personas= crear_vector_con_personas();\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n        let filtrados = persona.filtrar_por_edad_ciudad(\u0026personas, 20, \"La plata\".to_string());\n\n        //In filtrados there should be 2 people.\n        assert!(filtrados.is_some());\n        assert_eq!(filtrados.as_ref().unwrap().len(), 2);\n    }\n\n    #[test]\n    fn test_todos_viven_en() {\n        let personas_no_cumplen = crear_vector_con_personas(); //Not everyone lives in La Plata.\n        let personas_cumplen = vec![\n            Persona {\n                nombre: \"Juli\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 19,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Pepe\",\n                apellido: \"P\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 20,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Nombre\",\n                apellido: \"N\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 60,\n                salario: 50000.0,\n            },\n            Persona {\n                nombre: \"Jorgito\",\n                apellido: \"J\",\n                direccion: \"Arg\",\n                ciudad: \"La Plata\",\n                edad: 35,\n                salario: 45000.0,\n            },\n            Persona {\n                nombre: \"Benja\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La PLATA\",\n                edad: 25,\n                salario: 60000.0,\n            },\n        ];\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        assert_eq!(persona.todos_viven_en(\u0026personas_no_cumplen, \"La plata\"), false);\n        assert_eq!(persona.todos_viven_en(\u0026personas_cumplen, \"La plata\"), true);\n\n    }\n\n    #[test]\n    fn test_alguno_vive_en() {\n        let personas_cumplen = crear_vector_con_personas(); //There's one person that lives in Bs As (the city I'm using to check).\n        let personas_no_cumplen = vec![ //Nobody lives in Bs As.s\n            Persona {\n                nombre: \"Juli\",\n                apellido: \"M\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 19,\n                salario: 10000.0,\n            },\n            Persona {\n                nombre: \"Pepe\",\n                apellido: \"P\",\n                direccion: \"Arg\",\n                ciudad: \"La plata\",\n                edad: 20,\n                salario: 10000.0,\n            },\n        ];\n\n        let persona= Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        assert_eq!(persona.alguno_vive_en(\u0026personas_cumplen, \"bs as\"), true);\n        assert_eq!(persona.alguno_vive_en(\u0026personas_no_cumplen, \"bs as\"), false);\n\n        assert_ne!(persona.alguno_vive_en(\u0026personas_no_cumplen, \"bs as\"), true);\n\n    }\n\n    #[test]\n    fn test_persona_existe() {\n        let personas = crear_vector_con_personas();\n        let persona_existente = Persona {nombre: \"Juli\", apellido: \"M\", ciudad: \"la plata\", direccion: \"arg\", edad: 19, salario: 10000.0};\n        let persona_inexistente = Persona {nombre: \"zzz\", apellido: \"M\", ciudad: \"la plata\", direccion: \"arg\", edad: 99, salario: 20000.0};\n\n        let persona_tester = Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        assert_eq!(persona_tester.persona_existe(\u0026personas, \u0026persona_existente), true);\n        assert_eq!(persona_tester.persona_existe(\u0026personas, \u0026persona_inexistente), false);\n    }\n\n    #[test]\n    fn test_recolectar_edades() {\n        let personas = crear_vector_con_personas();\n        let persona_tester = Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n    \n        let edades =  persona_tester.recolectar_edades(\u0026personas);\n        assert!(edades.is_some());\n        assert_eq!(*edades.as_ref().unwrap(), vec![19,20,60,35,25]);\n\n\n        let edades = persona_tester.recolectar_edades(\u0026vec![]);\n        assert!(edades.is_none());\n    }\n\n    #[test]\n    fn test_salario_mayor_menor() {\n        let personas = crear_vector_con_personas();\n        let persona_tester = Persona {nombre: \"Persona test\", salario: 0.0, apellido: \"test\", edad: 0, ciudad: \"\", direccion: \"\"};\n\n        let result = persona_tester.salario_mayor_menor(\u0026personas);\n        assert!(result.is_some());\n\n        let (persona_menor_salario, persona_mayor_salario) = result.unwrap();\n\n        assert_eq!(persona_menor_salario.nombre, \"Pepe\");\n        assert_eq!(persona_mayor_salario.nombre, \"Benja\");\n\n\n        let personas2: Vec\u003cPersona\u003c'_\u003e\u003e = vec![];\n        let result2 = persona_tester.salario_mayor_menor(\u0026personas2);\n        assert!(result2.is_none());\n    }\n}","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej03.rs"],"content":"use std::ptr::eq;\n\n#[derive(Clone, Debug)]\nenum TipoSuscripcion {\n    Basic,\n    Clasic,\n    Super,\n}\n\nimpl PartialEq for TipoSuscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoSuscripcion::Basic, TipoSuscripcion::Basic) =\u003e true,\n            (TipoSuscripcion::Clasic, TipoSuscripcion::Clasic) =\u003e true,\n            (TipoSuscripcion::Super, TipoSuscripcion::Super) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n\nimpl TipoSuscripcion {\n    fn costo_mensual(\u0026self) -\u003e f64 {\n        match self {\n            TipoSuscripcion::Basic =\u003e 5.0,\n            TipoSuscripcion::Clasic =\u003e 9.5,\n            TipoSuscripcion::Super =\u003e 15.0,\n        }\n    }\n\n    fn upgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e{\n        match self {\n            TipoSuscripcion::Basic =\u003e Some(TipoSuscripcion::Clasic),\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Super),\n            TipoSuscripcion::Super =\u003e None,\n        }\n    }\n\n    fn downgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\n        match  self {\n            TipoSuscripcion::Basic =\u003e None,\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Basic),\n            TipoSuscripcion::Super =\u003e Some(TipoSuscripcion::Clasic),\n            \n        }\n    }\n\n    fn soy_basic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Basic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_clasic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Clasic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_super(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Super =\u003e true,\n            _ =\u003e false, \n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Suscripcion {\n    tipo: TipoSuscripcion,\n    duracion_meses: u8,\n    fecha_inicio: String,\n    activa: bool,\n}\n\nimpl Suscripcion {\n    fn new(tipo: TipoSuscripcion, duracion_meses: u8, fecha_inicio: String) -\u003e Suscripcion {\n        Suscripcion {\n            tipo,\n            duracion_meses,\n            fecha_inicio,\n            activa: true,\n        }\n    }\n\n    fn activar_suscripcion(\u0026mut self) {\n        self.activa = true\n    }\n\n    fn desactivar_suscripcion(\u0026mut self) {\n        self.activa = false\n    }\n\n    fn upgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.upgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede ascender de Super.\".to_string()) //Is it okay to make it an err? \n        }\n    }\n\n    fn downgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.downgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e {\n                self.desactivar_suscripcion();\n                Err(\"Se ha canclado su suscripción.\".to_string())\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum MedioPago {\n    Efectivo,\n    MercadoPago {\n        cbu: u32,\n    },\n    TransferenciaBancaria {\n        cuenta_destino: String,\n        cuenta_origen: String,    },\n    TarjetaCredito {\n        numero_tarjeta: u32,\n    },\n    Cripto {\n        tipo_cripto: String,\n    },\n}\n\nimpl MedioPago {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            MedioPago::Efectivo =\u003e String::from(\"Efectivo\"),\n            MedioPago::TarjetaCredito { numero_tarjeta } =\u003e String::from(\"TarjetaCredito\"),\n            MedioPago::MercadoPago { cbu } =\u003e String::from(\"MercadoPago\"),\n            MedioPago::TransferenciaBancaria { cuenta_destino, cuenta_origen } =\u003e String::from(\"TransferenciaBancaria\"),\n            MedioPago::Cripto { tipo_cripto } =\u003e String::from(\"Cripto\"),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct Usuario {\n    suscripciones: Vec\u003cSuscripcion\u003e,\n    medio_pago: MedioPago,\n    id: u32,\n    username: String,\n    nombre: String,\n    apellido: String,\n    email: String,\n}\n\nimpl Usuario {\n    fn agregar_suscripcion(\u0026mut self, suscripcion: Suscripcion) {\n        self.suscripciones.iter_mut().for_each(|s| s.desactivar_suscripcion()); //Deactivate all previous subscriptons.\n        self.suscripciones.push(suscripcion); //Add the new subscription.\n    }\n\n    fn obtener_suscripcion_activa(\u0026self) -\u003e Option\u003c\u0026Suscripcion\u003e {\n        self.suscripciones.iter().find(|s| s.activa)\n    }\n\n    fn obtener_suscripcion_activa_mutable(\u0026mut self) -\u003e Option\u003c\u0026mut Suscripcion\u003e {\n        self.suscripciones.iter_mut().find(|s| s.activa)\n    }\n\n    fn cancelar_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion_a_cancelar) =\u003e {\n                suscripcion_a_cancelar.desactivar_suscripcion();\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede cancelar esa suscripción. Ya sea porque no existe o porque ya está desactivada.\".to_string())\n        }\n    }\n\n    fn tiene_suscripcion_activa(\u0026self) -\u003e bool {\n        self.suscripciones.iter().any(|s| s.activa)\n    }\n\n    fn upgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.upgrade();\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para mejorar.\".to_string())\n        }\n    }\n\n    fn downgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.downgrade();\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para degradar.\".to_string())\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct StreamingRust {\n    usuarios: Vec\u003cUsuario\u003e, \n}\n\nimpl StreamingRust {\n\n    pub fn crear_plataforma() -\u003e StreamingRust {\n        StreamingRust {\n            usuarios: Vec::new(),\n        }\n    }\n\n    pub fn crear_usuario(\u0026mut self, suscripcion: \u0026Suscripcion, medio_pago: \u0026MedioPago, id: u32, username: String, nombre: String, apellido: String, email: String) {\n        let usuario = Usuario {\n            id: id,\n            suscripciones: vec![suscripcion.clone()],\n            medio_pago: medio_pago.clone(),\n            username: username,\n            nombre: nombre,\n            apellido: apellido,\n            email: email,\n        };\n\n        self.usuarios.push(usuario);\n    }\n\n    pub fn upgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        //Given an user upgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.upgrade_suscripcion(); //Update subscription.\n        }\n    }\n\n    pub fn downgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        //Given an user downgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.downgrade_suscripcion(); //Downgrade subscription.\n        }\n    }\n\n    pub fn cancelar_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.cancelar_suscripcion(); //Downgrade subscription.\n        }\n    }\n\n    //Estadísticas.\n    pub fn suscripcion_mas_contratada_activos(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones activas de los usuarios.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro usuarios con suscripción activa.\n            .for_each(|u| { //Para cada una de ellas.\n                //Obtener el tipo de suscripción activa.\n                if let Some(suscripcion) = u.obtener_suscripcion_activa() {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {  //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n\n                    }\n                }\n               \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn suscripcion_mas_contratada(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        //No me importan solo las suscripciones activas, tengo que chequear todas.\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario.\n                //Recorrer sus suscripciones (todas).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n                    }\n                });                     \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn medio_pago_mas_usado_activos(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n        \n        //Si no coincide con ninguna, creo la posición con el medio de pago y la cantidad inicializada en 1.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro los usuarios con suscripciones activas.\n            .for_each(|u| {\n                //Busco si su medio de pago coincide con alguna entrada en el vector -\u003e aumento en 1 la cantidad.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                    entry.1 += 1;\n                } else {\n                    auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                }\n            });\n\n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.\n    }\n\n    pub fn medio_pago_mas_usado(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario. (No filter).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                    }\n                });                     \n            });\n        \n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.    \n    }\n\n}\n\n\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_upgrade_downgrade() {\n        let mut suscripcion0 = Suscripcion::new(TipoSuscripcion::Basic, 3, \"12/9/2020\".to_string());\n        let mut suscripcion1 = Suscripcion::new(TipoSuscripcion::Super, 3, \"4/9/2019\".to_string());\n\n        //Test upgrade. Ok.\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.upgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_clasic(), true);\n\n        assert!(suscripcion1.upgrade().is_err());\n\n        //Test downgrade. Ok.\n        assert!(suscripcion0.downgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.downgrade().is_err());\n        assert_eq!(suscripcion0.activa, false);\n    }\n\n    #[test]\n    fn test_upgrade_subscription() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut usuarios = vec![user0.clone()];\n        let mut plataforma = StreamingRust {usuarios};\n\n        plataforma.upgrade_suscripcion(\u0026mut user0);\n\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n\n        assert!(user0.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Clasic)); //Ok.\n\n\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 124 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Super,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        plataforma.usuarios.push(user1.clone());\n        plataforma.upgrade_suscripcion(\u0026mut user1);\n        assert!(user1.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Super)); //Ok.\n\n\n        plataforma.cancelar_suscripcion(\u0026mut user0);\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n        assert_eq!(user0.suscripciones.iter().any(|s| s.activa), false); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        //Creo los usuarios para agregarlos a mi plataforma después.\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user2 = Usuario {\n            username: \"sus2\".to_string(),\n            email: \"sus2@email\".to_string(),\n            apellido: \"2\".to_string(),\n            id: 3,\n            nombre: \"sus2\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 123 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user3 = Usuario {\n            username: \"sus3\".to_string(),\n            email: \"sus3@email\".to_string(),\n            apellido: \"3\".to_string(),\n            id: 4,\n            nombre: \"sus3\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: false,\n            }],\n        };\n\n        //En resumen: \n        //Medios de pago: Activos: 2 de efectivo, 1 de mercado pago. Inactivos: 1 Efectivo.\n        //Suscripciones: Activos: 2 Basic, 1 Clasic. Inactivos: 1 Clasic.\n\n        let mut usuarios = vec![user0.clone(), user1.clone(), user2.clone(), user3.clone()];\n        let mut plataforma = StreamingRust {usuarios};\n\n        assert_eq!(plataforma.medio_pago_mas_usado_activos(), Some((\"Efectivo\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.medio_pago_mas_usado(), Some((\"Efectivo\".to_string(), 3))); //Ok.\n\n        assert_eq!(plataforma.suscripcion_mas_contratada(), Some((TipoSuscripcion::Clasic, 2))); //Ok. (Se queda con el último valor que encontró (el clasic en este caso) si hay un empate).\n        assert_eq!(plataforma.suscripcion_mas_contratada_activos(), Some((TipoSuscripcion::Basic, 2))); //Ok.\n    }\n  \n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej04.rs"],"content":"use std::{collections::HashMap, vec};\nuse std::hash::{Hash, Hasher};\n\n#[derive(Clone, Debug)]\nstruct Producto {\n    nombre: String,\n    categoria: Categoria,\n    precio_base: f64,\n}\n\n#[derive(Clone, Debug)]\n#[derive(Eq, Hash, PartialEq)]\nenum Categoria {\n    Hogar,\n    Limpieza,\n    Comida,\n    Tecnologia,\n}\n\n/*impl PartialEq for Categoria {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Categoria::Comida, Categoria::Comida) =\u003e true,\n            (Categoria::Hogar, Categoria::Hogar) =\u003e true,\n            (Categoria::Limpieza, Categoria::Limpieza) =\u003e true,\n            (Categoria::Tecnologia, Categoria::Tecnologia) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}*/\n\n#[derive(Clone, Debug)]\n#[derive(Eq, Hash, PartialEq)]\nstruct DatosPersona {\n    nombre: String, \n    apellido: String,\n    direccion: String,\n    dni: u32,\n}\n\n#[derive(Clone, Debug, PartialEq)]\nstruct F64Wrapper(f64); //F64Wrapper is a simple struct that contains a single field of type f64.\n\nimpl Eq for F64Wrapper {} //The Eq trait is implemented manually. This is safe because PartialEq is already derived, and the wrapper ensures consistent equality checks.\n\nimpl Hash for F64Wrapper { //The Hash trait is implemented by converting the f64 value to its bit representation using to_bits(). This ensures that equivalent floating-point values produce the same hash.\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        // Convert the f64 to its bit representation for consistent hashing\n        self.0.to_bits().hash(state);\n    }\n}\n\n#[derive(Clone, Debug)]\n#[derive(Eq, Hash, PartialEq)]\nstruct Vendedor {\n    datos: DatosPersona,\n    legajo: u32,\n    antiguedad: u32,\n    salario: F64Wrapper, //Now, the Vendedor struct can safely derive Eq and Hash. \n}\n\n#[derive(Clone, Debug)]\nstruct Cliente {\n    datos: DatosPersona,\n    suscripcion_newsletter: bool,\n    email_suscripcion: Option\u003cString\u003e, \n}\n\n#[derive(Clone, Debug)]\nstruct VentaProducto {\n    producto: Producto,\n    cantidad: u32,\n}\n\n#[derive(Clone, Debug)]\nstruct Venta {\n    fecha: String,\n    cliente: Cliente,\n    vendedor: Vendedor,\n    productos: Vec\u003cVentaProducto\u003e,\n    medio_pago: MedioPago,\n}\n\n#[derive(Clone, Debug)]\nenum MedioPago {\n    TarjetaCredito,\n    TarjetaDebito,\n    TransferenciaBancaria,\n    Efectivo,\n}\n\n#[derive(Clone, Debug)]\nstruct SistemaVentas {\n    ventas: Vec\u003cVenta\u003e,\n    categorias_descuento: Vec\u003cCategoria\u003e,\n    porcentajes_descuento: Vec\u003c(Categoria, f64)\u003e,\n}\n\nstruct ReportePorCategoria {\n    ventas_categoria: HashMap\u003cCategoria, Vec\u003cVenta\u003e\u003e,\n}\n\nstruct ReportePorVendedor {\n    ventas_vendedor: HashMap\u003cVendedor, Vec\u003cVenta\u003e\u003e,\n}\n\nimpl SistemaVentas {\n    pub fn new() -\u003e SistemaVentas {\n        SistemaVentas {\n            ventas: Vec::new(),\n            categorias_descuento: vec![Categoria::Hogar, Categoria::Tecnologia],\n            porcentajes_descuento: vec![(Categoria::Hogar, 15.0), (Categoria::Tecnologia, 20.0)],\n        }\n    }\n\n    pub fn crear_venta(\u0026mut self, fecha: String, cliente: \u0026Cliente, vendedor: \u0026Vendedor, productos: Vec\u003cVentaProducto\u003e, medio_pago: MedioPago) -\u003e Venta {\n        let venta = Venta{\n            cliente: cliente.clone(),\n            fecha: fecha,\n            vendedor: vendedor.clone(),\n            productos: productos,\n            medio_pago: medio_pago,\n        };\n\n        self.ventas.push(venta.clone());\n        venta\n    }\n\n    pub fn obtener_porcentaje_descuento(\u0026self, categoria: \u0026Categoria) -\u003e f64 {\n        //Buscar la categoria en el vector de descuentos y retornar lo que esté en la posición 1 de la tupla.\n        if let Some(entry) = self.porcentajes_descuento.iter().find(|(desc, _)| *desc == *categoria) {\n            return entry.1;\n        } else { //Si no está la ctegoría\n            return 0.0;\n        }\n    }\n\n    pub fn obtener_descuento_suscripcion(\u0026self) -\u003e f64 {\n        5.0\n    }\n\n    pub fn precio_final_venta(\u0026self, venta: \u0026Venta) -\u003e f64 {\n        if venta.productos.is_empty() {\n            return 0.0;\n        }\n\n        let mut precio = 0.0;\n\n        venta.productos.iter()\n            .for_each(|p| { //Para cada producto:\n                let mut precio_producto = p.producto.precio_base; //Inicializo el precio del producto con su precio base.\n                //Tengo que ver si encuentro la categoría del producto en el vector de categorías con descuento del sistema de ventas.\n                if self.categorias_descuento.iter().any(|c| *c == p.producto.categoria) {\n                    //Si el producto es de una categoría con descuento se lo aplico:\n                    precio_producto = (self.obtener_porcentaje_descuento(\u0026p.producto.categoria)/100.0) * p.producto.precio_base;\n                }\n                precio_producto = precio_producto * p.cantidad as f64; //Multiplico el precio (con el descuento aplicado o no) por la cantidad del producto.\n                precio += precio_producto; //Lo sumo en mi acumulador total.\n            });\n        \n        if venta.cliente.suscripcion_newsletter {\n            precio -= (self.obtener_descuento_suscripcion()/100.0) * precio;\n        }\n\n        precio\n    }\n\n    //Reportes.\n    fn reporte_por_vendedor(\u0026self) -\u003e ReportePorVendedor {\n        //Recorrer mi vector de ventas.\n        /*Por cada vendedor nuevo que no esté registrado en mi HM creo una entrada {\n            (vendedor, vec con esa venta.)}\n\n        Por cada vendedor que sí esté registrado en el HM  {\n            pusheo la venta al valor de esa entrada.}\n        */\n\n        let mut hm_auxiliar:HashMap\u003cVendedor, Vec\u003cVenta\u003e\u003e = HashMap::new();\n\n        for venta in self.ventas.iter() {\n            let vendedor = venta.vendedor.clone();\n            \n            if let Some(ventas_vendedor) = hm_auxiliar.get_mut(\u0026vendedor) {\n                ventas_vendedor.push(venta.clone());\n            } else {\n                hm_auxiliar.insert(vendedor, vec![venta.clone()]);\n            }\n        }\n\n        let reporte = ReportePorVendedor {\n           ventas_vendedor: hm_auxiliar,\n        };\n        \n        reporte\n    }\n\n    fn reporte_por_categoria(\u0026self) -\u003e ReportePorCategoria {\n        //Recorrer mi vector de ventas.\n        /*\n        Por cada venta :\n            Recorrer el listado de productos. \n            (Asumo que una misma venta se puede encontrar en más de una entrada del hm, porque sus productos pueden ser de más de una categoría.)\n                Por cada producto cuya categoría no esté registrada en mi HM -\u003e creo una entrada (categoria, vec con esa venta.)\n                Por cada categoría que sí esté registrada ern el hm -\u003e pusheo la venta al valor de esa entrada.\n         */\n\n        let mut hm_auxiliar:HashMap\u003cCategoria, Vec\u003cVenta\u003e\u003e = HashMap::new();\n\n        for venta in self.ventas.iter() { //Para cada venta.\n            let productos_venta = venta.productos.clone();\n            for producto_venta in productos_venta.iter() { //Para cada producto de la lista de productos.\n                let producto = producto_venta.producto.clone(); //Me guardo a ese producto.\n\n                if let Some(ventas_categoria) = hm_auxiliar.get_mut(\u0026producto.categoria) {\n                    ventas_categoria.push(venta.clone());\n                } else {\n                    hm_auxiliar.insert(producto.categoria.clone(), vec![venta.clone()]);\n                }\n\n            }\n        }\n\n        let reporte = ReportePorCategoria {\n            ventas_categoria: hm_auxiliar,\n         };\n         \n         reporte\n    }\n\n\n        \n}\n\n#[cfg(test)]\nmod test {\n\n    use super::*;\n\n    #[test]\n    fn test_crear_venta() {\n        let persona1 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 123,\n         };\n         \n         let persona2 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 234,\n         };\n\n        let cliente = Cliente {datos: persona1, suscripcion_newsletter: true, email_suscripcion: Some(String::from(\"pepe@email\")) };\n        let vendedor = Vendedor { datos: persona2, legajo: 0000, antiguedad: 3, salario: F64Wrapper(50000.0) };\n\n        let producto1 = Producto {\n            nombre: \"Agua\".to_string(),\n            categoria: Categoria::Comida,\n            precio_base: 600.0,\n        };\n\n        let producto2 = Producto {\n            nombre: \"Lampara\".to_string(),\n            categoria: Categoria::Hogar,\n            precio_base: 2000.0,\n        };\n\n        let prodCant1 = VentaProducto {\n            producto: producto1,\n            cantidad: 1,\n        };\n\n        let prodCant2 = VentaProducto {\n            producto: producto2,\n            cantidad: 1,\n        };\n\n        let productos = vec![prodCant1.clone(), prodCant2.clone()];\n\n        let mut sistema_ventas:SistemaVentas;\n\n        let mut sistema_ventas = SistemaVentas::new();\n        assert_eq!(sistema_ventas.ventas.len(), 0); //Ok.\n\n        sistema_ventas.crear_venta(\"1/1/2025\".to_string(), \u0026cliente, \u0026vendedor, productos, MedioPago::TransferenciaBancaria);\n\n        assert_eq!(sistema_ventas.ventas.len(), 1); //Ok.\n    }\n\n    #[test]\n    fn test_precio_final_venta() {\n\n        let persona1 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 123,\n         };\n         \n         let persona2 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 234,\n         };\n\n        let cliente = Cliente {datos: persona1, suscripcion_newsletter: true, email_suscripcion: Some(String::from(\"pepe@email\")) };\n        let vendedor = Vendedor { datos: persona2, legajo: 0000, antiguedad: 3, salario: F64Wrapper(50000.0) };\n\n        let producto1 = Producto {\n            nombre: \"Agua\".to_string(),\n            categoria: Categoria::Comida,\n            precio_base: 600.0,\n        };\n\n        let producto2 = Producto {\n            nombre: \"Lampara\".to_string(),\n            categoria: Categoria::Hogar,\n            precio_base: 2000.0,\n        };\n\n        let prodCant1 = VentaProducto {\n            producto: producto1,\n            cantidad: 1,\n        };\n\n        let prodCant2 = VentaProducto {\n            producto: producto2,\n            cantidad: 1,\n        };\n\n        let productos = vec![prodCant1.clone(), prodCant2.clone()];\n        let mut sistema_ventas = SistemaVentas::new();\n        let venta = sistema_ventas.crear_venta(\"1/1/2025\".to_string(), \u0026cliente, \u0026vendedor, productos, MedioPago::TransferenciaBancaria);\n\n        //El precio total tendría que ser de 855.0\n        assert_eq!(sistema_ventas.precio_final_venta(\u0026venta), 855.0); //Ok.\n    }\n\n    #[test]\n    fn test_reportes() {\n        let persona1 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 123,\n         };\n         \n         let persona2 = DatosPersona {\n            apellido: \"ape\".to_string(),\n            nombre: \"nom\".to_string(),\n            direccion: \"arg\".to_string(),\n            dni: 234,\n         };\n\n        let cliente = Cliente {datos: persona1, suscripcion_newsletter: true, email_suscripcion: Some(String::from(\"pepe@email\")) };\n        let vendedor = Vendedor { datos: persona2, legajo: 0000, antiguedad: 3, salario: F64Wrapper(50000.0) };\n\n        let producto1 = Producto {\n            nombre: \"Agua\".to_string(),\n            categoria: Categoria::Comida,\n            precio_base: 600.0,\n        };\n\n        let producto2 = Producto {\n            nombre: \"Lampara\".to_string(),\n            categoria: Categoria::Hogar,\n            precio_base: 2000.0,\n        };\n\n        let prodCant1 = VentaProducto {\n            producto: producto1,\n            cantidad: 1,\n        };\n\n        let prodCant2 = VentaProducto {\n            producto: producto2,\n            cantidad: 1,\n        };\n\n        let productos = vec![prodCant1.clone(), prodCant2.clone()];\n        let mut sistema_ventas = SistemaVentas::new();\n        let venta = sistema_ventas.crear_venta(\"1/1/2025\".to_string(), \u0026cliente, \u0026vendedor, productos.clone(), MedioPago::TransferenciaBancaria);\n        \n\n        let reporte_por_vendedor = sistema_ventas.reporte_por_vendedor();\n\n        assert_eq!(reporte_por_vendedor.ventas_vendedor.len(), 1); //Ok.\n\n\n        sistema_ventas.crear_venta(\"2/2/2025\".to_string(), \u0026cliente, \u0026vendedor, productos.clone(), MedioPago::Efectivo);\n        let reporte_por_vendedor2 = sistema_ventas.reporte_por_vendedor();\n\n        assert_eq!(reporte_por_vendedor2.ventas_vendedor.len(), 1); //Ok.\n        assert_eq!(reporte_por_vendedor2.ventas_vendedor.get(\u0026vendedor).unwrap().len(), 2); //Ok.\n\n        //REPORTE POR CATEGORÍA AHEAD:\n\n        let reporte_por_categoria = sistema_ventas.reporte_por_categoria();\n        assert_eq!(reporte_por_categoria.ventas_categoria.len(), 2); //Ok.\n    }\n\n}","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","ej05.rs"],"content":"use std::collections::HashMap;\nuse chrono::{DateTime, Utc};\nuse rand::Rng;\nuse std::ptr::eq;\n\n#[derive(Clone, Debug)]\nstruct Usuario {\n    nombre: String,\n    apellido: String,\n    email: String,\n    dni: u32,\n    identidad_validada: bool,\n    balance_fiat: f64,\n    balance_criptomoneda: HashMap\u003cString, f64\u003e, //Nombre_cripto -\u003e cantidad.\n}\n\n#[derive(Clone, Debug)]\nstruct Blockchain {\n    nombre: String,\n    prefijo: String,\n}\n\n#[derive(Clone, Debug)]\nstruct Criptomoneda { \n    nombre: String,\n    prefijo: String,\n    listado_blockchains: Vec\u003cBlockchain\u003e,\n}\n\n#[derive(Clone, Debug)]\npub enum TipoTransaccion {\n    IngresoFiat,\n    CompraCripto,\n    VentaCripto,\n    RetiroCripto,\n    RecepcionCripto,\n    RetiroFiat,\n}\n\nimpl PartialEq for TipoTransaccion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoTransaccion::CompraCripto, TipoTransaccion::CompraCripto) =\u003e true,\n            (TipoTransaccion::IngresoFiat, TipoTransaccion::IngresoFiat) =\u003e true,\n            (TipoTransaccion::RecepcionCripto, TipoTransaccion::RecepcionCripto) =\u003e true,\n            (TipoTransaccion::RetiroCripto, TipoTransaccion::RetiroCripto) =\u003e true,\n            (TipoTransaccion::RetiroFiat, TipoTransaccion::RetiroFiat) =\u003e true,\n            (TipoTransaccion::VentaCripto, TipoTransaccion::VentaCripto) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\nenum Medio {\n    MercadoPago,\n    TransferenciaBancaria,\n}\n\n#[derive(Clone, Debug)]\nstruct Transaccion {\n    fecha: DateTime\u003cUtc\u003e,\n    tipo: TipoTransaccion,\n    usuario: Usuario,\n    monto_fiat: Option\u003cf64\u003e,\n    criptomoneda: Option\u003cCriptomoneda\u003e,\n    monto_criptomoneda: Option\u003cf64\u003e,\n    cotizacion: Option\u003cf64\u003e,\n    blockchain: Option\u003cBlockchain\u003e,\n    hash: Option\u003cString\u003e,\n    medio: Option\u003cMedio\u003e,\n}\n\n#[derive(Clone, Debug)]\nstruct PlataformaXYZ {\n    usuarios: HashMap\u003cString, Usuario\u003e, //Email -\u003e usuario.\n    criptomonedas: HashMap\u003cString, Criptomoneda\u003e, //Nombre_cripto -\u003e cripto.\n    transacciones: Vec\u003cTransaccion\u003e,\n}\n\n//Custom errors.\n#[derive(Clone, Debug)]\nenum ErrorIntercambio { \n    UsuarioNoValido,\n    BalanceInsuficiente,\n    CriptoNoEncontrada,\n    BlockchainNoDisponible,\n    UsuarioNoEncontrado,\n}\n\n//Obtener cotizacion.\npub fn obtener_cotizacion(cripto_nombre: \u0026str) -\u003e f64  { //Datos en dólares del 28/05/2025.\n    match cripto_nombre {\n        \"Bitcoin\" =\u003e 107281.20,\n        \"Ethereum\" =\u003e 18.10,\n        \"Litecoin\" =\u003e 94.42,\n        _ =\u003e 50.0,\n    }\n}\n\nimpl PlataformaXYZ {\n    fn new() -\u003e Self {\n        PlataformaXYZ { usuarios: HashMap::new(), criptomonedas: HashMap::new(), transacciones:Vec::new() }\n    }\n\n    //Registrar usuario.\n    pub fn registrar_usuario(\u0026mut self, usuario: Usuario) { \n        self.usuarios.insert(usuario.email.clone(), usuario);\n    }\n\n    pub fn registrar_criptomoneda(\u0026mut self, criptomoneda: Criptomoneda) {\n        self.criptomonedas.insert(criptomoneda.nombre.clone(), criptomoneda);\n    }\n\n    pub fn ingresar_dinero(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Verify that the user exists and it is valided.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        match usuario.identidad_validada {\n            true =\u003e {\n                //Acredito el monto fiat.\n                usuario.balance_fiat += monto_fiat;\n                //println!(\"{}\", usuario.balance_fiat); Just to checked it worked (Ok.)\n                //Creo la transaccion.\n                let transaccion = Transaccion {\n                    fecha: Utc::now(),\n                    tipo: TipoTransaccion::IngresoFiat,\n                    usuario: usuario.clone(),\n                    monto_fiat: Some(monto_fiat),\n                    criptomoneda: None,\n                    monto_criptomoneda: None,\n                    cotizacion: None,\n                    blockchain: None,\n                    hash: None,\n                    medio: None,\n                };\n\n                //Agrego la transaccion a mi registro de transacciones.\n                self.transacciones.push(transaccion);\n                Ok(())\n            }\n            false =\u003e Err(ErrorIntercambio::UsuarioNoValido),\n        }\n    }\n\n    pub fn comprar_determinada_criptomoneda(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        if usuario.balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Check if the cripto exists.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //If we've come this far it is because the purchase can be made.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre); \n        usuario.balance_fiat -= monto_fiat; //Descuento el monto_fiat del balance_fiat del usuario.\n\n        //Acredito la cantidad acorde de criptos.\n        let cantidad_cripto = monto_fiat/cotizacion;\n\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) += cantidad_cripto;\n\n\n        /* EXPLICACIÓN:\n\n        entry() = busca si existe la clave, me da acceso para leer/crear la entrada. Retorna un entry enum (occupied, vacant).\n        or_insert() = \n            match entry {\n                Occupied(entrada) =\u003e entrada.get_mut(), // Si existe, devuelve \u0026mut al valor\n                Vacant(entrada) =\u003e entrada.insert(0.0), // Si no existe, inserta 0.0 y devuelve \u0026mut\n            }\n\n        Si \"pepe\" existe: retorna \u0026mut f64 apuntando al valor actual\n        Si \"pepe\" no existe: crea la entrada con valor 0.0 y retorna \u0026mut f64\n        */\n\n\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            usuario: usuario.clone(),\n            tipo: TipoTransaccion::CompraCripto,\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(cantidad_cripto),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n\n    pub fn vender_determinada_criptomoneda(\u0026mut self, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda, monto_criptomoneda: f64) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the cripto exixts.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //Check if the user has enough of that cripto to sell.\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        let monto_fiat = cotizacion * monto_criptomoneda;\n\n        //Actualizar datos del usuario.\n        usuario.balance_fiat += monto_fiat;\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) -= monto_criptomoneda; \n\n        //Creo la transaccion. \n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::VentaCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n\n    pub fn retirar_criptomoneda_a_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, blockchain: \u0026Blockchain, usuario: \u0026mut Usuario) -\u003e Result\u003cString, ErrorIntercambio\u003e {\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Verificar que la blockchain es soportada por la cripto.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?;\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n         //Generar hash simulado\n         let mut rng = rand::rng();\n         let hash = format!(\"{}{}\", blockchain.nombre, rng.random::\u003cu32\u003e());\n         \n         let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n\n         *usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre).unwrap() -= monto_criptomoneda; //Descuento la cantidad acorde de esa cripto.\n\n         //Generar transaccion.\n         let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: Some(hash.clone()),\n            medio: None,\n         };\n\n         self.transacciones.push(transaccion);\n         Ok(hash)\n    }\n\n    pub fn recibir_criptomoneda_de_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, usuario: \u0026mut Usuario, blockchain: \u0026Blockchain) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user data.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check cripto and blockchain.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?; //Si no existe se propaga el error y termina la función.\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n        //Acredito la cripto en el balance del usuario.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        if let Some(balance) = usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre) { //Busco si ya está la cripto en los balances del usuario.\n            *balance += monto_criptomoneda / cotizacion; \n        } else {\n            // Si la criptomoneda no existe en el balance, la inicializo con el monto dado.\n            usuario.balance_criptomoneda.insert(criptomoneda.nombre.clone(), monto_criptomoneda / cotizacion);\n        }\n\n        //Genero la transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RecepcionCripto,\n            usuario: usuario.clone(),\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_fiat: None,\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n    \n    pub fn retirar_fiat_por_determinado_medio(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, medio: \u0026Medio) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        let balance_fiat = usuario.balance_fiat;\n        if balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Descontar el monto fiat del monto del usuario.\n        usuario.balance_fiat -= monto_fiat;\n\n        //Generar transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroFiat,\n            usuario: usuario.clone(),\n            monto_fiat: Some(monto_fiat),\n            criptomoneda: None,\n            monto_criptomoneda: None,\n            cotizacion: None,\n            blockchain: None,\n            hash: None,\n            medio: Some(medio.clone()),\n        };\n\n        self.transacciones.push(transaccion);\n        Ok(())\n    }\n\n\n\n\n    //Estadísticas.\n    pub fn criptomoneda_mas_vendida(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea VentaCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de ventas asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más ventas).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n\n        /*EXPLANATION: \n        Inside the map closure:\n\n        (nombre, cantidad) destructures the reference: nombre is \u0026String, cantidad is \u0026u32\n        nombre.clone() creates an owned String from the \u0026String\n        *cantidad dereferences the \u0026u32 to get an owned u32\n         */\n    }\n\n    pub fn criptomoneda_mas_comprada(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea CompraCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::CompraCripto)\n            .for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de compras asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más compras).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n    }\n\n    pub fn crpitomoneda_mas_volumen_venta (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción VentaCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de venta).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    }\n\n\n    pub fn crpitomoneda_mas_volumen_compra (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t|t.tipo == TipoTransaccion::CompraCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción CompraCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de compra).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    } \n}\n\n\n#[cfg(test)]\nmod test {\n    use core::hash;\n\n    use super::*;\n\n    fn crear_plataforma() -\u003e PlataformaXYZ {\n        let mut plataforma = PlataformaXYZ::new();\n\n        //Crear usuarios.\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user2 = Usuario {\n            nombre: \"Rosita\".to_string(),\n            apellido: \"R\".to_string(),\n            email: \"emailRosita\".to_string(),\n            dni: 345,\n            identidad_validada: true,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        plataforma.registrar_usuario(user0);\n        plataforma.registrar_usuario(user1);\n        plataforma.registrar_usuario(user2);\n        plataforma.registrar_usuario(user3);\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        let litecoin_chain = Blockchain {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        let litecoin = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![litecoin_chain],\n        };\n\n        plataforma.registrar_criptomoneda(bitcoin);\n        plataforma.registrar_criptomoneda(ethereum);\n        plataforma.registrar_criptomoneda(litecoin);\n\n        plataforma\n    }\n\n\n    #[test]\n    fn test_ingresar_dinero() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Test with an user that is valid.\n        \n        //println!(\"Balance before: {}\", \u0026user0.balance_fiat);\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user0).is_ok());\n\n        //let usuario = plataforma.usuarios.get(\u0026user0.email);\n        //println!(\"From platform {}\", usuario.unwrap().balance_fiat); //Se modifica.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0.balance_fiat = updated_user.balance_fiat; // Synchronize user0 with the updated user\n\n        //println!(\"Balance after: {}\", user0.balance_fiat);\n        assert_eq!(user0.balance_fiat, 12000.0);\n\n\n        //Test with an user that is not valid.\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user3).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_comprar_determinada_moneda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { //Esta cripto sí está.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let pepecripto = Criptomoneda { //Esta cripto no.\n            nombre: \"PepeCripto\".to_string(),\n            prefijo: \"PC\".to_string(),\n            listado_blockchains: vec![],\n        };\n\n        //Compra de una cripto que existe desde un usario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Tiene la cripto.\n\n        //Compra de una cripto que no existe desde un usuario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026pepecripto).is_err()); //Ok.\n\n        //Compra de una cripto que sí existe desde un usuario que NO puede(user1, por el balance).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user1, \u0026bitcoin).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_vender_determinada_criptomeda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.01).is_ok());\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone();\n        assert_eq!(user0.balance_fiat, 8072.812); //Ok. Se le acreditó el balance fiat de su venta.\n    }\n\n    #[test]\n    fn test_retirar_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { //Blockchain válida.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let bitcoin_unvalid_chain = Blockchain { //Blockchain NO válida.\n            nombre: \"bit\".to_string(),\n            prefijo: \"b\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0).is_ok());\n\n        //let hash = plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0);\n        //println!(\"{}\", hash.unwrap()); \n\n\n        //Probar con una blockchain que no existe.\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_unvalid_chain, \u0026mut user0).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_recibir_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n        //Arranca user0 sin criptos. (HM len == 0).\n        //println!(\"Error: {:?}\",plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain) ); \n        assert!(plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain).is_ok()); //Ok.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Ok.\n    }\n\n    #[test]\n    fn test_retirar_fiat() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let medio = \u0026Medio::MercadoPago;\n\n        assert!(plataforma.retirar_fiat_por_determinado_medio(5000.0,\u0026mut user0, medio).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_fiat, 5000.0); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 100000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Voy a usar a user0 para haga todas las transacciones.\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n        \n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026ethereum);\n        \n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n\n        //assert_eq!(user0.balance_criptomoneda.len(), 2);\n        //println!(\"{}\", plataforma.transacciones.len());\n        assert_eq!(plataforma.criptomoneda_mas_comprada(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_compra(), Some((\"Ethereum\".to_string(), 55.24861878453038))); //Ok.\n\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026ethereum, 0.0001);\n\n        assert_eq!(plataforma.criptomoneda_mas_vendida(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_venta(), Some((\"Bitcoin\".to_string(), 0.0002))); //Ok.\n    }\n}\n \n","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp04","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05;","traces":[],"covered":0,"coverable":0},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej01.rs"],"content":"use serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n\n#[derive(Clone, Serialize, Deserialize, Debug)]\nenum Color {\n    ROJO,\n    VERDE, \n    AZUL,\n    AMARILLO,\n    BLANCO,\n    NEGRO,\n}\n#[derive(Clone)]\n#[derive(Serialize, Deserialize, Debug)]\nstruct Auto {\n    color: Color,\n    marca: String,\n    modelo: String,\n    precio_bruto: f64,\n    año: u32,\n}\n\n\nstruct ConsecionarioAuto {\n    nombre: String,\n    direccion: String,\n    x: u32,\n    autos: Vec\u003cAuto\u003e,\n    archivo_autos: PathBuf, //ruta del archivo JSON.\n}\n\n#[derive(Clone, Debug)]\nenum ErroresPersonalizados {\n    CapacidadExcedida(String),\n    ErrorArchivo(String),\n    AutoNoEncontrado(String),\n}\n\n\npub fn compare_colors(color1: \u0026Color, color2: \u0026Color) -\u003e bool {\n    match(color1, color2) {\n        (Color::AMARILLO, Color::AMARILLO) =\u003e true,\n        (Color::AZUL, Color::AZUL) =\u003e true,\n        (Color::VERDE, Color::VERDE) =\u003e true,\n        (Color::ROJO, Color::ROJO) =\u003e true,\n        (Color::NEGRO, Color::NEGRO) =\u003e true,\n        (Color::BLANCO, Color::BLANCO) =\u003e true,\n        _ =\u003e false, //If the variants are different, they are not equal\n    }\n}\n\npub fn compare (auto1: \u0026Auto, auto2: \u0026Auto) -\u003e bool {\n    auto1.año == auto2.año \u0026\u0026\n    auto1.marca == auto2.marca \u0026\u0026\n    auto1.modelo == auto2.modelo \u0026\u0026\n    auto1.precio_bruto == auto2.precio_bruto \u0026\u0026\n    compare_colors(\u0026auto1.color, \u0026auto2.color)\n\n}\n\nimpl ConsecionarioAuto {\n    fn new(nombre: String, direccion: String, x: u32, archivo_autos: String) -\u003e ConsecionarioAuto {\n        let path = PathBuf::from(archivo_autos);\n        let mut concesionario =  ConsecionarioAuto {\n            nombre: nombre,\n            direccion: direccion,\n            x: x,\n            autos: Vec::new(),\n            archivo_autos: path,\n        };\n\n        concesionario\n    }\n\n    pub fn cargar_al_archivo(\u0026mut self, auto: \u0026Auto) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Abrir el archivo en modo escritura.\n        let mut archivo = match File::create(self.archivo_autos.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo en modo escritura.\")))?,\n            Ok(arch) =\u003e arch,            \n        };\n\n        let auto_serializado = serde_json::to_string(\u0026auto).unwrap();\n        match archivo.write(\u0026auto_serializado.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo.\")))?,\n            Ok(_) =\u003e Ok(()),  \n        }\n    }\n\n    fn agregar_auto(\u0026mut self, auto: \u0026Auto) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        if self.autos.len()+1 \u003c= self.x.try_into().unwrap() {\n            self.autos.push(auto.clone());\n\n            //Lo agrego a mi archivo JSON.\n            self.cargar_al_archivo(\u0026auto)?; //Está bien dejar que el error se propague acá?\n            \n\n            \n            Ok(())\n        } else {\n            Err(ErroresPersonalizados::CapacidadExcedida(format!(\"No se pueden agrgar más autos. Concesionario lleno :/\")))\n        }\n    }\n\n    fn eliminar_auto(\u0026mut self, auto: \u0026Auto) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Find the car I want to delete in the vec.\n        let mut index_car_delete= -1;\n        for i in 0.. self.autos.len() {\n            if compare(\u0026self.autos[i], \u0026auto) {\n                index_car_delete= i as i32;\n                break;\n            }  \n        }\n\n        //Delete the car.\n        if index_car_delete != -1 {  //If I found the car to delete.\n            // Delete the car from the JSON file.\n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_autos)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n            self.autos.remove(index_car_delete as usize);\n\n            //Write the updated vector back to the file.\n            let writer = std::io::BufWriter::new(\u0026file); //Crea un nuevo BufWriter.\n\n            serde_json::to_writer(writer, \u0026self.autos)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo: {}\", e)))?;\n            Ok(())\n        } else {\n            Err(ErroresPersonalizados::AutoNoEncontrado(format!(\"El auto que desea eliminar no fue encontrado.\")))\n        }\n    }\n\n    fn buscar_auto(\u0026self, auto: \u0026Auto) -\u003e Option\u003c\u0026Auto\u003e {\n        for car in self.autos.iter() {\n            if compare(\u0026car, \u0026auto) {\n                return Some(car);\n            }\n        }\n        None //If I didn't find it, return nothing (None).\n    }\n}\n\nimpl Auto {\n    fn new(marca: String, modelo: String, precio_bruto: f64, año: u32, color: Color ) -\u003e Auto {\n        Auto {\n            marca,\n            modelo,\n            precio_bruto,\n            año,\n            color,\n        }\n    }\n\n    fn calcular_precio(\u0026self) -\u003e f64 {\n        let mut precio_final= self.precio_bruto;\n\n        //Check first condition (color).\n        let es_primario = match self.color {\n            Color::AMARILLO | Color::AZUL | Color::ROJO =\u003e true,\n            _ =\u003e false,\n        };\n\n        if es_primario {\n            precio_final += (self.precio_bruto * 25.0)/100.0; //+25%.\n        } else {\n            precio_final -= (10.0*self.precio_bruto)/100.0; //-10%.\n        }\n\n        //Check second condition (brand).\n        if self.marca == \"BMW\" {\n            precio_final += (self.precio_bruto * 15.0)/100.0; //+15%.\n        }\n\n        //Check third condition (year).\n        if self.año \u003c 2000 {\n            precio_final -= (self.precio_bruto * 5.0)/100.0; //-5%.\n        }\n\n        precio_final\n    }\n}\n\n#[cfg(test)]\nmod  test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_auto() {\n        let path = \"src/tp05/archivo_autos.txt\";\n\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3, String::from(path));\n\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n        let auto4= Auto::new(String::from(\"Ferrari\"), String::from(\"modelo R\"), 1000.0, 2015, Color::ROJO);\n\n        \n        assert!(concesionario.agregar_auto(\u0026auto1).is_ok());\n        assert_eq!(concesionario.autos.len(), 1); //Added only 1 element.\n\n        //Fill all available space.\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.agregar_auto(\u0026auto3);\n        assert_eq!(concesionario.autos.len(), 3);\n\n        //Try to add one more.\n        match concesionario.agregar_auto(\u0026auto4) {\n            Ok(_) =\u003e println!(\"Auto agregado exitosamente.\"),\n            Err(ErroresPersonalizados::CapacidadExcedida(msg)) =\u003e println!(\"Error: {}\", msg),\n            Err(_) =\u003e println!(\"Error desconocido.\"),\n        }\n    }\n\n    #[test]\n    fn testear_eliminar_auto() {\n        let path = \"src/tp05/archivo_autos.txt\";\n\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3,  String::from(path));\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n\n        //First I try to delete a car from an empty list.\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //Passed. Nothing changed.\n\n        //Add cars to delete.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 0); //yes.\n\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        concesionario.eliminar_auto(\u0026auto1);\n        assert_eq!(concesionario.autos.len(), 1);\n    }\n    \n    #[test]\n    fn testear_buscar_auto() {\n        let path = \"src/tp05/archivo_autos.txt\";\n\n        let mut concesionario= ConsecionarioAuto::new(String::from(\"Juli cars :D\"), String::from(\"Argentina\"), 3, String::from(path));\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo J\"), 1000.0, 2015, Color::AMARILLO);\n        let auto2= Auto::new(String::from(\"Honda\"), String::from(\"modelo H\"), 1000.0, 2015, Color::NEGRO);\n        let auto3= Auto::new(String::from(\"Cronos\"), String::from(\"modelo X\"), 1000.0, 2015, Color::ROJO);\n\n\n        //Try to find a car in an empty list.\n        assert!(concesionario.buscar_auto(\u0026auto1).is_none());\n\n        //Find a car that exists.\n        concesionario.agregar_auto(\u0026auto1);\n        concesionario.agregar_auto(\u0026auto2);\n        assert!(concesionario.buscar_auto(\u0026auto2).is_some());\n\n        //Find a car that doesn't exist.\n        assert!(concesionario.buscar_auto(\u0026auto3).is_none());\n    }\n\n    #[test]\n    fn testear_calcular_precio() {\n        //Test brand (and not primary color).\n        let auto1= Auto::new(String::from(\"BMW\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n        let auto2= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::BLANCO);\n\n        assert_eq!(auto1.calcular_precio(), 1050.0); \n        assert_eq!(auto2.calcular_precio(), 900.0);\n\n        //Test if primary color.\n        let auto3= Auto::new(String::from(\"Toyota\"), String::from(\"modelo 1\"), 1000.0, 2004, Color::AMARILLO);\n        assert_eq!(auto3.calcular_precio(), 1250.0);\n        \n        //Test year (withouth primary color).\n        let auto4= Auto::new(String::from(\"Cronos\"), String::from(\"modelo 1\"), 1000.0, 1999, Color::BLANCO);\n        assert_eq!(auto4.calcular_precio(), 850.0);\n    }\n\n}","traces":[{"line":45,"address":[2989808,2989862],"length":1,"stats":{"Line":1}},{"line":46,"address":[2989864,2989818],"length":1,"stats":{"Line":1}},{"line":57,"address":[2990016],"length":1,"stats":{"Line":2}},{"line":58,"address":[2990047,2990039],"length":1,"stats":{"Line":3}},{"line":59,"address":[2990063],"length":1,"stats":{"Line":2}},{"line":60,"address":[2990083],"length":1,"stats":{"Line":1}},{"line":61,"address":[2990111],"length":1,"stats":{"Line":1}},{"line":62,"address":[2990134],"length":1,"stats":{"Line":2}},{"line":67,"address":[2990692,2990623,2990176],"length":1,"stats":{"Line":1}},{"line":68,"address":[2990227],"length":1,"stats":{"Line":1}},{"line":73,"address":[2990383],"length":1,"stats":{"Line":2}},{"line":80,"address":[2991937,2990736,2991943],"length":1,"stats":{"Line":2}},{"line":82,"address":[2990766],"length":1,"stats":{"Line":2}},{"line":83,"address":[2990807,2991956,2990881],"length":1,"stats":{"Line":0}},{"line":84,"address":[2990843],"length":1,"stats":{"Line":2}},{"line":87,"address":[2990871,2991224],"length":1,"stats":{"Line":4}},{"line":88,"address":[2991262,2991330],"length":1,"stats":{"Line":2}},{"line":89,"address":[2991886,2991426,2991502],"length":1,"stats":{"Line":0}},{"line":90,"address":[2991473],"length":1,"stats":{"Line":2}},{"line":94,"address":[2991984],"length":1,"stats":{"Line":1}},{"line":95,"address":[2992289,2992523,2992027],"length":1,"stats":{"Line":4}},{"line":96,"address":[2992296],"length":1,"stats":{"Line":1}},{"line":99,"address":[2992428,2992347],"length":1,"stats":{"Line":1}},{"line":103,"address":[2992516],"length":1,"stats":{"Line":1}},{"line":105,"address":[2992113],"length":1,"stats":{"Line":1}},{"line":109,"address":[2993471,2992528,2993465],"length":1,"stats":{"Line":1}},{"line":111,"address":[2992571],"length":1,"stats":{"Line":1}},{"line":112,"address":[2992611,2992579],"length":1,"stats":{"Line":2}},{"line":113,"address":[2992666],"length":1,"stats":{"Line":1}},{"line":114,"address":[2992718],"length":1,"stats":{"Line":1}},{"line":120,"address":[2992701,2992900],"length":1,"stats":{"Line":2}},{"line":122,"address":[2992995,2992905,2993113],"length":1,"stats":{"Line":2}},{"line":125,"address":[2992957],"length":1,"stats":{"Line":1}},{"line":126,"address":[2993058,2992974],"length":1,"stats":{"Line":1}},{"line":128,"address":[2993155,2993235],"length":1,"stats":{"Line":2}},{"line":131,"address":[2993255],"length":1,"stats":{"Line":1}},{"line":133,"address":[2993327,2993267,2993399],"length":1,"stats":{"Line":2}},{"line":134,"address":[2993367,2993304],"length":1,"stats":{"Line":1}},{"line":135,"address":[2993426],"length":1,"stats":{"Line":1}},{"line":137,"address":[2992724],"length":1,"stats":{"Line":1}},{"line":141,"address":[2993488],"length":1,"stats":{"Line":1}},{"line":142,"address":[2993542,2993501],"length":1,"stats":{"Line":2}},{"line":143,"address":[2993595],"length":1,"stats":{"Line":1}},{"line":144,"address":[2993634],"length":1,"stats":{"Line":1}},{"line":147,"address":[2993615],"length":1,"stats":{"Line":1}},{"line":152,"address":[2993648],"length":1,"stats":{"Line":1}},{"line":162,"address":[2993728],"length":1,"stats":{"Line":1}},{"line":163,"address":[2993741],"length":1,"stats":{"Line":1}},{"line":166,"address":[2993752],"length":1,"stats":{"Line":1}},{"line":167,"address":[2993792],"length":1,"stats":{"Line":1}},{"line":168,"address":[2993785],"length":1,"stats":{"Line":1}},{"line":171,"address":[2993797,2993849],"length":1,"stats":{"Line":2}},{"line":172,"address":[2993855],"length":1,"stats":{"Line":1}},{"line":174,"address":[2993808],"length":1,"stats":{"Line":1}},{"line":178,"address":[2993896,2993968],"length":1,"stats":{"Line":2}},{"line":179,"address":[2993931],"length":1,"stats":{"Line":1}},{"line":183,"address":[2993916,2994026],"length":1,"stats":{"Line":2}},{"line":184,"address":[2993985],"length":1,"stats":{"Line":1}},{"line":187,"address":[2993970],"length":1,"stats":{"Line":1}}],"covered":57,"coverable":59},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej02.rs"],"content":"use serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n\n\n#[derive(Clone, Serialize, Deserialize)]\nenum Genero {\n    ROCK,\n    POP,\n    JAZZ,\n    RAP,\n    OTROS,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Cancion {\n    titulo: String,\n    artista: String,\n    genero: Genero,\n}\n\nstruct PlayList {\n    nombre: String,\n    canciones: Vec\u003cCancion\u003e,\n    archivo_canciones: PathBuf,\n}\n\nenum ErroresPersonalizados {\n    CancionNoEncontrada(String),\n    ErrorArchivo(String),\n    PosicionFueraDeRango,\n}\n\nimpl Cancion {\n    fn new(titulo: String, artista: String, genero: Genero) -\u003e Cancion {\n        Cancion {\n            titulo,\n            artista,\n            genero,\n        }\n    }\n}\n\npub fn compare_genre(genero1: \u0026Genero, genero2: \u0026Genero) -\u003e bool {\n    match (genero1, genero2) {\n        (Genero::JAZZ, Genero::JAZZ) =\u003e true,\n        (Genero::ROCK, Genero::ROCK) =\u003e true,\n        (Genero::RAP, Genero::RAP) =\u003e true,\n        (Genero::POP, Genero::POP) =\u003e true,\n        (Genero::OTROS, Genero::OTROS) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare (cancion1: \u0026Cancion, cancion2: \u0026Cancion) -\u003e bool {\n    cancion1.artista == cancion2.artista \u0026\u0026\n    cancion1.titulo == cancion2.titulo \u0026\u0026\n    compare_genre(\u0026cancion1.genero, \u0026cancion2.genero)\n\n}\n\nimpl PlayList {\n    fn new(nombre: String, archivo_canciones: String) -\u003e PlayList {\n        let path = PathBuf::from(archivo_canciones);\n        PlayList {\n            nombre,\n            canciones: Vec::new(),\n            archivo_canciones: path,\n        }\n    }\n\n    pub fn cargar_al_archivo(\u0026mut self, cancion: \u0026Cancion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Abrir el archivo en modo escritura.\n        let mut archivo = match File::create(self.archivo_canciones.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Problema al abrir el archivo\")))?,\n            Ok(arch) =\u003e arch,            \n        };\n\n        let cancion_serializada = serde_json::to_string(\u0026cancion).unwrap();\n        match archivo.write(\u0026cancion_serializada.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo(format!(\"Problema al escribir en el archivo\")))?,\n            Ok(_) =\u003e Ok(()),  \n        }\n    }\n\n    fn agregar_cancion(\u0026mut self, cancion: \u0026Cancion) {\n        self.canciones.push(cancion.clone());\n        self.cargar_al_archivo(cancion); //Qué hago con el unused result?\n\n    }\n\n    fn eliminar_cancion(\u0026mut self, cancion: \u0026Cancion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Find the song I want to delete in the vec.\n        let mut index_song_delete= -1;\n        for i in 0.. self.canciones.len() {\n            if compare(\u0026self.canciones[i], \u0026cancion) {\n                index_song_delete= i as i32;\n                break;\n            }  \n        }\n        //Delete the car. \n        if index_song_delete != -1 { //If I found the car to delete.\n\n            let file = std::fs::OpenOptions::new() //Me armo mi file nuevo.\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_canciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n            self.canciones.remove(index_song_delete as usize);\n\n            let writer = std::io::BufWriter::new(\u0026file); //Crea un nuevo BufWriter.\n\n            serde_json::to_writer(writer, \u0026self.canciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo: {}\", e)))?;\n        \n            Ok(())\n        } else {\n            Err(ErroresPersonalizados::CancionNoEncontrada(format!(\"NO se encontró la canción que desea eliminar.\")))\n        }\n    }\n\n    fn mover_cancion(\u0026mut self, cancion: \u0026Cancion, posicion_nueva: u32) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        if posicion_nueva \u003c self.canciones.len() as u32 {\n\n            //Search song in the playlist.\n            let mut song_index:i32= -1;\n            for i in 0..self.canciones.len() {\n                if compare(\u0026self.canciones[i], \u0026cancion) {\n                    song_index= i as i32;\n                    break;\n                }\n            }\n\n            if song_index != -1 { //If I found the song.\n                //Move the song to the new position.\n                let song = self.canciones.remove(song_index as usize);\n                self.canciones.insert(posicion_nueva as usize, song);\n\n                let file = std::fs::OpenOptions::new() //Me armo mi file nuevo.\n                    .read(true)\n                    .write(true)\n                    .open(\u0026self.archivo_canciones)\n                    .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n                \n                let writer = std::io::BufWriter::new(\u0026file); //Crea un nuevo BufWriter.\n\n                serde_json::to_writer(writer, \u0026self.canciones)\n                    .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al escribir en el archivo: {}\", e)))?;\n\n                Ok(())\n            } else {\n                Err(ErroresPersonalizados::CancionNoEncontrada(format!(\"No se encontró la canción que desea mover.\")))\n            }\n\n        } else {\n            Err(ErroresPersonalizados::PosicionFueraDeRango)\n        }\n    }\n\n    fn buscar_cancion_por_nombre(\u0026self, nombre: String) -\u003e Option\u003cCancion\u003e {\n        for song in self.canciones.iter() {\n            if (song.titulo == nombre) {\n                return Some(song.clone());\n            }\n        }\n        None\n    }\n\n    fn obtener_canciones_por_genero(\u0026self, genero: Genero) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_genero= Vec::new();\n\n        for song in self.canciones.iter() {\n            if compare_genre(\u0026song.genero, \u0026genero) {\n                canciones_genero.push(song.clone());\n            }\n        }\n        canciones_genero\n    }\n\n    fn obtener_canciones_por_artista(\u0026self, artista: String) -\u003e Vec\u003cCancion\u003e {\n        let mut canciones_artista= Vec::new();\n\n        for song in self.canciones.iter() {\n            if song.artista == artista {\n                canciones_artista.push(song.clone());\n            }\n        }\n\n        canciones_artista\n    }\n\n    fn modificar_titulo_playlist(\u0026mut self, titulo_nuevo: String) {\n        self.nombre= titulo_nuevo;\n    }\n\n    fn eliminar_todas_las_canciones(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        self.canciones.clear();\n\n        let mut archivo = OpenOptions::new() \n            .write(true)\n            .read(true)\n            .open(self.archivo_canciones.clone())\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?;\n\n        archivo.write_all(b\"[]\").map_err(|e| ErroresPersonalizados::ErrorArchivo(format!(\"Error al abrir el archivo: {}\", e)))?; //b\"[]\" to write an empty JSON array to the file. Ask if okay???\n\n        Ok(())\n    }\n }\n\n\n #[cfg(test)]\n\n mod test {\n    use super::*;\n\n    #[test]\n    fn testear_agregar_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        assert_eq!(playlist.canciones.len(), 3);\n    }\n\n    #[test]\n    fn testear_eliminar_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        \n        playlist.eliminar_cancion(\u0026cancion1); //Delete just 1 song.\n        assert_eq!(playlist.canciones.len(), 1);\n\n        //Try to delete a song that is not in the playlist.\n        playlist.eliminar_cancion(\u0026cancion3);\n        assert_eq!(playlist.canciones.len(), 1); //lenght shouldn't change.\n    }\n\n    #[test]\n    fn testear_buscar_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n        \n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n\n        playlist.agregar_cancion(\u0026cancion1);\n\n        //Search for a song that is in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion1\")).is_some());\n\n        //Search for a song that is not in the playlist.\n        assert!(playlist.buscar_cancion_por_nombre(String::from(\"Cancion10\")).is_none());\n    }\n\n    #[test]\n    fn testear_eliminar_canciones() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n\n        playlist.agregar_cancion(\u0026cancion1);\n        playlist.agregar_cancion(\u0026cancion2);\n        playlist.agregar_cancion(\u0026cancion3);\n\n        playlist.eliminar_todas_las_canciones();\n        assert_eq!(playlist.canciones.len(), 0);\n    }\n\n    #[test]\n    fn testear_mover_cancion() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); //Originally in pos 0 (in playlist).\n        playlist.agregar_cancion(\u0026cancion2); //Originally in pos 1 (in playlist).\n        playlist.agregar_cancion(\u0026cancion3); //Originally in pos 2 (in playlist).\n\n        //Check that.\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\"));\n\n        //Move a song that is in the playlist.\n        playlist.mover_cancion(\u0026cancion2, 2);\n        assert_eq!(playlist.canciones[2].titulo, String::from(\"Cancion2\"));\n\n        //Move a song that is not in the playlist.\n        playlist.mover_cancion(\u0026cancion4, 0);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n\n        //Move a song that is in the playlist to a non existing position.\n        playlist.mover_cancion(\u0026cancion1, 3);\n        assert_eq!(playlist.canciones[0].titulo, String::from(\"Cancion1\")); //It shouldn't change.\n    }\n\n    #[test]\n    fn testear_cambiar_nombre_playlist() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        //Check that.\n        assert_eq!(playlist.nombre, String::from(\"Chill music\"));\n        \n        //Change the name.\n        playlist.modificar_titulo_playlist(String::from(\"Nombre nuevo\"));\n        assert_eq!(playlist.nombre, String::from(\"Nombre nuevo\"));\n    }\n\n    #[test]\n    fn testear_canciones_mismo_genero() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 jazz songs.\n        let mut jazz_songs: Vec\u003cCancion\u003e;\n        jazz_songs= playlist.obtener_canciones_por_genero(Genero::JAZZ);\n        assert_eq!(jazz_songs.len(), 2);\n\n        //Try with a genre that is not in the playlist.\n        let mut pop_songs= playlist.obtener_canciones_por_genero(Genero::POP);\n        assert_eq!(pop_songs.len(), 0);\n    }\n\n    #[test]\n    fn testear_canciones_mismo_artista() {\n        let path = \"src/tp05/archivo_canciones.txt\";\n\n        let mut playlist= PlayList::new(String::from(\"Chill music\"), String::from(path));\n        let cancion1= Cancion::new(String::from(\"Cancion1\"), String::from(\"pepe\"), Genero::JAZZ);\n        let cancion2= Cancion::new(String::from(\"Cancion2\"), String::from(\"juancito\"), Genero::JAZZ);\n        let cancion3= Cancion::new(String::from(\"Cancion3\"), String::from(\"pepa\"), Genero::OTROS);\n        let cancion4= Cancion::new(String::from(\"Cancion4\"), String::from(\"pepa\"), Genero::ROCK);\n\n        playlist.agregar_cancion(\u0026cancion1); \n        playlist.agregar_cancion(\u0026cancion2); \n        playlist.agregar_cancion(\u0026cancion3); \n        playlist.agregar_cancion(\u0026cancion4);\n\n        //2 pepa songs.\n        let mut pepa_songs: Vec\u003cCancion\u003e;\n        pepa_songs= playlist.obtener_canciones_por_artista(String::from(\"pepa\"));\n        assert_eq!(pepa_songs.len(), 2);\n\n        //Try with an artist that is not in the playlist.\n        let mut titi_songs= playlist.obtener_canciones_por_artista(String::from(\"titi\"));\n        assert_eq!(titi_songs.len(), 0);\n    }\n }","traces":[{"line":40,"address":[2751984],"length":1,"stats":{"Line":1}},{"line":49,"address":[2752048,2752102],"length":1,"stats":{"Line":1}},{"line":50,"address":[2752058,2752104],"length":1,"stats":{"Line":2}},{"line":60,"address":[2752224],"length":1,"stats":{"Line":1}},{"line":61,"address":[2752247,2752264],"length":1,"stats":{"Line":2}},{"line":62,"address":[2752280],"length":1,"stats":{"Line":1}},{"line":63,"address":[2752300],"length":1,"stats":{"Line":1}},{"line":68,"address":[2752663,2752688,2752336],"length":1,"stats":{"Line":1}},{"line":69,"address":[2752371],"length":1,"stats":{"Line":1}},{"line":72,"address":[2752475],"length":1,"stats":{"Line":1}},{"line":77,"address":[2753921,2753927,2752720],"length":1,"stats":{"Line":1}},{"line":79,"address":[2752750],"length":1,"stats":{"Line":2}},{"line":80,"address":[2753940,2752865,2752791],"length":1,"stats":{"Line":0}},{"line":81,"address":[2752827],"length":1,"stats":{"Line":2}},{"line":84,"address":[2752855,2753208],"length":1,"stats":{"Line":3}},{"line":85,"address":[2753314,2753246],"length":1,"stats":{"Line":4}},{"line":86,"address":[2753410,2753486,2753870],"length":1,"stats":{"Line":0}},{"line":87,"address":[2753457],"length":1,"stats":{"Line":3}},{"line":91,"address":[2753968],"length":1,"stats":{"Line":1}},{"line":92,"address":[2753998],"length":1,"stats":{"Line":1}},{"line":93,"address":[2754049],"length":1,"stats":{"Line":2}},{"line":97,"address":[2755012,2754080,2755018],"length":1,"stats":{"Line":1}},{"line":99,"address":[2754123],"length":1,"stats":{"Line":1}},{"line":100,"address":[2754163,2754131],"length":1,"stats":{"Line":2}},{"line":101,"address":[2754218],"length":1,"stats":{"Line":1}},{"line":102,"address":[2754270],"length":1,"stats":{"Line":1}},{"line":107,"address":[2754253,2754452],"length":1,"stats":{"Line":2}},{"line":109,"address":[2754547,2754457,2754662],"length":1,"stats":{"Line":2}},{"line":112,"address":[2754509],"length":1,"stats":{"Line":1}},{"line":113,"address":[2666160,2666195],"length":1,"stats":{"Line":1}},{"line":115,"address":[2754784,2754704],"length":1,"stats":{"Line":2}},{"line":117,"address":[2754804],"length":1,"stats":{"Line":1}},{"line":119,"address":[2754874,2754946,2754816],"length":1,"stats":{"Line":2}},{"line":120,"address":[2666451,2666416],"length":1,"stats":{"Line":1}},{"line":122,"address":[2754973],"length":1,"stats":{"Line":1}},{"line":124,"address":[2754276],"length":1,"stats":{"Line":1}},{"line":128,"address":[2756132,2756126,2755040],"length":1,"stats":{"Line":1}},{"line":129,"address":[2755094,2755175],"length":1,"stats":{"Line":2}},{"line":132,"address":[2755182],"length":1,"stats":{"Line":1}},{"line":133,"address":[2755190,2755237],"length":1,"stats":{"Line":2}},{"line":134,"address":[2755292],"length":1,"stats":{"Line":1}},{"line":135,"address":[2755344],"length":1,"stats":{"Line":1}},{"line":140,"address":[2755327,2755526],"length":1,"stats":{"Line":2}},{"line":142,"address":[2755536],"length":1,"stats":{"Line":1}},{"line":143,"address":[2755571],"length":1,"stats":{"Line":1}},{"line":145,"address":[2755686,2755804,2755596],"length":1,"stats":{"Line":2}},{"line":148,"address":[2755648],"length":1,"stats":{"Line":1}},{"line":149,"address":[2666672,2666707],"length":1,"stats":{"Line":1}},{"line":152,"address":[2755866],"length":1,"stats":{"Line":1}},{"line":154,"address":[2756054,2755982,2755922],"length":1,"stats":{"Line":2}},{"line":155,"address":[2756022,2755959],"length":1,"stats":{"Line":1}},{"line":157,"address":[2756081],"length":1,"stats":{"Line":1}},{"line":159,"address":[2755350],"length":1,"stats":{"Line":1}},{"line":163,"address":[2755116],"length":1,"stats":{"Line":1}},{"line":167,"address":[2756160,2756537],"length":1,"stats":{"Line":1}},{"line":168,"address":[2756203,2756275],"length":1,"stats":{"Line":2}},{"line":169,"address":[2756416,2756473],"length":1,"stats":{"Line":2}},{"line":170,"address":[2756494],"length":1,"stats":{"Line":1}},{"line":173,"address":[2756437],"length":1,"stats":{"Line":1}},{"line":176,"address":[2756972,2756966,2756560],"length":1,"stats":{"Line":1}},{"line":177,"address":[2756601],"length":1,"stats":{"Line":1}},{"line":179,"address":[2756611,2756679],"length":1,"stats":{"Line":2}},{"line":180,"address":[2756905,2756834],"length":1,"stats":{"Line":2}},{"line":181,"address":[2756927],"length":1,"stats":{"Line":1}},{"line":184,"address":[2756864],"length":1,"stats":{"Line":1}},{"line":187,"address":[2757448,2756992],"length":1,"stats":{"Line":1}},{"line":188,"address":[2757032],"length":1,"stats":{"Line":1}},{"line":190,"address":[2757085,2757150],"length":1,"stats":{"Line":2}},{"line":191,"address":[2757310,2757387],"length":1,"stats":{"Line":2}},{"line":192,"address":[2757409],"length":1,"stats":{"Line":1}},{"line":196,"address":[2757335],"length":1,"stats":{"Line":1}},{"line":199,"address":[2757472,2757532],"length":1,"stats":{"Line":1}},{"line":200,"address":[2757567,2757490],"length":1,"stats":{"Line":2}},{"line":203,"address":[2758148,2758142,2757600],"length":1,"stats":{"Line":1}},{"line":204,"address":[2757638],"length":1,"stats":{"Line":1}},{"line":206,"address":[2757756,2757853,2757647],"length":1,"stats":{"Line":2}},{"line":209,"address":[2757701],"length":1,"stats":{"Line":1}},{"line":210,"address":[2667184,2667219],"length":1,"stats":{"Line":1}},{"line":212,"address":[2667475,2667440],"length":1,"stats":{"Line":2}},{"line":214,"address":[2758098],"length":1,"stats":{"Line":1}}],"covered":78,"coverable":80},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej03.rs"],"content":"use std::{collections::VecDeque, path::PathBuf};\nuse crate::tp03::ej03::Fecha;\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\n\n\n#[derive(Clone, Serialize, Deserialize)]\nenum TipoAnimal {\n    PERRO,\n    GATO,\n    CABALLO,\n    OTROS,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Veterinaria {\n    nombre: String,\n    direccion: String,\n    id: i32,\n    atenciones: VecDeque\u003cAtencion\u003e,\n    atenciones_realizadas: Vec\u003cAtencion\u003e,\n    archivo_atenciones: PathBuf,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Atencion {\n    mascota: Mascota,\n    diagnostico_final: String,\n    tratamiento: String,\n    fecha: Option\u003cFecha\u003e,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Mascota {\n    nombre: String,\n    edad: String,\n    tipo: TipoAnimal,\n    dueño: Dueño,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Dueño {\n    nombre: String,\n    direccion: String,\n    telefono: u32,\n}\n\npub fn compare_owners(owner1: \u0026Dueño, owner2: \u0026Dueño) -\u003e bool {\n    owner1.direccion == owner2.direccion \u0026\u0026\n    owner1.nombre == owner2.nombre \u0026\u0026\n    owner1.telefono == owner2.telefono\n}\n\npub fn compare_type(type1: \u0026TipoAnimal, type2: \u0026TipoAnimal)  -\u003e bool{\n    match (type1, type2) {\n        (TipoAnimal::CABALLO, TipoAnimal::CABALLO) =\u003e true,\n        (TipoAnimal::PERRO, TipoAnimal::PERRO) =\u003e true,\n        (TipoAnimal::GATO, TipoAnimal::GATO) =\u003e true,\n        (TipoAnimal::OTROS, TipoAnimal::OTROS) =\u003e true,\n        _ =\u003e false, \n    }\n}\n\npub fn compare_pets (mascota1: \u0026Mascota, mascota2: \u0026Mascota) -\u003e bool {\n    compare_owners(\u0026mascota1.dueño, \u0026mascota2.dueño) \u0026\u0026\n    mascota1.edad == mascota2.edad \u0026\u0026\n    mascota1.nombre == mascota2.nombre \u0026\u0026\n    compare_type(\u0026mascota1.tipo, \u0026mascota2.tipo)\n}\n\nfn compare_fecha(fecha1: \u0026Option\u003cFecha\u003e, fecha2: \u0026Option\u003cFecha\u003e) -\u003e bool {\n    match (fecha1, fecha2) {\n        (Some(f1), Some(f2)) =\u003e f1.dia == f2.dia \u0026\u0026 f1.mes == f2.mes \u0026\u0026 f1.año == f2.año,\n        (None, None) =\u003e true, // Ambas son None → consideradas iguales\n        _ =\u003e false,           // Una tiene valor y la otra no → distintas\n    }\n}\n\n\n\npub fn compare_atencion(atencion1: \u0026Atencion, atencion2: \u0026Atencion) -\u003e bool {\n    atencion1.diagnostico_final == atencion2.diagnostico_final \u0026\u0026\n    compare_fecha(\u0026atencion1.fecha, \u0026atencion2.fecha) \u0026\u0026\n    atencion1.tratamiento == atencion2.tratamiento \u0026\u0026\n    compare_pets(\u0026atencion1.mascota, \u0026atencion2.mascota)\n}\n\n\nenum ErroresPersonalizados {\n    ErrorArchivo,\n    MascotaNoEncontrada,\n    AtencionNoEncontrada,\n}\n\nimpl Veterinaria {\n    fn new(nombre: String, direccion: String, id: i32, archivo_atenciones: String) -\u003e Veterinaria {\n        let path = PathBuf::from(archivo_atenciones);\n        Veterinaria {\n            nombre,\n            direccion,\n            id,\n            atenciones: VecDeque::new(),\n            atenciones_realizadas: Vec::new(),\n            archivo_atenciones: path,\n        }\n    }\n\n    pub fn cargar_al_archivo(\u0026mut self, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut archivo: File = match File::create(self.archivo_atenciones.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        let atencion_serializada = serde_json::to_string(\u0026atencion).unwrap();\n        match archivo.write(\u0026atencion_serializada.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(_) =\u003e Ok(()),\n        }\n    }\n\n    pub fn agregar_nueva_mascota(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion = Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_back(nueva_atencion.clone());\n        self.cargar_al_archivo(\u0026nueva_atencion.clone());\n    }\n\n    pub fn cargar_al_inicio_del_archivo(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let file = std::fs::OpenOptions::new()\n            .read(true)\n            .write(true)\n            .open(\u0026self.archivo_atenciones)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n    \n        let writer = std::io::BufWriter::new(\u0026file);\n        serde_json::to_writer(writer, \u0026self.atenciones)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n        \n        Ok(())\n    }\n\n    fn agregar_mascota_maxima_prioridad(\u0026mut self, mascota: Mascota, fecha: Option\u003cFecha\u003e) {\n        let nueva_atencion= Atencion {\n            mascota,\n            diagnostico_final: String::new(),\n            tratamiento: String::new(),\n            fecha,\n        };\n\n        self.atenciones.push_front(nueva_atencion.clone());\n        //Tendría que hacer que la atención nueva también esté en el archivo al inicio (para que persista con el orden en el que se encuentran los datos en la estructura).\n        self.cargar_al_inicio_del_archivo();\n    }\n\n    fn atender_mascota(\u0026mut self) -\u003e Option\u003cMascota\u003e{\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            return Some(mascota_atendida.mascota);\n            //Está bien modificar el archivo acá???\n            //Tendría que eliminar a la mascota de atenciones.\n            //Tendría que modificar mi atender mascota original para que lo agregue a atenciones realizadas, no?\n\n        } \n        None\n    }\n\n    fn eliminar_mascota(\u0026mut self, mascota: Mascota) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        //Find pet.\n        let mut indice_mascota_retirada:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_pets(\u0026self.atenciones[i].mascota,\u0026 mascota) {\n                indice_mascota_retirada= i as i32;\n                break;\n            }\n        }\n        //Delete pet.\n        if indice_mascota_retirada != -1 { //If I found the pet.\n            self.atenciones.remove(indice_mascota_retirada as usize);\n\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n\n        \n    }\n\n    fn registrar_atencion(\u0026mut self, tratamiento: String, diagnostico: String, fecha: Option\u003cFecha\u003e) {\n        if let Some(mascota_atendida)= self.atenciones.pop_front() {\n            let atencion_hecha= Atencion {\n                mascota: mascota_atendida.mascota,\n                diagnostico_final: diagnostico,\n                tratamiento: tratamiento,\n                fecha,\n            };\n\n            self.atenciones_realizadas.push(atencion_hecha);\n        };\n    }\n\n    fn buscar_atencion(\u0026self, nombre_mascota: String, nombre_dueño: String, telefono: u32) -\u003e Option\u003cAtencion\u003e {\n        for atencion in self.atenciones.iter() {\n            if atencion.mascota.nombre == nombre_mascota \u0026\u0026 atencion.mascota.dueño.nombre == nombre_dueño \u0026\u0026 atencion.mascota.dueño.telefono == telefono {\n                return Some(atencion.clone());\n            }\n        }\n        None\n    }\n\n    fn modificar_diagnostico(\u0026mut self, diagnostico_nuevo: String, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e{\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n        //Modify diagnostic.\n        if indice_atencion!= -1 { //If I found the attention.\n            self.atenciones[indice_atencion as usize].diagnostico_final = diagnostico_nuevo;\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n    }\n\n    fn modificar_fecha(\u0026mut self, fecha_nueva: Option\u003cFecha\u003e, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 { \n            self.atenciones[indice_atencion as usize].fecha = fecha_nueva;\n\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n    }\n\n    fn eliminar_atencion (\u0026mut self, atencion: \u0026Atencion) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Buscar la atención.\n        let mut indice_atencion:i32= -1;\n        for i in 0..self.atenciones.len() {\n            if compare_atencion(\u0026self.atenciones[i], \u0026atencion) {\n                indice_atencion= i as i32;\n                break;\n            }\n        }\n\n        if indice_atencion != -1 {\n            self.atenciones.remove(indice_atencion as usize);\n            //Modify the JSON file. \n            let file = std::fs::OpenOptions::new()\n                .read(true)\n                .write(true)\n                .open(\u0026self.archivo_atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            let writer = std::io::BufWriter::new(\u0026file);\n            serde_json::to_writer(writer, \u0026self.atenciones)\n                .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n            Ok(())\n        } else {\n            return Err(ErroresPersonalizados::MascotaNoEncontrada);\n        }\n    }\n}\n\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tp03::ej03::Fecha;\n\n    fn crear_dueño() -\u003e Dueño {\n        Dueño {\n            nombre: String::from(\"Juan Perez\"),\n            direccion: String::from(\"Calle Falsa 123\"),\n            telefono: 12345678,\n        }\n    }\n\n    fn crear_mascota(nombre: \u0026str, tipo: TipoAnimal) -\u003e Mascota {\n        Mascota {\n            nombre: String::from(nombre),\n            edad: String::from(\"5\"),\n            tipo,\n            dueño: crear_dueño(),\n        }\n    }\n\n    fn crear_fecha() -\u003e Option\u003cFecha\u003e {\n        Some(Fecha { dia: 1, mes: 1, año: 2024 })\n    }\n\n    #[test]\n    fn test_agregar_nueva_mascota() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 1\"), String::from(\"Arg\"), 1, String::from(path));\n        let mascota = crear_mascota(\"Firulais\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        assert_eq!(vet.atenciones.len(), 1);\n    }\n\n    #[test]\n    fn test_agregar_mascota_maxima_prioridad() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 2\"), String::from(\"Arg \"), 2, String::from(path));\n        let m1 = crear_mascota(\"Gato\", TipoAnimal::GATO);\n        let m2 = crear_mascota(\"Caballo\", TipoAnimal::CABALLO);\n\n        vet.agregar_nueva_mascota(m1.clone(), crear_fecha());\n        vet.agregar_mascota_maxima_prioridad(m2.clone(), crear_fecha());\n\n        assert_eq!(vet.atenciones.front().unwrap().mascota.nombre, \"Caballo\");\n    }\n\n    #[test]\n    fn test_atender_mascota() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 3\"), String::from(\"Arg\"), 3, String::from(path));\n        let mascota = crear_mascota(\"Toby\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), crear_fecha());\n        let atendido = vet.atender_mascota();\n\n        assert!(atendido.is_some());\n        assert_eq!(atendido.unwrap().nombre, \"Toby\");\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_registrar_atencion() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 4\"), String::from(\"Arg\"), 4 , String::from(path));\n        let mascota = crear_mascota(\"Rex\", TipoAnimal::PERRO);\n        let fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        vet.registrar_atencion(String::from(\"Antibióticos\"), String::from(\"Infección\"), fecha.clone());\n\n        assert_eq!(vet.atenciones.len(), 0);\n        assert_eq!(vet.atenciones_realizadas.len(), 1);\n        let atendida = \u0026vet.atenciones_realizadas[0];\n        assert_eq!(atendida.mascota.nombre, \"Rex\");\n        assert_eq!(atendida.tratamiento, \"Antibióticos\");\n        assert_eq!(atendida.diagnostico_final, \"Infección\");\n        assert!(compare_fecha(\u0026atendida.fecha, \u0026fecha));\n    }\n\n    #[test]\n    fn test_eliminar_mascota() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 5\"), String::from(\"Zoológico\"), 5, String::from(path));\n        let mascota = crear_mascota(\"Milo\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        assert_eq!(vet.atenciones.len(), 1);\n\n        vet.eliminar_mascota(mascota);\n        assert_eq!(vet.atenciones.len(), 0);\n    }\n\n    #[test]\n    fn test_buscar_atencion() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        let resultado = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert!(resultado.is_some());\n        assert_eq!(resultado.unwrap().mascota.nombre, \"Rocky\");\n    }\n\n    #[test]\n    fn test_modificar_diagnostico() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert!(atencion.is_some());\n        vet.modificar_diagnostico(\"Resfrio\".to_string(), \u0026atencion.unwrap());\n\n        let updated_atencion =  vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n        assert!(updated_atencion.is_some());\n        atencion = Some(updated_atencion.unwrap());\n\n        assert_eq!(atencion.unwrap().diagnostico_final, String::from(\"Resfrio\")); //Ok.\n    }\n\n    #[test]\n    fn test_modificar_fecha() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n        let mut fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), fecha);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        let fecha_nueva = Fecha {\n            año: 2025,\n            dia: 24,\n            mes: 12,\n        };\n        vet.modificar_fecha(Some(fecha_nueva), \u0026atencion.unwrap());\n\n        let updated_atencion =  vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n        assert!(updated_atencion.is_some());\n        atencion = Some(updated_atencion.unwrap());\n\n        assert_eq!(atencion.clone().unwrap().fecha.unwrap().año, 2025);\n        assert_eq!(atencion.clone().unwrap().fecha.unwrap().mes, 12);\n        assert_eq!(atencion.clone().unwrap().fecha.unwrap().dia, 24);\n    }\n\n    #[test]\n    fn test_eliminar_atencion() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n        let mut fecha = crear_fecha();\n\n        vet.agregar_nueva_mascota(mascota.clone(), fecha);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert_eq!(vet.atenciones.len(), 1); //Estado inicial.\n\n        vet.eliminar_atencion(\u0026atencion.unwrap());\n        assert_eq!(vet.atenciones.len(), 0); //Ok.\n    }\n\n    #[test]\n    fn test_agregar_mascota_maxima_prioridad_archivo() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 2\"), String::from(\"Arg \"), 2, String::from(path));\n        let m1 = crear_mascota(\"Gato\", TipoAnimal::GATO);\n        let m2 = crear_mascota(\"Caballo\", TipoAnimal::CABALLO);\n\n        vet.agregar_nueva_mascota(m1.clone(), crear_fecha());\n        vet.agregar_mascota_maxima_prioridad(m2.clone(), crear_fecha());\n\n        assert_eq!(vet.atenciones.front().unwrap().mascota.nombre, \"Caballo\");\n        //En el archivo aparece Caballo primero!. Ok.\n    }\n\n    #[test]\n    fn test_eliminar_mascota_nuevo() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 5\"), String::from(\"Zoológico\"), 5, String::from(path));\n        let mascota = crear_mascota(\"Milo\", TipoAnimal::GATO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), None);\n        assert_eq!(vet.atenciones.len(), 1);\n\n        assert!(vet.eliminar_mascota(mascota).is_ok());\n        assert_eq!(vet.atenciones.len(), 0);\n\n        let mascota2 = crear_mascota(\"Pepe\", TipoAnimal::GATO);\n        assert!(vet.eliminar_mascota(mascota2.clone()).is_err());\n\n    }\n\n    #[test]\n    fn eliminar_atencion_nuevo() {\n        let path = \"src/tp05/archivo_atenciones.txt\";\n        let mut vet = Veterinaria::new(String::from(\"Vet 6\"), String::from(\"BuscaVet\"), 6, String::from(path));\n        let mascota = crear_mascota(\"Rocky\", TipoAnimal::PERRO);\n        let mut fecha = crear_fecha();\n        let mascota2 = crear_mascota(\"Pepe\", TipoAnimal::PERRO);\n\n        vet.agregar_nueva_mascota(mascota.clone(), fecha);\n        let mut atencion = vet.buscar_atencion(String::from(\"Rocky\"), String::from(\"Juan Perez\"), 12345678);\n\n        assert_eq!(vet.atenciones.len(), 1); //Estado inicial.\n\n        assert!(vet.eliminar_atencion(\u0026atencion.unwrap()).is_ok());\n        assert_eq!(vet.atenciones.len(), 0); //Ok.\n\n        \n        /*let mut atencion2= Atencion { mascota2.clone(), String::from(\"fiebre\"), String::from(\"antibioticos\"), None}; //Por qué no me deja???\n        assert!(vet.eliminar_atencion(\u0026atencion2).is_err());*/\n\n    }\n}\n\n\n","traces":[{"line":53,"address":[3037792],"length":1,"stats":{"Line":1}},{"line":54,"address":[3037832,3037815],"length":1,"stats":{"Line":1}},{"line":55,"address":[3037848],"length":1,"stats":{"Line":1}},{"line":56,"address":[3037868],"length":1,"stats":{"Line":1}},{"line":59,"address":[3037958,3037904],"length":1,"stats":{"Line":1}},{"line":60,"address":[3037960,3037914],"length":1,"stats":{"Line":4}},{"line":69,"address":[3038064],"length":1,"stats":{"Line":1}},{"line":70,"address":[3038087,3038104],"length":1,"stats":{"Line":1}},{"line":71,"address":[3038120],"length":1,"stats":{"Line":1}},{"line":72,"address":[3038148],"length":1,"stats":{"Line":1}},{"line":73,"address":[3038168],"length":1,"stats":{"Line":1}},{"line":76,"address":[3038208],"length":1,"stats":{"Line":1}},{"line":77,"address":[3038218],"length":1,"stats":{"Line":2}},{"line":78,"address":[3038287,3038348],"length":1,"stats":{"Line":2}},{"line":80,"address":[3038341],"length":1,"stats":{"Line":0}},{"line":86,"address":[3038400],"length":1,"stats":{"Line":1}},{"line":87,"address":[3038440,3038423],"length":1,"stats":{"Line":1}},{"line":88,"address":[3038456],"length":1,"stats":{"Line":2}},{"line":89,"address":[3038490],"length":1,"stats":{"Line":3}},{"line":90,"address":[3038524],"length":1,"stats":{"Line":1}},{"line":101,"address":[3038560,3039179,3039110],"length":1,"stats":{"Line":1}},{"line":102,"address":[3038611],"length":1,"stats":{"Line":1}},{"line":107,"address":[3038767],"length":1,"stats":{"Line":2}},{"line":108,"address":[3038823],"length":1,"stats":{"Line":3}},{"line":113,"address":[3040153,3039216,3040147],"length":1,"stats":{"Line":1}},{"line":114,"address":[3039242],"length":1,"stats":{"Line":4}},{"line":115,"address":[3039397,3039283,3040170],"length":1,"stats":{"Line":0}},{"line":116,"address":[3039359],"length":1,"stats":{"Line":1}},{"line":119,"address":[3039592,3039387],"length":1,"stats":{"Line":6}},{"line":120,"address":[3039698,3039630],"length":1,"stats":{"Line":7}},{"line":121,"address":[3039900,3039796,3040092],"length":1,"stats":{"Line":0}},{"line":122,"address":[3039873],"length":1,"stats":{"Line":6}},{"line":126,"address":[3040793,3040192],"length":1,"stats":{"Line":3}},{"line":129,"address":[3040308],"length":1,"stats":{"Line":3}},{"line":130,"address":[3040363],"length":1,"stats":{"Line":1}},{"line":134,"address":[3040661,3040590],"length":1,"stats":{"Line":5}},{"line":135,"address":[3040696],"length":1,"stats":{"Line":4}},{"line":138,"address":[3041273,3041279,3040816],"length":1,"stats":{"Line":2}},{"line":139,"address":[3040927,3041002,3040836],"length":1,"stats":{"Line":4}},{"line":142,"address":[3040882],"length":1,"stats":{"Line":2}},{"line":143,"address":[2813353,2813344],"length":1,"stats":{"Line":2}},{"line":145,"address":[3041051],"length":1,"stats":{"Line":2}},{"line":146,"address":[3041104,3041256,3041206,3041145],"length":1,"stats":{"Line":4}},{"line":147,"address":[3041196,3041130],"length":1,"stats":{"Line":2}},{"line":149,"address":[3041224],"length":1,"stats":{"Line":2}},{"line":152,"address":[3041814,3041296],"length":1,"stats":{"Line":2}},{"line":155,"address":[3041412],"length":1,"stats":{"Line":2}},{"line":156,"address":[3041467],"length":1,"stats":{"Line":2}},{"line":160,"address":[3041694,3041762],"length":1,"stats":{"Line":4}},{"line":162,"address":[3041789],"length":1,"stats":{"Line":2}},{"line":165,"address":[3041840,3042265,3042271],"length":1,"stats":{"Line":1}},{"line":166,"address":[3041864],"length":1,"stats":{"Line":1}},{"line":167,"address":[3041947],"length":1,"stats":{"Line":1}},{"line":173,"address":[3042175],"length":1,"stats":{"Line":0}},{"line":176,"address":[3043314,3042288,3043292],"length":1,"stats":{"Line":1}},{"line":178,"address":[3042316],"length":1,"stats":{"Line":2}},{"line":179,"address":[3042394,3042327],"length":1,"stats":{"Line":2}},{"line":180,"address":[3042588,3042540],"length":1,"stats":{"Line":2}},{"line":181,"address":[3042617],"length":1,"stats":{"Line":1}},{"line":186,"address":[3042563],"length":1,"stats":{"Line":1}},{"line":187,"address":[3042708,3042655],"length":1,"stats":{"Line":2}},{"line":190,"address":[3042723,3042831,3043302,3042958],"length":1,"stats":{"Line":2}},{"line":193,"address":[3042787],"length":1,"stats":{"Line":1}},{"line":194,"address":[2813440,2813449],"length":1,"stats":{"Line":1}},{"line":196,"address":[3043016],"length":1,"stats":{"Line":1}},{"line":197,"address":[3043116,3043263,3043186,3043072],"length":1,"stats":{"Line":2}},{"line":198,"address":[2813488,2813497],"length":1,"stats":{"Line":1}},{"line":200,"address":[3043204],"length":1,"stats":{"Line":1}},{"line":202,"address":[3042626],"length":1,"stats":{"Line":1}},{"line":208,"address":[3044202,3044075,3043328],"length":1,"stats":{"Line":1}},{"line":209,"address":[3043457,3043368],"length":1,"stats":{"Line":2}},{"line":211,"address":[3043541],"length":1,"stats":{"Line":1}},{"line":217,"address":[3043902],"length":1,"stats":{"Line":1}},{"line":221,"address":[3044762,3044240],"length":1,"stats":{"Line":3}},{"line":222,"address":[3044355,3044288],"length":1,"stats":{"Line":5}},{"line":223,"address":[3044618,3044504],"length":1,"stats":{"Line":5}},{"line":224,"address":[3044696],"length":1,"stats":{"Line":3}},{"line":227,"address":[3044535],"length":1,"stats":{"Line":0}},{"line":230,"address":[3046090,3046030,3044784],"length":1,"stats":{"Line":1}},{"line":232,"address":[3044820],"length":1,"stats":{"Line":1}},{"line":233,"address":[3044923,3044855],"length":1,"stats":{"Line":2}},{"line":234,"address":[3045109,3045069],"length":1,"stats":{"Line":2}},{"line":235,"address":[3045146],"length":1,"stats":{"Line":1}},{"line":240,"address":[3045092],"length":1,"stats":{"Line":1}},{"line":241,"address":[3045192,3046068,3045281],"length":1,"stats":{"Line":1}},{"line":243,"address":[3046040,3045474,3045582,3045709],"length":1,"stats":{"Line":2}},{"line":246,"address":[3045538],"length":1,"stats":{"Line":1}},{"line":247,"address":[2813536,2813545],"length":1,"stats":{"Line":1}},{"line":249,"address":[3045767],"length":1,"stats":{"Line":1}},{"line":250,"address":[3045823,3046001,3045937,3045867],"length":1,"stats":{"Line":2}},{"line":251,"address":[2813584,2813593],"length":1,"stats":{"Line":1}},{"line":253,"address":[3045955],"length":1,"stats":{"Line":1}},{"line":255,"address":[3045155],"length":1,"stats":{"Line":0}},{"line":259,"address":[3046849,3046128],"length":1,"stats":{"Line":1}},{"line":261,"address":[3046158],"length":1,"stats":{"Line":1}},{"line":262,"address":[3046166],"length":1,"stats":{"Line":1}},{"line":263,"address":[3046253],"length":1,"stats":{"Line":1}},{"line":264,"address":[3046302],"length":1,"stats":{"Line":1}},{"line":269,"address":[3046288],"length":1,"stats":{"Line":1}},{"line":270,"address":[3046337],"length":1,"stats":{"Line":1}},{"line":273,"address":[3046570,3046384,3046481],"length":1,"stats":{"Line":2}},{"line":276,"address":[3046436],"length":1,"stats":{"Line":1}},{"line":277,"address":[2813632,2813641],"length":1,"stats":{"Line":1}},{"line":279,"address":[3046619],"length":1,"stats":{"Line":1}},{"line":280,"address":[3046672,3046786,3046716,3046829],"length":1,"stats":{"Line":2}},{"line":281,"address":[2813689,2813680],"length":1,"stats":{"Line":1}},{"line":283,"address":[3046804],"length":1,"stats":{"Line":1}},{"line":285,"address":[3046308],"length":1,"stats":{"Line":0}},{"line":289,"address":[3047617,3047623,3046880],"length":1,"stats":{"Line":2}},{"line":291,"address":[3046905],"length":1,"stats":{"Line":1}},{"line":292,"address":[3046913,3046945],"length":1,"stats":{"Line":2}},{"line":293,"address":[3047000],"length":1,"stats":{"Line":1}},{"line":294,"address":[3047049],"length":1,"stats":{"Line":1}},{"line":299,"address":[3047035],"length":1,"stats":{"Line":1}},{"line":300,"address":[3047084],"length":1,"stats":{"Line":1}},{"line":302,"address":[3047219,3047320,3047113],"length":1,"stats":{"Line":2}},{"line":305,"address":[3047165],"length":1,"stats":{"Line":1}},{"line":306,"address":[2813728,2813737],"length":1,"stats":{"Line":1}},{"line":308,"address":[3047378],"length":1,"stats":{"Line":1}},{"line":309,"address":[3047594,3047548,3047434,3047478],"length":1,"stats":{"Line":2}},{"line":310,"address":[2813785,2813776],"length":1,"stats":{"Line":1}},{"line":312,"address":[3047566],"length":1,"stats":{"Line":1}},{"line":314,"address":[3047055],"length":1,"stats":{"Line":0}}],"covered":115,"coverable":123},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej04.rs"],"content":"use std::collections::HashMap;\nuse crate::tp03::ej03::Fecha;\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n#[derive(Clone, Serialize, Deserialize)]\nenum Genero {\n    Novela,\n    Infantil,\n    Tecnico,\n    Otros\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nenum EstadoPrestamo {\n    Devuelto,\n    EnPrestamo,\n}\n\n#[derive(Clone)]\nstruct Biblioteca {\n    nombre: String,\n    direccion: String,\n    libros: HashMap\u003cu32, Libro\u003e, //Key: ISBN.\n    prestamos: Vec\u003cPrestamo\u003e,\n    archivo_libros: PathBuf,\n    archivo_prestamos: PathBuf,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Libro {\n    isbn: u32,\n    titulo: String,\n    copias_disponiles: u32,\n    autor: String,\n    numero_paginas: u32,\n    genero: Genero,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Prestamo {\n    isbn_libro: u32,\n    cliente: Cliente,\n    fecha_vencimiento: Fecha,\n    fecha_devolucion: Fecha, \n    estado: EstadoPrestamo,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Cliente {\n    nombre: String,\n    telefono: u32,\n    correo: String,\n}\n\n#[derive(Debug)]\nenum ErroresPersonalizados {\n    ErrorArchivo,\n    LibroNoEncontrado,\n    PrestamoNoPosible,\n}\n\npub fn no_devolvio (estado: \u0026EstadoPrestamo) -\u003e bool {\n    match estado {\n        (EstadoPrestamo::EnPrestamo) =\u003e true,\n        _ =\u003e false,\n    }\n}\n\npub fn compare_clientes (cliente1: \u0026Cliente, cliente2: \u0026Cliente) -\u003e bool {\n    cliente1.nombre == cliente2.nombre \u0026\u0026\n    cliente1.correo == cliente2.correo \u0026\u0026\n    cliente1.telefono == cliente2.telefono\n}\n\nimpl Biblioteca {\n\n    pub fn cargar_al_archivo_libros(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut archivo_libros:File = match File::create(self.archivo_libros.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        serde_json::to_writer(\u0026archivo_libros, \u0026self.libros)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    pub fn cargar_al_archivo_prestamos(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut archivo_prestamos:File = match File::create(self.archivo_prestamos.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        serde_json::to_writer(\u0026archivo_prestamos, \u0026self.prestamos)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    fn obtener_cantidad_copias (\u0026self, libro: \u0026Libro) -\u003e u32 {\n        if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            return book.copias_disponiles;\n        } else {\n            return 0;\n        } \n    }\n\n    pub fn modificar_campo_json_libro(\u0026mut self, isbn: u32, nuevas_copias: u32) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Open the json file.\n        \n        let file = File::open(self.archivo_libros.clone()).map_err(|_| ErroresPersonalizados::ErrorArchivo)?; \n        \n        let mut libros_deserializados: HashMap\u003cu32, Libro\u003e  = serde_json::from_reader(file)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n\n        //Modify the specific field.\n        if let Some(libro) = libros_deserializados.get_mut(\u0026isbn.clone()) {\n            libro.copias_disponiles = nuevas_copias;\n        } else {\n            return Err(ErroresPersonalizados::LibroNoEncontrado);\n        }\n\n        //Serialize the updated data structure back into JSON format.\n\n        let file = File::create(self.archivo_libros.clone()).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n        serde_json::to_writer(file, \u0026libros_deserializados).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    pub fn modificar_campo_json_prestmo(\u0026mut self, estado: \u0026EstadoPrestamo, cliente: \u0026Cliente, isbn: \u0026u32) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Open the json file.\n        \n        let file = File::open(self.archivo_prestamos.clone()).map_err(|_| ErroresPersonalizados::ErrorArchivo)?; \n        \n        let mut prestamos_deserializados: Vec\u003cPrestamo\u003e  = serde_json::from_reader(file)\n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n\n        //Modify the specific field.\n        for prestamo in prestamos_deserializados.iter_mut() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == isbn.clone() {\n                prestamo.estado = estado.clone();\n                break; //Si encontré el cliente no hay necesidad de seguir buscando.\n            }\n        }\n\n        //Serialize the updated data structure back into JSON format.\n\n        let file = File::create(self.archivo_prestamos.clone()).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n        serde_json::to_writer(file, \u0026prestamos_deserializados).map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    fn decrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let (isbn, copias) = {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles -= 1;\n                (book.isbn, book.copias_disponiles)\n            } else {\n                return Err(ErroresPersonalizados::LibroNoEncontrado)?; \n            }\n        }; // Mutable borrow ends here\n        \n        self.modificar_campo_json_libro(isbn, copias); //Debería hacer que se propague el result de esto?\n        Ok(())\n    }\n\n    fn incrementar_cantidad_copias (\u0026mut self, libro: \u0026Libro) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let (isbn, copias) = {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles += 1;\n                (book.isbn, book.copias_disponiles)\n            } else {\n                return Err(ErroresPersonalizados::LibroNoEncontrado); \n            }\n        }; // Mutable borrow ends here\n        \n        self.modificar_campo_json_libro(isbn, copias); //Debería hacer que se propague el result de esto?\n        Ok(())\n    }\n\n    fn contar_prestamos_cliente (\u0026self, cliente: \u0026Cliente) -\u003e u32 {\n        let mut cant_prestamos= 0;\n\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) {\n                cant_prestamos += 1;\n            }\n        }\n        cant_prestamos\n    }\n\n    fn realizar_prestamo (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        //Check if the book exists and has available copies.\n        let mut updated_loan: Option\u003cPrestamo\u003e = None;\n        let mut updated_book: Option\u003cLibro\u003e = None;\n\n        let okay_prestamo = if let Some(book) = self.libros.get(\u0026libro.isbn) {\n            book.copias_disponiles \u003e= 1\n        } else {\n            false\n        };\n\n        //Check if the client has fewer than 5 loans.\n        if okay_prestamo \u0026\u0026 self.contar_prestamos_cliente(cliente) \u003c 5 {\n            if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                book.copias_disponiles -= 1;\n                updated_book = Some(book.clone());\n                //Crear el préstamo en estado en prestamo.\n                self.prestamos.push(Prestamo {\n                    isbn_libro: 999, // libro cualquiera\n                    cliente: cliente.clone(),\n                    fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n                    fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n                    estado: EstadoPrestamo::EnPrestamo,\n                });\n            }\n        } else  {\n            return Err(ErroresPersonalizados::PrestamoNoPosible);\n        }\n\n\n\n        //Mod arch libro (copias)\n        if updated_book.clone().is_some() {\n            self.modificar_campo_json_libro(updated_book.clone().unwrap().isbn.clone(), updated_book.clone().unwrap().copias_disponiles.clone()); \n            self.cargar_al_archivo_prestamos();\n        }\n\n        Ok(())\n    }\n\n\n    fn prestamos_vencer(\u0026self, cant_dias: u32, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut fecha_limite = fecha_actual.clone();\n        fecha_limite.sumar_dias(cant_dias);\n\n        let mut lista_prestamos_vencer = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            let fecha_igual = prestamo.fecha_vencimiento.dia == fecha_actual.dia \u0026\u0026 prestamo.fecha_vencimiento.mes == fecha_actual.mes \u0026\u0026 prestamo.fecha_vencimiento.año == fecha_actual.año;\n\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_limite) \u0026\u0026  // fecha_vencimiento \u003c= fecha_limite\n            (prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual) || fecha_igual)  // fecha_vencimiento \u003e= fecha_actual\n            {\n                lista_prestamos_vencer.push(prestamo.clone());\n            }\n        }\n         lista_prestamos_vencer    \n    }\n\n    fn prestamos_vencidos(\u0026self, fecha_actual: \u0026Fecha) -\u003e Vec\u003cPrestamo\u003e {\n        let mut lista_prestamos_vencidos = Vec::new();\n\n        for prestamo in self.prestamos.iter() {\n            if no_devolvio(\u0026prestamo.estado) \u0026\u0026\n            !prestamo.fecha_vencimiento.es_mayor(\u0026fecha_actual)\n            {\n                lista_prestamos_vencidos.push(prestamo.clone());\n            }\n        }\n        lista_prestamos_vencidos \n    }\n\n    fn buscar_prestamo (\u0026self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Option\u003cPrestamo\u003e {\n        for prestamo in self.prestamos.iter() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                return Some(prestamo.clone());\n            }\n        }\n        None\n    }\n\n    fn devolver_libro (\u0026mut self, libro: \u0026Libro, cliente: \u0026Cliente) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut updated_book: Option\u003cLibro\u003e = None;\n        let mut updated_loan: Option\u003cPrestamo\u003e = None;\n\n        for prestamo in self.prestamos.iter_mut() {\n            if compare_clientes(\u0026prestamo.cliente, \u0026cliente) \u0026\u0026 prestamo.isbn_libro == libro.isbn {\n                prestamo.estado= EstadoPrestamo::Devuelto;\n                if let Some(book) = self.libros.get_mut(\u0026libro.isbn) {\n                    book.copias_disponiles += 1;     \n                    updated_book = Some(book.clone());  \n                    updated_loan = Some(prestamo.clone());         \n                } else {\n                    return Err(ErroresPersonalizados::LibroNoEncontrado);\n                }\n\n                break; //Si encontré el cliente no hay necesidad de seguir buscando.\n            }\n        }\n\n        //Mod arch libro (copias)\n        if updated_book.clone().is_some() {\n            self.modificar_campo_json_libro(updated_book.clone().unwrap().isbn.clone(), updated_book.clone().unwrap().copias_disponiles.clone()); \n            \n            //Mod arch prest.\n            if updated_loan.clone().is_some() {\n                self.modificar_campo_json_prestmo(\u0026updated_loan.clone().unwrap().estado, \u0026updated_loan.clone().unwrap().cliente, \u0026updated_book.clone().unwrap().isbn);\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_obtener_cant_copias_libro() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        //Insertar libro.\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        let copias = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias, 7);\n    \n        //Libro no existente debe devolver 0\n        let libro_inexistente = Libro {\n            isbn: 999,\n            titulo: \"No existe\".to_string(),\n            copias_disponiles: 0,\n            autor: \"\".to_string(),\n            numero_paginas: 0,\n            genero: Genero::Otros,\n        };\n        let copias_inexistente = biblioteca.obtener_cantidad_copias(\u0026libro_inexistente);\n        assert_eq!(copias_inexistente, 0);\n    }\n\n    #[test]\n    fn test_decrementar_copias() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.decrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 6);\n    }\n\n    #[test]\n    fn test_incrementar_copias() {\n        let mut libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.incrementar_cantidad_copias(\u0026libro);\n\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 8);\n    }\n\n    #[test]\n    fn test_contar_prestamos_cliente() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n    \n        let prestamo2 = Prestamo {\n            isbn_libro: libro2.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1, prestamo2],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        let cantidad = biblioteca.contar_prestamos_cliente(\u0026cliente);\n        assert_eq!(cantidad, 2);\n    }\n\n    #[test]\n    fn test_realizar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            correo: \"juan@mail.com\".to_string(),\n        };\n    \n        let libro = Libro {\n            isbn: 101,\n            titulo: \"Libro Test\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor Test\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n    \n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Test\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        biblioteca.libros.insert(libro.isbn, libro.clone());\n    \n        // Cliente sin préstamos previos, debería poder tomar prestado\n        let exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(exito.is_ok());\n    \n        // Copias deberían reducirse en 1\n        let copias_restantes = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_restantes, libro.copias_disponiles - 1);\n    \n        // Simulamos que el cliente ya tiene 5 préstamos\n        for _ in 0..5 {\n            biblioteca.prestamos.push(Prestamo {\n                isbn_libro: 999, // libro cualquiera\n                cliente: cliente.clone(),\n                fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n                fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n                estado: EstadoPrestamo::EnPrestamo,\n            });\n        }\n    \n        // Ahora no debería permitir más préstamos\n        let no_exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(no_exito.is_err());\n    \n        // Copias no deberían cambiar porque no se hizo el préstamo\n        let copias_final = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_final, libro.copias_disponiles - 1);\n    }\n\n    #[test]\n    fn test_prestamos_a_vencer () {\n        let fecha_actual = Fecha { dia: 10, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n            nombre: \"Luis\".to_string(),\n            telefono: 5551234,\n            correo: \"luis@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 123,\n            titulo: \"Libro de prueba\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n\n         // Préstamo que vence dentro de 5 días (día 14)\n        let prestamo_proximo = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 14, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo que vence después de 10 días (día 22)\n        let prestamo_lejano = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 22, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        // Préstamo ya devuelto, no debería aparecer\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 12, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 11, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo_proximo.clone(), prestamo_lejano, prestamo_devuelto],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        let prestamos_vencer = biblioteca.prestamos_vencer(5, \u0026fecha_actual);\n\n        // Sólo debería contener el préstamo que vence dentro de 5 días y está activo\n        assert_eq!(prestamos_vencer.len(), 1);\n\n    }\n\n    #[test]\n    fn test_prestamos_vencidos() {\n        let fecha_actual = Fecha { dia: 15, mes: 5, año: 2025 };\n\n        let cliente = Cliente {\n          nombre: \"Carlos\".to_string(),\n          telefono: 123456,\n          correo: \"carlos@mail.com\".to_string(),\n        };\n\n        let libro = Libro {\n            isbn: 1,\n            titulo: \"Libro X\".to_string(),\n            copias_disponiles: 1,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n\n        let prestamo_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 10, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_no_vencido = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 20, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let prestamo_devuelto = Prestamo {\n            isbn_libro: libro.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 5, mes: 5, año: 2025 },\n            fecha_devolucion: Fecha { dia: 6, mes: 5, año: 2025 },\n            estado: EstadoPrestamo::Devuelto,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblio Test\".to_string(),\n            direccion: \"Dirección\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![\n                prestamo_vencido.clone(),\n                prestamo_no_vencido,\n                prestamo_devuelto,\n            ],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        let vencidos = biblioteca.prestamos_vencidos(\u0026fecha_actual);\n\n        assert_eq!(vencidos.len(), 1);\n    }\n\n    #[test]\n    fn test_buscar_prestamo() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n\n        let biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        assert!(biblioteca.buscar_prestamo(\u0026libro1, \u0026cliente).is_some());\n\n        //Busco uno que no exista;\n        assert!(biblioteca.buscar_prestamo(\u0026libro2, \u0026cliente).is_none())\n    }\n\n    #[test]\n    fn test_devolver_libro() {\n        let cliente = Cliente {\n            nombre: \"Roberto\".to_string(),\n            telefono: 555123789,\n            correo: \"roberto@mail.com\".to_string(),\n        };\n    \n        \n        let mut libro = Libro {\n            isbn: 42,\n            titulo: \"pepe\".to_string(),\n            copias_disponiles: 5,  // Inicialmente hay 5 copias\n            autor: \"Autor\".to_string(),\n            numero_paginas: 300,\n            genero: Genero::Novela,\n        };\n    \n        \n        let prestamo = Prestamo {\n            isbn_libro: libro.isbn.clone(),\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 15, mes: 6, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },  // Aún no devuelto\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        \n        let mut biblioteca = Biblioteca {\n            nombre: \"biblioteca\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn.clone(), libro.clone());\n        biblioteca.devolver_libro(\u0026libro, \u0026cliente);//Lo devuelvo.\n        let libro_devuelto = biblioteca.buscar_prestamo(\u0026libro, \u0026cliente);\n        let esta_devuelto = {\n            match libro_devuelto.unwrap().estado {\n                (EstadoPrestamo::Devuelto) =\u003e true,\n                _ =\u003e false,\n                \n            }\n        };\n\n        //println!(\"{}\", biblioteca.libros.len());\n        let updated_book = biblioteca.libros.get(\u0026libro.isbn.clone());\n        libro = updated_book.unwrap().clone();\n        assert_eq!(libro.copias_disponiles, 6); //Ok.\n\n        assert_eq!(esta_devuelto, true);\n    }\n\n    //Tests nuevos.\n    #[test]\n    fn test_cargar_al_archivo_libros() {\n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let libro2 = Libro {\n            isbn: 2,\n            titulo: \"Libro 2\".to_string(),\n            copias_disponiles: 2,\n            autor: \"Autor 2\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Infantil,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.clone().into(),\n            archivo_prestamos: path_prestamos.clone().into(),\n        };\n\n        biblioteca.libros.insert(1, libro1.clone());\n        biblioteca.libros.insert(2, libro2.clone());\n\n        assert_eq!(biblioteca.libros.len(), 2);\n        assert!(biblioteca.cargar_al_archivo_libros().is_ok()); //Ok.\n    }\n\n    #[test]\n    fn test_cargar_al_archivo_prestamos() {\n        let cliente = Cliente {\n            nombre: \"Ana\".to_string(),\n            telefono: 123456,\n            correo: \"ana@mail.com\".to_string(),\n        };\n    \n        let libro1 = Libro {\n            isbn: 1,\n            titulo: \"Libro 1\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor 1\".to_string(),\n            numero_paginas: 100,\n            genero: Genero::Novela,\n        };\n    \n        let prestamo1 = Prestamo {\n            isbn_libro: libro1.isbn,\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 1, mes: 1, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Falsa\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo1],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        assert!(biblioteca.cargar_al_archivo_prestamos().is_ok());\n    }\n\n    #[test]\n    fn test_decrementar_copias_nuevo() {\n        let libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n    \n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.cargar_al_archivo_libros();\n\n\n        biblioteca.decrementar_cantidad_copias(\u0026libro);\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 6);\n    }\n\n\n    #[test]\n    fn test_incrementar_copias_nuevo() {\n        let mut libro = Libro {\n            isbn: 100,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let mut libro1 = Libro {\n            isbn: 000,\n            titulo: \"Test Libro\".to_string(),\n            copias_disponiles: 7,\n            autor: \"Autor X\".to_string(),\n            numero_paginas: 200,\n            genero: Genero::Novela,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.libros.insert(libro1.isbn, libro1.clone());\n        biblioteca.cargar_al_archivo_libros();\n        \n        biblioteca.incrementar_cantidad_copias(\u0026libro);\n\n        assert_eq!(biblioteca.obtener_cantidad_copias(\u0026libro), 8);\n    }\n\n    #[test]\n    fn test_devolver_libro_nuevo() {\n        let cliente = Cliente {\n            nombre: \"Roberto\".to_string(),\n            telefono: 555123789,\n            correo: \"roberto@mail.com\".to_string(),\n        };\n    \n        \n        let mut libro = Libro {\n            isbn: 42,\n            titulo: \"pepe\".to_string(),\n            copias_disponiles: 5,  // Inicialmente hay 5 copias\n            autor: \"Autor\".to_string(),\n            numero_paginas: 300,\n            genero: Genero::Novela,\n        };\n    \n        \n        let prestamo = Prestamo {\n            isbn_libro: libro.isbn.clone(),\n            cliente: cliente.clone(),\n            fecha_vencimiento: Fecha { dia: 15, mes: 6, año: 2025 },\n            fecha_devolucion: Fecha { dia: 0, mes: 0, año: 0 },  // Aún no devuelto\n            estado: EstadoPrestamo::EnPrestamo,\n        };\n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n    \n        \n        let mut biblioteca = Biblioteca {\n            nombre: \"biblioteca\".to_string(),\n            direccion: \"arg\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![prestamo],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n\n        biblioteca.libros.insert(libro.isbn.clone(), libro.clone());\n        biblioteca.cargar_al_archivo_libros();\n        biblioteca.cargar_al_archivo_prestamos();\n\n\n        biblioteca.devolver_libro(\u0026libro, \u0026cliente);//Lo devuelvo.\n        let libro_devuelto = biblioteca.buscar_prestamo(\u0026libro, \u0026cliente);\n        let esta_devuelto = {\n            match libro_devuelto.unwrap().estado {\n                (EstadoPrestamo::Devuelto) =\u003e true,\n                _ =\u003e false,\n                \n            }\n        };\n\n        //println!(\"{}\", biblioteca.libros.len());\n        let updated_book = biblioteca.libros.get(\u0026libro.isbn.clone());\n        libro = updated_book.unwrap().clone();\n        assert_eq!(libro.copias_disponiles, 6); //Ok.\n\n        assert_eq!(esta_devuelto, true);\n\n        //El archivo de libros se modifica. Ok.\n        //El archivo de préstamos se modifica. Ok.\n\n    }\n\n\n    #[test]\n    fn test_realizar_prestamo_nuevo() {\n        let cliente = Cliente {\n            nombre: \"Juan\".to_string(),\n            telefono: 123456,\n            correo: \"juan@mail.com\".to_string(),\n        };\n    \n        let libro = Libro {\n            isbn: 101,\n            titulo: \"Libro Test\".to_string(),\n            copias_disponiles: 3,\n            autor: \"Autor Test\".to_string(),\n            numero_paginas: 150,\n            genero: Genero::Novela,\n        };\n    \n\n        let path_books = \"src/tp05/archivo_libros.txt\".to_string();\n        let path_prestamos = \"src/tp05/archivo_prestamos.txt\".to_string();\n\n        let mut biblioteca = Biblioteca {\n            nombre: \"Biblioteca Test\".to_string(),\n            direccion: \"Calle Test\".to_string(),\n            libros: HashMap::new(),\n            prestamos: vec![],\n            archivo_libros: path_books.into(),\n            archivo_prestamos: path_prestamos.into(),\n        };\n    \n        biblioteca.libros.insert(libro.isbn, libro.clone());\n        biblioteca.cargar_al_archivo_libros();\n        biblioteca.cargar_al_archivo_prestamos();\n    \n        // Cliente sin préstamos previos, debería poder tomar prestado\n        let exito = biblioteca.realizar_prestamo(\u0026libro, \u0026cliente);\n        assert!(exito.is_ok());\n    \n        // Copias deberían reducirse en 1\n        let copias_restantes = biblioteca.obtener_cantidad_copias(\u0026libro);\n        assert_eq!(copias_restantes, libro.copias_disponiles - 1);\n\n        //El archivo de libros y de préstamos se modifica. Ok.\n    }\n}","traces":[{"line":69,"address":[2847520],"length":1,"stats":{"Line":1}},{"line":70,"address":[2847525],"length":1,"stats":{"Line":1}},{"line":76,"address":[2847552],"length":1,"stats":{"Line":1}},{"line":77,"address":[2847584,2847575],"length":1,"stats":{"Line":1}},{"line":78,"address":[2847600],"length":1,"stats":{"Line":1}},{"line":79,"address":[2847628],"length":1,"stats":{"Line":1}},{"line":84,"address":[2848173,2847664,2848167],"length":1,"stats":{"Line":1}},{"line":85,"address":[2847684],"length":1,"stats":{"Line":1}},{"line":86,"address":[2847725,2848190,2847827],"length":1,"stats":{"Line":0}},{"line":87,"address":[2847786],"length":1,"stats":{"Line":2}},{"line":90,"address":[2848100,2848150,2848039,2847803],"length":1,"stats":{"Line":3}},{"line":91,"address":[2848090,2848024],"length":1,"stats":{"Line":2}},{"line":93,"address":[2848118],"length":1,"stats":{"Line":2}},{"line":96,"address":[2848208,2848717,2848711],"length":1,"stats":{"Line":1}},{"line":97,"address":[2848228],"length":1,"stats":{"Line":1}},{"line":98,"address":[2848734,2848269,2848371],"length":1,"stats":{"Line":0}},{"line":99,"address":[2848330],"length":1,"stats":{"Line":1}},{"line":102,"address":[2848694,2848644,2848583,2848347],"length":1,"stats":{"Line":2}},{"line":103,"address":[2848634,2848568],"length":1,"stats":{"Line":1}},{"line":105,"address":[2848662],"length":1,"stats":{"Line":2}},{"line":108,"address":[2848752],"length":1,"stats":{"Line":1}},{"line":109,"address":[2848766],"length":1,"stats":{"Line":1}},{"line":110,"address":[2848822],"length":1,"stats":{"Line":1}},{"line":112,"address":[2848831],"length":1,"stats":{"Line":1}},{"line":116,"address":[2848848,2850057,2850108],"length":1,"stats":{"Line":2}},{"line":119,"address":[2848888],"length":1,"stats":{"Line":2}},{"line":121,"address":[2849249,2849087,2850102,2849194],"length":1,"stats":{"Line":3}},{"line":122,"address":[2849239,2849171],"length":1,"stats":{"Line":1}},{"line":126,"address":[2849366,2849450],"length":1,"stats":{"Line":2}},{"line":127,"address":[2849514],"length":1,"stats":{"Line":1}},{"line":129,"address":[2849536],"length":1,"stats":{"Line":2}},{"line":134,"address":[3250640,3250649],"length":1,"stats":{"Line":2}},{"line":135,"address":[2849785,2850021,2849866],"length":1,"stats":{"Line":2}},{"line":137,"address":[2849969],"length":1,"stats":{"Line":1}},{"line":140,"address":[2851572,2850144,2851614],"length":1,"stats":{"Line":1}},{"line":143,"address":[2850213],"length":1,"stats":{"Line":1}},{"line":145,"address":[2850558,2850448,2850619,2851605],"length":1,"stats":{"Line":2}},{"line":146,"address":[2850609,2850535],"length":1,"stats":{"Line":1}},{"line":150,"address":[2850779,2850712],"length":1,"stats":{"Line":2}},{"line":151,"address":[2850934,2850984],"length":1,"stats":{"Line":0}},{"line":152,"address":[2851025],"length":1,"stats":{"Line":0}},{"line":159,"address":[2851582,2851069,2850961],"length":1,"stats":{"Line":2}},{"line":160,"address":[2851278,2851520,2851359],"length":1,"stats":{"Line":2}},{"line":162,"address":[2851462],"length":1,"stats":{"Line":1}},{"line":165,"address":[2851648],"length":1,"stats":{"Line":1}},{"line":166,"address":[2851834],"length":1,"stats":{"Line":1}},{"line":167,"address":[2851667],"length":1,"stats":{"Line":1}},{"line":168,"address":[2851727,2851854,2851825],"length":1,"stats":{"Line":2}},{"line":169,"address":[2851828],"length":1,"stats":{"Line":1}},{"line":171,"address":[2851876,2851746],"length":1,"stats":{"Line":0}},{"line":175,"address":[2851842],"length":1,"stats":{"Line":2}},{"line":176,"address":[2851847],"length":1,"stats":{"Line":1}},{"line":179,"address":[2851920],"length":1,"stats":{"Line":2}},{"line":180,"address":[2852055],"length":1,"stats":{"Line":2}},{"line":181,"address":[2851939],"length":1,"stats":{"Line":2}},{"line":182,"address":[2852046,2852000,2852075],"length":1,"stats":{"Line":4}},{"line":183,"address":[2852049],"length":1,"stats":{"Line":2}},{"line":185,"address":[2852017],"length":1,"stats":{"Line":0}},{"line":189,"address":[2852063],"length":1,"stats":{"Line":2}},{"line":190,"address":[2852068],"length":1,"stats":{"Line":2}},{"line":193,"address":[2852112],"length":1,"stats":{"Line":1}},{"line":194,"address":[2852126],"length":1,"stats":{"Line":1}},{"line":196,"address":[2852134,2852175],"length":1,"stats":{"Line":2}},{"line":197,"address":[2852277,2852228],"length":1,"stats":{"Line":2}},{"line":198,"address":[2852279,2852253],"length":1,"stats":{"Line":1}},{"line":201,"address":[2852244],"length":1,"stats":{"Line":1}},{"line":204,"address":[2853729,2852304,2853723],"length":1,"stats":{"Line":1}},{"line":206,"address":[2852360],"length":1,"stats":{"Line":1}},{"line":207,"address":[2852365],"length":1,"stats":{"Line":1}},{"line":209,"address":[2852373,2852509,2852438],"length":1,"stats":{"Line":6}},{"line":210,"address":[2852493],"length":1,"stats":{"Line":2}},{"line":212,"address":[2852511],"length":1,"stats":{"Line":0}},{"line":216,"address":[2852519,2852573],"length":1,"stats":{"Line":4}},{"line":217,"address":[2852603,2852687],"length":1,"stats":{"Line":4}},{"line":218,"address":[2852819,2852747,2852801],"length":1,"stats":{"Line":4}},{"line":219,"address":[2852812,2852918,2852839],"length":1,"stats":{"Line":4}},{"line":221,"address":[2853045,2853148],"length":1,"stats":{"Line":4}},{"line":223,"address":[2853062],"length":1,"stats":{"Line":2}},{"line":224,"address":[2853074],"length":1,"stats":{"Line":2}},{"line":225,"address":[2853107],"length":1,"stats":{"Line":2}},{"line":226,"address":[2853140],"length":1,"stats":{"Line":2}},{"line":230,"address":[2852529],"length":1,"stats":{"Line":1}},{"line":236,"address":[2852782,2853332],"length":1,"stats":{"Line":4}},{"line":237,"address":[2853462],"length":1,"stats":{"Line":2}},{"line":238,"address":[2853696],"length":1,"stats":{"Line":2}},{"line":241,"address":[2853423],"length":1,"stats":{"Line":2}},{"line":245,"address":[2854379,2853744,2854373],"length":1,"stats":{"Line":1}},{"line":246,"address":[2853790],"length":1,"stats":{"Line":1}},{"line":247,"address":[2853822],"length":1,"stats":{"Line":1}},{"line":249,"address":[2853835],"length":1,"stats":{"Line":1}},{"line":251,"address":[2853845,2853916],"length":1,"stats":{"Line":2}},{"line":252,"address":[2854071,2854138],"length":1,"stats":{"Line":2}},{"line":254,"address":[2854199],"length":1,"stats":{"Line":1}},{"line":255,"address":[2854232],"length":1,"stats":{"Line":1}},{"line":256,"address":[2854274],"length":1,"stats":{"Line":1}},{"line":258,"address":[2854331],"length":1,"stats":{"Line":1}},{"line":261,"address":[2854095],"length":1,"stats":{"Line":1}},{"line":264,"address":[2854400,2854839,2854845],"length":1,"stats":{"Line":1}},{"line":265,"address":[2854440],"length":1,"stats":{"Line":1}},{"line":267,"address":[2854450,2854518],"length":1,"stats":{"Line":2}},{"line":268,"address":[2854739,2854673],"length":1,"stats":{"Line":2}},{"line":269,"address":[2854753],"length":1,"stats":{"Line":1}},{"line":271,"address":[2854800],"length":1,"stats":{"Line":1}},{"line":274,"address":[2854698],"length":1,"stats":{"Line":1}},{"line":277,"address":[2854864],"length":1,"stats":{"Line":1}},{"line":278,"address":[2854920,2854961],"length":1,"stats":{"Line":2}},{"line":279,"address":[2855077,2855021],"length":1,"stats":{"Line":2}},{"line":280,"address":[2855089],"length":1,"stats":{"Line":1}},{"line":283,"address":[2855042],"length":1,"stats":{"Line":1}},{"line":286,"address":[2857104,2855136,2857083],"length":1,"stats":{"Line":1}},{"line":287,"address":[2855187],"length":1,"stats":{"Line":1}},{"line":288,"address":[2855195],"length":1,"stats":{"Line":1}},{"line":290,"address":[2855286,2855203],"length":1,"stats":{"Line":3}},{"line":291,"address":[2855441,2855490],"length":1,"stats":{"Line":4}},{"line":292,"address":[2855536],"length":1,"stats":{"Line":1}},{"line":293,"address":[2855554],"length":1,"stats":{"Line":1}},{"line":294,"address":[2855723,2855705,2855639],"length":1,"stats":{"Line":2}},{"line":295,"address":[2855716,2855822,2855743],"length":1,"stats":{"Line":2}},{"line":296,"address":[2855952,2856070],"length":1,"stats":{"Line":1}},{"line":298,"address":[2855656],"length":1,"stats":{"Line":0}},{"line":306,"address":[2856162,2855476],"length":1,"stats":{"Line":2}},{"line":307,"address":[2856295],"length":1,"stats":{"Line":1}},{"line":310,"address":[2856542],"length":1,"stats":{"Line":1}},{"line":311,"address":[2856667],"length":1,"stats":{"Line":1}},{"line":314,"address":[2856253],"length":1,"stats":{"Line":1}}],"covered":117,"coverable":125},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej05.rs"],"content":"use std::{path::PathBuf, ptr::eq};\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nenum TipoSuscripcion {\n    Basic,\n    Clasic,\n    Super,\n}\n\nimpl PartialEq for TipoSuscripcion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoSuscripcion::Basic, TipoSuscripcion::Basic) =\u003e true,\n            (TipoSuscripcion::Clasic, TipoSuscripcion::Clasic) =\u003e true,\n            (TipoSuscripcion::Super, TipoSuscripcion::Super) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n\nimpl TipoSuscripcion {\n    fn costo_mensual(\u0026self) -\u003e f64 {\n        match self {\n            TipoSuscripcion::Basic =\u003e 5.0,\n            TipoSuscripcion::Clasic =\u003e 9.5,\n            TipoSuscripcion::Super =\u003e 15.0,\n        }\n    }\n\n    fn upgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e{\n        match self {\n            TipoSuscripcion::Basic =\u003e Some(TipoSuscripcion::Clasic),\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Super),\n            TipoSuscripcion::Super =\u003e None,\n        }\n    }\n\n    fn downgrade(\u0026self) -\u003e Option\u003cTipoSuscripcion\u003e {\n        match  self {\n            TipoSuscripcion::Basic =\u003e None,\n            TipoSuscripcion::Clasic =\u003e Some(TipoSuscripcion::Basic),\n            TipoSuscripcion::Super =\u003e Some(TipoSuscripcion::Clasic),\n            \n        }\n    }\n\n    fn soy_basic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Basic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_clasic(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Clasic =\u003e true,\n            _ =\u003e false, \n        }\n    }\n\n    fn soy_super(\u0026self) -\u003e bool {\n        match self {\n            TipoSuscripcion::Super =\u003e true,\n            _ =\u003e false, \n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Suscripcion {\n    tipo: TipoSuscripcion,\n    duracion_meses: u8,\n    fecha_inicio: String,\n    activa: bool,\n}\n\nimpl Suscripcion {\n    fn new(tipo: TipoSuscripcion, duracion_meses: u8, fecha_inicio: String) -\u003e Suscripcion {\n        Suscripcion {\n            tipo,\n            duracion_meses,\n            fecha_inicio,\n            activa: true,\n        }\n    }\n\n    fn activar_suscripcion(\u0026mut self) {\n        self.activa = true\n    }\n\n    fn desactivar_suscripcion(\u0026mut self) {\n        self.activa = false\n    }\n\n    fn upgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.upgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede ascender de Super.\".to_string()) //Is it okay to make it an err? \n        }\n    }\n\n    fn downgrade(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.tipo.downgrade() {\n            Some(tipo_nuevo) =\u003e {\n                self.tipo = tipo_nuevo;\n                Ok(())\n            }\n            None =\u003e {\n                self.desactivar_suscripcion();\n                Err(\"Se ha canclado su suscripción.\".to_string())\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nenum MedioPago {\n    Efectivo,\n    MercadoPago {\n        cbu: u32,\n    },\n    TransferenciaBancaria {\n        cuenta_destino: String,\n        cuenta_origen: String,    },\n    TarjetaCredito {\n        numero_tarjeta: u32,\n    },\n    Cripto {\n        tipo_cripto: String,\n    },\n}\n\nimpl MedioPago {\n    fn to_string(\u0026self) -\u003e String {\n        match self {\n            MedioPago::Efectivo =\u003e String::from(\"Efectivo\"),\n            MedioPago::TarjetaCredito { numero_tarjeta } =\u003e String::from(\"TarjetaCredito\"),\n            MedioPago::MercadoPago { cbu } =\u003e String::from(\"MercadoPago\"),\n            MedioPago::TransferenciaBancaria { cuenta_destino, cuenta_origen } =\u003e String::from(\"TransferenciaBancaria\"),\n            MedioPago::Cripto { tipo_cripto } =\u003e String::from(\"Cripto\"),\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Usuario {\n    suscripciones: Vec\u003cSuscripcion\u003e,\n    medio_pago: MedioPago,\n    id: u32,\n    username: String,\n    nombre: String,\n    apellido: String,\n    email: String,\n}\n\nimpl Usuario {\n    fn agregar_suscripcion(\u0026mut self, suscripcion: Suscripcion) {\n        self.suscripciones.iter_mut().for_each(|s| s.desactivar_suscripcion()); //Deactivate all previous subscriptons.\n        self.suscripciones.push(suscripcion); //Add the new subscription.\n    }\n\n    fn obtener_suscripcion_activa(\u0026self) -\u003e Option\u003c\u0026Suscripcion\u003e {\n        self.suscripciones.iter().find(|s| s.activa)\n    }\n\n    fn obtener_suscripcion_activa_mutable(\u0026mut self) -\u003e Option\u003c\u0026mut Suscripcion\u003e {\n        self.suscripciones.iter_mut().find(|s| s.activa)\n    }\n\n    fn cancelar_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion_a_cancelar) =\u003e {\n                suscripcion_a_cancelar.desactivar_suscripcion();\n                Ok(())\n            }\n            None =\u003e Err(\"No se puede cancelar esa suscripción. Ya sea porque no existe o porque ya está desactivada.\".to_string())\n        }\n    }\n\n    fn tiene_suscripcion_activa(\u0026self) -\u003e bool {\n        self.suscripciones.iter().any(|s| s.activa)\n    }\n\n    fn upgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.upgrade();\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para mejorar.\".to_string())\n        }\n    }\n\n    fn downgrade_suscripcion(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        match self.obtener_suscripcion_activa_mutable() {\n            Some(suscripcion) =\u003e {\n                suscripcion.downgrade()?;\n                Ok(())\n            }\n            None =\u003e Err(\"No hay una suscripción activa para degradar.\".to_string())\n        }\n    }\n}\n\nenum ErroresPersonalizados {\n    ErrorArchivo,\n}\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct StreamingRust {\n    usuarios: Vec\u003cUsuario\u003e, \n    archivo_usuarios_suscripciones: PathBuf,\n    \n}\n\nimpl StreamingRust {\n\n    pub fn crear_plataforma(archivo_usuarios_suscripciones: String) -\u003e StreamingRust {\n        let path = PathBuf::from(archivo_usuarios_suscripciones);\n        StreamingRust {\n            usuarios: Vec::new(),\n            archivo_usuarios_suscripciones: path,\n        }\n    }\n\n    fn cargar_usuario_al_archivo(\u0026mut self, usuario: \u0026Usuario) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut file = OpenOptions::new()\n        .create(true)      // Create file if it doesn't exist\n        .append(true)      // Append to end of file (don't overwrite)\n        .open(\u0026self.archivo_usuarios_suscripciones)\n        .map_err(|_| ErroresPersonalizados::ErrorArchivo)?;\n\n        let usuario_serializado = serde_json::to_string(\u0026usuario).unwrap();\n\n        match file.write(\u0026usuario_serializado.as_bytes()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo),\n            Ok(_) =\u003e Ok(()),\n        }\n    }\n\n    fn modificar_archivo(\u0026mut self) -\u003e Result\u003c(), ErroresPersonalizados\u003e {\n        let mut file:File = match File::create(self.archivo_usuarios_suscripciones.clone()) {\n            Err(e) =\u003e Err(ErroresPersonalizados::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        let writer = std::io::BufWriter::new(\u0026file);\n\n        serde_json::to_writer(writer, \u0026self.usuarios) \n            .map_err(|e| ErroresPersonalizados::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    pub fn crear_usuario(\u0026mut self, suscripcion: \u0026Suscripcion, medio_pago: \u0026MedioPago, id: u32, username: String, nombre: String, apellido: String, email: String) {\n        //Tendría que chequear que el usuario no existe antes??\n        let usuario = Usuario {\n            id: id,\n            suscripciones: vec![suscripcion.clone()],\n            medio_pago: medio_pago.clone(),\n            username: username,\n            nombre: nombre,\n            apellido: apellido,\n            email: email,\n        };\n\n        self.usuarios.push(usuario.clone());\n\n        //Append al archivo de suscripciones.\n        self.cargar_usuario_al_archivo(\u0026usuario.clone());\n    }\n\n    pub fn upgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        //Given an user upgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.upgrade_suscripcion(); //Update subscription.\n\n            //Modificar archivo suscripciones.\n            self.modificar_archivo();\n        }\n\n    }\n\n    pub fn downgrade_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) -\u003e Result\u003c(), String\u003e {\n        //Given an user downgrade their subscription.\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.downgrade_suscripcion()?; //Downgrade subscription.\n\n            //Modificar archivo suscripciones.\n            self.modificar_archivo();\n\n            return Ok(());\n        }\n        Err(\"No se encontró el usuario\".to_string())\n    }\n\n    pub fn cancelar_suscripcion(\u0026mut self, usuario: \u0026mut Usuario) {\n        if let Some(user) = self.usuarios.iter_mut().find(|u| u.id == usuario.id) {\n            user.cancelar_suscripcion(); //Downgrade subscription.\n\n            //Modificar archivo suscripciones.\n            self.modificar_archivo();\n        }\n    }\n\n    //Estadísticas.\n    pub fn suscripcion_mas_contratada_activos(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones activas de los usuarios.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro usuarios con suscripción activa.\n            .for_each(|u| { //Para cada una de ellas.\n                //Obtener el tipo de suscripción activa.\n                if let Some(suscripcion) = u.obtener_suscripcion_activa() {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {  //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n\n                    }\n                }\n               \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn suscripcion_mas_contratada(\u0026self) -\u003e Option\u003c(TipoSuscripcion, u32)\u003e {\n        //No me importan solo las suscripciones activas, tengo que chequear todas.\n        let mut aux_vec: Vec\u003c(TipoSuscripcion, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario.\n                //Recorrer sus suscripciones (todas).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = aux_vec.iter_mut().find(|(tipo, _)| *tipo == suscripcion.tipo) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        aux_vec.push((suscripcion.tipo.clone(), 1));\n                    }\n                });                     \n            });\n\n        aux_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar.\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) \n    }\n\n    pub fn medio_pago_mas_usado_activos(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n        \n        //Si no coincide con ninguna, creo la posición con el medio de pago y la cantidad inicializada en 1.\n        self.usuarios.iter().filter(|u| u.tiene_suscripcion_activa()) //Filtro los usuarios con suscripciones activas.\n            .for_each(|u| {\n                //Busco si su medio de pago coincide con alguna entrada en el vector -\u003e aumento en 1 la cantidad.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                    entry.1 += 1;\n                } else {\n                    auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                }\n            });\n\n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.\n    }\n\n    pub fn medio_pago_mas_usado(\u0026self) -\u003e Option\u003c(String, u32)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        if self.usuarios.is_empty() {\n            return None;\n        }\n\n        //Ir llenando el aux_vec con las suscripciones de los usuarios.\n        self.usuarios.iter()\n            .for_each(|u| { //Para cada usuario. (No filter).\n                u.suscripciones.iter().for_each(|suscripcion| {\n                    //Si el tipo de suscripción ya existe en el vector auxiliar aumento en 1 la cantidad de veces que aparece.\n                    if let Some(entry) = auxiliar_vec.iter_mut().find(|(medio,_)| *medio == u.medio_pago.to_string()) {\n                        entry.1 += 1;\n                    } else {\n                        //Si no existe creo la posición con el Tipo de suscripción y un valor inicial de uno.\n                        auxiliar_vec.push((u.medio_pago.to_string(), 1));\n                    }\n                });                     \n            });\n        \n        auxiliar_vec.iter() //Creates an iterator over the elements of auxiliar_vec\n        .max_by_key(|\u0026(_, cantidad)| cantidad) //The \u0026(_, cantidad) pattern destructures each tuple in the vector, ignoring the first element (medio) and borrowing the second element (cantidad). The closure returns the cantidad value, which is used as the key for comparison.\n        .map(|(medio, cantidad)| (medio.clone(), *cantidad)) //applies the map method to transform the result of max_by_key. If max_by_key returns Some((medio, cantidad)), the closure |(medio, cantidad)| (medio.clone(), *cantidad) is applied to the tuple.    \n    }\n\n}\n\n\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_upgrade_downgrade() {\n        let mut suscripcion0 = Suscripcion::new(TipoSuscripcion::Basic, 3, \"12/9/2020\".to_string());\n        let mut suscripcion1 = Suscripcion::new(TipoSuscripcion::Super, 3, \"4/9/2019\".to_string());\n\n        //Test upgrade. Ok.\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.upgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_clasic(), true);\n\n        assert!(suscripcion1.upgrade().is_err());\n\n        //Test downgrade. Ok.\n        assert!(suscripcion0.downgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_basic(), true);\n        assert!(suscripcion0.downgrade().is_err());\n        assert_eq!(suscripcion0.activa, false);\n    }\n\n    #[test]\n    fn test_upgrade_subscription() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n        let mut usuarios = vec![user0.clone()];\n        let mut plataforma = StreamingRust {usuarios, archivo_usuarios_suscripciones: path.into()};\n\n        plataforma.upgrade_suscripcion(\u0026mut user0);\n\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n\n        assert!(user0.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Clasic)); //Ok.\n\n\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 124 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Super,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        plataforma.usuarios.push(user1.clone());\n        plataforma.upgrade_suscripcion(\u0026mut user1);\n        assert!(user1.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Super)); //Ok.\n\n\n        plataforma.cancelar_suscripcion(\u0026mut user0);\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user0.id) {\n            user0.suscripciones = updated_user.suscripciones.clone();\n        }\n        assert_eq!(user0.suscripciones.iter().any(|s| s.activa), false); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        //Creo los usuarios para agregarlos a mi plataforma después.\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user2 = Usuario {\n            username: \"sus2\".to_string(),\n            email: \"sus2@email\".to_string(),\n            apellido: \"2\".to_string(),\n            id: 3,\n            nombre: \"sus2\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 123 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut user3 = Usuario {\n            username: \"sus3\".to_string(),\n            email: \"sus3@email\".to_string(),\n            apellido: \"3\".to_string(),\n            id: 4,\n            nombre: \"sus3\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Clasic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: false,\n            }],\n        };\n\n        //En resumen: \n        //Medios de pago: Activos: 2 de efectivo, 1 de mercado pago. Inactivos: 1 Efectivo.\n        //Suscripciones: Activos: 2 Basic, 1 Clasic. Inactivos: 1 Clasic.\n\n        let mut usuarios = vec![user0.clone(), user1.clone(), user2.clone(), user3.clone()];\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n\n        let mut plataforma = StreamingRust {usuarios, archivo_usuarios_suscripciones: path.into()};\n\n        assert_eq!(plataforma.medio_pago_mas_usado_activos(), Some((\"Efectivo\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.medio_pago_mas_usado(), Some((\"Efectivo\".to_string(), 3))); //Ok.\n\n        assert_eq!(plataforma.suscripcion_mas_contratada(), Some((TipoSuscripcion::Clasic, 2))); //Ok. (Se queda con el último valor que encontró (el clasic en este caso) si hay un empate).\n        assert_eq!(plataforma.suscripcion_mas_contratada_activos(), Some((TipoSuscripcion::Basic, 2))); //Ok.\n    }\n\n    //Tests agregados: \n    #[test]\n    fn test_upgrade_downgrade_2() {\n        let mut suscripcion0 = Suscripcion::new(TipoSuscripcion::Clasic, 3, \"12/9/2020\".to_string());\n        let mut suscripcion1 = Suscripcion::new(TipoSuscripcion::Super, 3, \"4/9/2019\".to_string());\n\n        //Test upgrade. Ok.\n        assert_eq!(suscripcion0.tipo.soy_clasic(), true);\n        assert!(suscripcion0.upgrade().is_ok());\n        assert_eq!(suscripcion0.tipo.soy_super(), true);\n\n        assert!(suscripcion1.upgrade().is_err());\n\n        //Test downgrade. Ok.\n        assert_eq!(suscripcion1.tipo.soy_super(), true);\n        assert!(suscripcion1.downgrade().is_ok());\n        assert_eq!(suscripcion1.tipo.soy_clasic(), true);\n    }\n\n    #[test]\n    fn crear_plataforma() {\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n        let mut plataforma:StreamingRust = StreamingRust::crear_plataforma(String::from(path));\n        assert!(plataforma.usuarios.is_empty()); //Ok. Se crea con el vector de usuarios vacío.\n\n        let mut suscripcion: Suscripcion = Suscripcion::new(TipoSuscripcion::Clasic, 3, \"12/9/2020\".to_string());\n\n        let mut user = plataforma.crear_usuario(\u0026suscripcion, \u0026MedioPago::Cripto { tipo_cripto: \"Bitcoin\".to_string() }, 123, \"username\".to_string(), \"nombre\".to_string(), \"apellido\".to_string(), \"email\".to_string());\n        \n        assert_ne!(plataforma.usuarios.is_empty(), true); //Ok.\n        assert_eq!(plataforma.usuarios.len(), 1); //Ok.\n    } \n\n    #[test]\n    fn test_downgrade() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        let mut usuarios = vec![user0.clone()];\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n\n        let mut plataforma = StreamingRust {usuarios, archivo_usuarios_suscripciones: path.into()};\n\n        assert!(plataforma.downgrade_suscripcion(\u0026mut user0).is_err()); //Ok.\n\n\n        let mut user1 = Usuario {\n            username: \"sus1\".to_string(),\n            email: \"sus1@email\".to_string(),\n            apellido: \"1\".to_string(),\n            id: 2,\n            nombre: \"sus1\".to_string(),\n            medio_pago: MedioPago::MercadoPago { cbu: 124 },\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Super,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: true,\n            }],\n        };\n\n        plataforma.usuarios.push(user1.clone());\n        assert!(plataforma.downgrade_suscripcion(\u0026mut user1).is_ok());\n\n        // Synchronize user0 with the updated user.\n        if let Some(updated_user) = plataforma.usuarios.iter().find(|u| u.id == user1.id) {\n            user1.suscripciones = updated_user.suscripciones.clone();\n        }\n\n        assert!(user1.suscripciones.iter().any(|s| s.tipo == TipoSuscripcion::Clasic)); //Ok.\n    }\n\n    #[test]\n    fn test_usuario_features() {\n        let mut user0 = Usuario {\n            username: \"sus0\".to_string(),\n            email: \"sus0@email\".to_string(),\n            apellido: \"0\".to_string(),\n            id: 1,\n            nombre: \"sus0\".to_string(),\n            medio_pago: MedioPago::Efectivo,\n            suscripciones: vec![Suscripcion {\n                tipo: TipoSuscripcion::Basic,\n                duracion_meses: 8,\n                fecha_inicio: \"1/1/2025\".to_string(),\n                activa: false,\n            }],\n        };\n\n        assert!(user0.cancelar_suscripcion().is_err()); //Ok.\n        assert!(user0.upgrade_suscripcion().is_err()); //Ok.\n        assert!(user0.downgrade_suscripcion().is_err()); //Ok.\n\n        let mut suscripcion: Suscripcion = Suscripcion::new(TipoSuscripcion::Clasic, 3, \"12/9/2020\".to_string());\n        user0.agregar_suscripcion(suscripcion);\n        assert_eq!(user0.suscripciones.len(), 2); //Ok.\n\n        //Activar la primera suscripción.\n        user0.suscripciones[0].activar_suscripcion();\n        assert_eq!(user0.suscripciones[0].activa, true); //Ok.\n    }\n\n    #[test]\n    fn test_crear_usuario_archivo() {\n        let path = \"src/tp05/archivo_usuarios_suscripciones.txt\";\n        let mut plataforma:StreamingRust = StreamingRust::crear_plataforma(String::from(path));\n\n        plataforma.crear_usuario(\u0026Suscripcion { tipo: TipoSuscripcion::Basic, duracion_meses: 8, fecha_inicio: \"12/12/2000\".to_string(), activa: true }, \u0026MedioPago::Efectivo, 1, \"user1\".to_string(), \"nombre1\".to_string(), \"ape1\".to_string(), \"email1\".to_string());\n        //Ok. El archivo de usuarios_suscripciones se crea correctamente.\n\n        plataforma.crear_usuario(\u0026Suscripcion { tipo: TipoSuscripcion::Basic, duracion_meses: 8, fecha_inicio: \"12/12/2000\".to_string(), activa: true }, \u0026MedioPago::Efectivo, 2, \"user2\".to_string(), \"nombre2\".to_string(), \"ape2\".to_string(), \"email2\".to_string());\n        //Ok. El usuario nuevo se agrega bien al final del archivo (append).\n    }\n\n    #[test]\n    fn test_costo_mensual() {\n        /*fn costo_mensual(\u0026self) -\u003e f64 {\n        match self {\n            TipoSuscripcion::Basic =\u003e 5.0,\n            TipoSuscripcion::Clasic =\u003e 9.5,\n            TipoSuscripcion::Super =\u003e 15.0,\n        }\n    }\n */\n        let tipo_b = TipoSuscripcion::Basic;\n        assert_eq!(tipo_b.costo_mensual(), 5.0);\n\n        let tipo_c = TipoSuscripcion::Clasic;\n        assert_eq!(tipo_c.costo_mensual(), 9.5);\n\n        let tipo_s = TipoSuscripcion::Super;\n        assert_eq!(tipo_s.costo_mensual(), 15.0);\n    }\n}","traces":[{"line":18,"address":[3114199,3114144],"length":1,"stats":{"Line":1}},{"line":19,"address":[3114201,3114154],"length":1,"stats":{"Line":2}},{"line":30,"address":[3114288],"length":1,"stats":{"Line":0}},{"line":31,"address":[3114293],"length":1,"stats":{"Line":0}},{"line":32,"address":[3114325],"length":1,"stats":{"Line":0}},{"line":33,"address":[3114341],"length":1,"stats":{"Line":0}},{"line":34,"address":[3114357],"length":1,"stats":{"Line":0}},{"line":38,"address":[3114384],"length":1,"stats":{"Line":2}},{"line":39,"address":[3114389],"length":1,"stats":{"Line":2}},{"line":40,"address":[3114421],"length":1,"stats":{"Line":1}},{"line":41,"address":[3114436],"length":1,"stats":{"Line":1}},{"line":42,"address":[3114451],"length":1,"stats":{"Line":1}},{"line":46,"address":[3114464],"length":1,"stats":{"Line":3}},{"line":47,"address":[3114469],"length":1,"stats":{"Line":3}},{"line":48,"address":[3114501],"length":1,"stats":{"Line":1}},{"line":49,"address":[3114508],"length":1,"stats":{"Line":1}},{"line":50,"address":[3114523],"length":1,"stats":{"Line":1}},{"line":55,"address":[3114544],"length":1,"stats":{"Line":1}},{"line":56,"address":[3114549],"length":1,"stats":{"Line":1}},{"line":62,"address":[3114576],"length":1,"stats":{"Line":1}},{"line":63,"address":[3114581],"length":1,"stats":{"Line":1}},{"line":69,"address":[3114608],"length":1,"stats":{"Line":1}},{"line":70,"address":[3114613],"length":1,"stats":{"Line":1}},{"line":86,"address":[3114640],"length":1,"stats":{"Line":1}},{"line":95,"address":[3114688],"length":1,"stats":{"Line":1}},{"line":96,"address":[3114693],"length":1,"stats":{"Line":1}},{"line":99,"address":[3114704],"length":1,"stats":{"Line":2}},{"line":100,"address":[3114709],"length":1,"stats":{"Line":2}},{"line":103,"address":[3114720],"length":1,"stats":{"Line":1}},{"line":104,"address":[3114750],"length":1,"stats":{"Line":2}},{"line":105,"address":[3114796],"length":1,"stats":{"Line":2}},{"line":106,"address":[3114804],"length":1,"stats":{"Line":2}},{"line":107,"address":[3114807],"length":1,"stats":{"Line":2}},{"line":109,"address":[3114822],"length":1,"stats":{"Line":1}},{"line":113,"address":[3114896],"length":1,"stats":{"Line":1}},{"line":114,"address":[3114926],"length":1,"stats":{"Line":1}},{"line":115,"address":[3114972],"length":1,"stats":{"Line":2}},{"line":116,"address":[3114980],"length":1,"stats":{"Line":2}},{"line":117,"address":[3114983],"length":1,"stats":{"Line":2}},{"line":120,"address":[3115002],"length":1,"stats":{"Line":1}},{"line":121,"address":[3115007],"length":1,"stats":{"Line":1}},{"line":145,"address":[3115072],"length":1,"stats":{"Line":1}},{"line":146,"address":[3115096],"length":1,"stats":{"Line":1}},{"line":147,"address":[3115161],"length":1,"stats":{"Line":1}},{"line":148,"address":[3115274],"length":1,"stats":{"Line":0}},{"line":149,"address":[3115193],"length":1,"stats":{"Line":1}},{"line":150,"address":[3115231],"length":1,"stats":{"Line":0}},{"line":151,"address":[3115312],"length":1,"stats":{"Line":0}},{"line":168,"address":[3115360,3115551,3115529],"length":1,"stats":{"Line":1}},{"line":169,"address":[3115441,3115379],"length":1,"stats":{"Line":4}},{"line":170,"address":[3115483],"length":1,"stats":{"Line":1}},{"line":173,"address":[3115568],"length":1,"stats":{"Line":1}},{"line":174,"address":[3115577],"length":1,"stats":{"Line":3}},{"line":177,"address":[3115616],"length":1,"stats":{"Line":2}},{"line":178,"address":[3195088,3195098],"length":1,"stats":{"Line":6}},{"line":181,"address":[3115664],"length":1,"stats":{"Line":1}},{"line":182,"address":[3115694],"length":1,"stats":{"Line":1}},{"line":183,"address":[3115732],"length":1,"stats":{"Line":1}},{"line":184,"address":[3115742],"length":1,"stats":{"Line":1}},{"line":185,"address":[3115752],"length":1,"stats":{"Line":1}},{"line":187,"address":[3115767],"length":1,"stats":{"Line":1}},{"line":191,"address":[3115840],"length":1,"stats":{"Line":1}},{"line":192,"address":[3115849],"length":1,"stats":{"Line":3}},{"line":195,"address":[3115904],"length":1,"stats":{"Line":1}},{"line":196,"address":[3115936],"length":1,"stats":{"Line":1}},{"line":197,"address":[3115974],"length":1,"stats":{"Line":1}},{"line":198,"address":[3115984],"length":1,"stats":{"Line":1}},{"line":199,"address":[3116009],"length":1,"stats":{"Line":1}},{"line":201,"address":[3116024],"length":1,"stats":{"Line":1}},{"line":205,"address":[3116096],"length":1,"stats":{"Line":1}},{"line":206,"address":[3116132],"length":1,"stats":{"Line":1}},{"line":207,"address":[3116170],"length":1,"stats":{"Line":1}},{"line":208,"address":[3116315,3116183],"length":1,"stats":{"Line":2}},{"line":209,"address":[3116369],"length":1,"stats":{"Line":1}},{"line":211,"address":[3116244],"length":1,"stats":{"Line":1}},{"line":228,"address":[3116384,3116548],"length":1,"stats":{"Line":2}},{"line":229,"address":[3116402],"length":1,"stats":{"Line":2}},{"line":231,"address":[3116412],"length":1,"stats":{"Line":2}},{"line":236,"address":[3117078,3116576,3117084],"length":1,"stats":{"Line":2}},{"line":237,"address":[3116673,3116601],"length":1,"stats":{"Line":4}},{"line":240,"address":[3116647],"length":1,"stats":{"Line":2}},{"line":241,"address":[3195136,3195145],"length":1,"stats":{"Line":2}},{"line":243,"address":[3116802,3116754],"length":1,"stats":{"Line":4}},{"line":245,"address":[3116896,3116831],"length":1,"stats":{"Line":4}},{"line":246,"address":[3116992],"length":1,"stats":{"Line":0}},{"line":247,"address":[3117032],"length":1,"stats":{"Line":2}},{"line":251,"address":[3117549,3117555,3117104],"length":1,"stats":{"Line":1}},{"line":252,"address":[3117127],"length":1,"stats":{"Line":1}},{"line":253,"address":[3117236,3117168,3117572],"length":1,"stats":{"Line":0}},{"line":254,"address":[3117201],"length":1,"stats":{"Line":1}},{"line":257,"address":[3117226],"length":1,"stats":{"Line":1}},{"line":259,"address":[3117530,3117444,3117412],"length":1,"stats":{"Line":2}},{"line":260,"address":[3117429],"length":1,"stats":{"Line":1}},{"line":262,"address":[3117496],"length":1,"stats":{"Line":1}},{"line":265,"address":[3117600,3118633,3118728],"length":1,"stats":{"Line":1}},{"line":269,"address":[3117830,3118639,3117767],"length":1,"stats":{"Line":4}},{"line":270,"address":[3118039],"length":1,"stats":{"Line":2}},{"line":277,"address":[3118450,3118499],"length":1,"stats":{"Line":4}},{"line":280,"address":[3118534],"length":1,"stats":{"Line":2}},{"line":283,"address":[3118768],"length":1,"stats":{"Line":1}},{"line":285,"address":[3118791],"length":1,"stats":{"Line":3}},{"line":286,"address":[3118882],"length":1,"stats":{"Line":1}},{"line":289,"address":[3118906],"length":1,"stats":{"Line":1}},{"line":294,"address":[3118928],"length":1,"stats":{"Line":1}},{"line":296,"address":[3118977],"length":1,"stats":{"Line":3}},{"line":297,"address":[3119071,3119204],"length":1,"stats":{"Line":2}},{"line":300,"address":[3119257],"length":1,"stats":{"Line":1}},{"line":302,"address":[3119267],"length":1,"stats":{"Line":1}},{"line":304,"address":[3119132],"length":1,"stats":{"Line":0}},{"line":307,"address":[3119296],"length":1,"stats":{"Line":1}},{"line":308,"address":[3119319],"length":1,"stats":{"Line":3}},{"line":309,"address":[3119410],"length":1,"stats":{"Line":1}},{"line":312,"address":[3119434],"length":1,"stats":{"Line":1}},{"line":317,"address":[3119456,3119804,3119798],"length":1,"stats":{"Line":1}},{"line":318,"address":[3119481],"length":1,"stats":{"Line":1}},{"line":320,"address":[3119491,3119543],"length":1,"stats":{"Line":2}},{"line":321,"address":[3119571],"length":1,"stats":{"Line":0}},{"line":325,"address":[3195296,3195310],"length":1,"stats":{"Line":4}},{"line":326,"address":[3195328],"length":1,"stats":{"Line":2}},{"line":328,"address":[3195360],"length":1,"stats":{"Line":1}},{"line":330,"address":[3195600,3195418,3195616,3195632,3195502],"length":1,"stats":{"Line":5}},{"line":331,"address":[3195602,3195517,3195597],"length":1,"stats":{"Line":2}},{"line":333,"address":[3195544],"length":1,"stats":{"Line":1}},{"line":340,"address":[3119764,3119672],"length":1,"stats":{"Line":2}},{"line":341,"address":[3119726],"length":1,"stats":{"Line":3}},{"line":342,"address":[3195696,3195709],"length":1,"stats":{"Line":3}},{"line":345,"address":[3119824,3120145,3120139],"length":1,"stats":{"Line":1}},{"line":347,"address":[3119849],"length":1,"stats":{"Line":1}},{"line":349,"address":[3119911,3119859],"length":1,"stats":{"Line":2}},{"line":350,"address":[3119939],"length":1,"stats":{"Line":0}},{"line":354,"address":[3119969,3119922],"length":1,"stats":{"Line":2}},{"line":355,"address":[3195744],"length":1,"stats":{"Line":2}},{"line":357,"address":[3195776,3195824],"length":1,"stats":{"Line":2}},{"line":359,"address":[3195848,3196021,3196064,3196048],"length":1,"stats":{"Line":4}},{"line":360,"address":[3196018,3196023,3195940],"length":1,"stats":{"Line":2}},{"line":363,"address":[3195967],"length":1,"stats":{"Line":1}},{"line":368,"address":[3120105,3120013],"length":1,"stats":{"Line":2}},{"line":369,"address":[3120067],"length":1,"stats":{"Line":3}},{"line":370,"address":[3196141,3196128],"length":1,"stats":{"Line":3}},{"line":373,"address":[3120160,3120503,3120509],"length":1,"stats":{"Line":1}},{"line":374,"address":[3120195],"length":1,"stats":{"Line":1}},{"line":376,"address":[3120205,3120257],"length":1,"stats":{"Line":2}},{"line":377,"address":[3120290],"length":1,"stats":{"Line":0}},{"line":381,"address":[3196190,3196176],"length":1,"stats":{"Line":4}},{"line":382,"address":[3196208],"length":1,"stats":{"Line":2}},{"line":384,"address":[3196510,3196496,3196459,3196241],"length":1,"stats":{"Line":4}},{"line":385,"address":[3196461,3196456,3196336],"length":1,"stats":{"Line":2}},{"line":387,"address":[3196363],"length":1,"stats":{"Line":1}},{"line":391,"address":[3120399],"length":1,"stats":{"Line":1}},{"line":392,"address":[3120453],"length":1,"stats":{"Line":3}},{"line":393,"address":[3196672,3196696],"length":1,"stats":{"Line":3}},{"line":396,"address":[3120528,3120850,3120844],"length":1,"stats":{"Line":1}},{"line":397,"address":[3120563],"length":1,"stats":{"Line":1}},{"line":399,"address":[3120625,3120573],"length":1,"stats":{"Line":2}},{"line":400,"address":[3120658],"length":1,"stats":{"Line":0}},{"line":404,"address":[3120636,3120696],"length":1,"stats":{"Line":2}},{"line":405,"address":[3120728],"length":1,"stats":{"Line":2}},{"line":406,"address":[3196864,3196819],"length":1,"stats":{"Line":2}},{"line":408,"address":[3196886,3197105,3197150,3197136],"length":1,"stats":{"Line":4}},{"line":409,"address":[3196985,3197107,3197102],"length":1,"stats":{"Line":2}},{"line":412,"address":[3197007],"length":1,"stats":{"Line":1}},{"line":417,"address":[3120740],"length":1,"stats":{"Line":1}},{"line":418,"address":[3120794],"length":1,"stats":{"Line":3}},{"line":419,"address":[3120814],"length":1,"stats":{"Line":3}}],"covered":149,"coverable":164},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","ej06.rs"],"content":"use std::{collections::HashMap, path::PathBuf};\nuse chrono::{DateTime, Utc};\nuse rand::Rng;\nuse std::ptr::eq;\n\nuse serde::{Serialize, Deserialize};\nuse core::arch;\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::path::Path;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Usuario {\n    nombre: String,\n    apellido: String,\n    email: String,\n    dni: u32,\n    identidad_validada: bool,\n    balance_fiat: f64,\n    balance_criptomoneda: HashMap\u003cString, f64\u003e, //Nombre_cripto -\u003e cantidad.\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Blockchain {\n    nombre: String,\n    prefijo: String,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Criptomoneda { \n    nombre: String,\n    prefijo: String,\n    listado_blockchains: Vec\u003cBlockchain\u003e,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub enum TipoTransaccion {\n    IngresoFiat,\n    CompraCripto,\n    VentaCripto,\n    RetiroCripto,\n    RecepcionCripto,\n    RetiroFiat,\n}\n\nimpl PartialEq for TipoTransaccion {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (TipoTransaccion::CompraCripto, TipoTransaccion::CompraCripto) =\u003e true,\n            (TipoTransaccion::IngresoFiat, TipoTransaccion::IngresoFiat) =\u003e true,\n            (TipoTransaccion::RecepcionCripto, TipoTransaccion::RecepcionCripto) =\u003e true,\n            (TipoTransaccion::RetiroCripto, TipoTransaccion::RetiroCripto) =\u003e true,\n            (TipoTransaccion::RetiroFiat, TipoTransaccion::RetiroFiat) =\u003e true,\n            (TipoTransaccion::VentaCripto, TipoTransaccion::VentaCripto) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nenum Medio {\n    MercadoPago,\n    TransferenciaBancaria,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct Transaccion {\n    fecha: DateTime\u003cUtc\u003e,\n    tipo: TipoTransaccion,\n    usuario: Usuario,\n    monto_fiat: Option\u003cf64\u003e,\n    criptomoneda: Option\u003cCriptomoneda\u003e,\n    monto_criptomoneda: Option\u003cf64\u003e,\n    cotizacion: Option\u003cf64\u003e,\n    blockchain: Option\u003cBlockchain\u003e,\n    hash: Option\u003cString\u003e,\n    medio: Option\u003cMedio\u003e,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\nstruct PlataformaXYZ {\n    usuarios: HashMap\u003cString, Usuario\u003e, //Email -\u003e usuario.\n    criptomonedas: HashMap\u003cString, Criptomoneda\u003e, //Nombre_cripto -\u003e cripto.\n    transacciones: Vec\u003cTransaccion\u003e,\n    archivo_transacciones: PathBuf,\n    archivo_usuarios_balances: PathBuf,\n}\n\n//Custom errors.\n#[derive(Clone, Debug)]\nenum ErrorIntercambio { \n    UsuarioNoValido,\n    BalanceInsuficiente,\n    CriptoNoEncontrada,\n    BlockchainNoDisponible,\n    UsuarioNoEncontrado,\n    ErrorArchivo, //está bien que esté dentro de errorIntercambio o tendría que estar en otro enum?\n}\n\n//Obtener cotizacion.\npub fn obtener_cotizacion(cripto_nombre: \u0026str) -\u003e f64  { //Datos en dólares del 28/05/2025.\n    match cripto_nombre {\n        \"Bitcoin\" =\u003e 107281.20,\n        \"Ethereum\" =\u003e 18.10,\n        \"Litecoin\" =\u003e 94.42,\n        _ =\u003e 50.0,\n    }\n}\n\nimpl PlataformaXYZ {\n    fn new(archivo_transacciones: String, archivo_usuarios_balances: String) -\u003e Self {\n        let path_trans = PathBuf::from(archivo_transacciones);\n        let path_users_bal = PathBuf::from(archivo_usuarios_balances);\n        PlataformaXYZ { usuarios: HashMap::new(), criptomonedas: HashMap::new(), transacciones:Vec::new(), archivo_transacciones: path_trans, archivo_usuarios_balances: path_users_bal }\n    //Tendría que inicializar los archivos de transacciones y de usuarios_balances acá vacíos??? O así está bien?\n    \n    }\n\n    fn cargar_transaccion_al_archivo(\u0026mut self, transaccion: \u0026Transaccion) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        let mut file = OpenOptions::new()\n        .create(true)      // Create file if it doesn't exist\n        .append(true)      // Append to end of file (don't overwrite)\n        .open(\u0026self.archivo_transacciones)\n        .map_err(|_| ErrorIntercambio::ErrorArchivo)?;\n\n        let transaccion_serializada = serde_json::to_string(\u0026transaccion).unwrap();\n\n        match file.write(\u0026transaccion_serializada.as_bytes()) {\n            Err(e) =\u003e Err(ErrorIntercambio::ErrorArchivo),\n            Ok(_) =\u003e Ok(()),\n        }\n    }\n\n    fn cargar_usuarios_al_archivo(\u0026mut self) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Cargar todos los usuarios al archivo.\n        let mut file:File = match File::create(self.archivo_usuarios_balances.clone()) {\n            Err(e) =\u003e Err(ErrorIntercambio::ErrorArchivo)?,\n            Ok(arch) =\u003e arch,\n        };\n\n        let writer = std::io::BufWriter::new(\u0026file);\n\n        serde_json::to_writer(writer, \u0026self.usuarios) \n            .map_err(|e| ErrorIntercambio::ErrorArchivo)?;\n\n        Ok(())\n    }\n\n    //Registrar usuario.\n    pub fn registrar_usuario(\u0026mut self, usuario: Usuario) { \n        self.usuarios.insert(usuario.email.clone(), usuario);\n    }\n\n    pub fn registrar_criptomoneda(\u0026mut self, criptomoneda: Criptomoneda) {\n        self.criptomonedas.insert(criptomoneda.nombre.clone(), criptomoneda);\n    }\n\n    pub fn ingresar_dinero(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Verify that the user exists and it is valided.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        match usuario.identidad_validada {\n            true =\u003e {\n                //Acredito el monto fiat.\n                usuario.balance_fiat += monto_fiat;\n                //println!(\"{}\", usuario.balance_fiat); Just to checked it worked (Ok.)\n                //Creo la transaccion.\n                let transaccion = Transaccion {\n                    fecha: Utc::now(),\n                    tipo: TipoTransaccion::IngresoFiat,\n                    usuario: usuario.clone(),\n                    monto_fiat: Some(monto_fiat),\n                    criptomoneda: None,\n                    monto_criptomoneda: None,\n                    cotizacion: None,\n                    blockchain: None,\n                    hash: None,\n                    medio: None,\n                };\n\n                //Agrego la transaccion a mi registro de transacciones.\n                self.transacciones.push(transaccion.clone());\n                //Modificar archivo transaccion (agregar transaccion)\n                self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n                //Modificar al usuario en el archivo de usuarios_balances. \n                self.cargar_usuarios_al_archivo();\n\n                Ok(())\n            }\n            false =\u003e Err(ErrorIntercambio::UsuarioNoValido),\n        }\n    }\n\n    pub fn comprar_determinada_criptomoneda(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        if usuario.balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Check if the cripto exists.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //If we've come this far it is because the purchase can be made.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre); \n        usuario.balance_fiat -= monto_fiat; //Descuento el monto_fiat del balance_fiat del usuario.\n\n        //Acredito la cantidad acorde de criptos.\n        let cantidad_cripto = monto_fiat/cotizacion;\n\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) += cantidad_cripto;\n\n\n        /* EXPLICACIÓN:\n\n        entry() = busca si existe la clave, me da acceso para leer/crear la entrada. Retorna un entry enum (occupied, vacant).\n        or_insert() = \n            match entry {\n                Occupied(entrada) =\u003e entrada.get_mut(), // Si existe, devuelve \u0026mut al valor\n                Vacant(entrada) =\u003e entrada.insert(0.0), // Si no existe, inserta 0.0 y devuelve \u0026mut\n            }\n\n        Si \"pepe\" existe: retorna \u0026mut f64 apuntando al valor actual\n        Si \"pepe\" no existe: crea la entrada con valor 0.0 y retorna \u0026mut f64\n        */\n\n\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            usuario: usuario.clone(),\n            tipo: TipoTransaccion::CompraCripto,\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(cantidad_cripto),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n        //Modificar al usuario en el archivo de usuarios_balances. \n        self.cargar_usuarios_al_archivo();\n        \n\n        Ok(())\n    }\n\n    pub fn vender_determinada_criptomoneda(\u0026mut self, usuario: \u0026mut Usuario, criptomoneda: \u0026Criptomoneda, monto_criptomoneda: f64) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check if the user exists.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        //Check if the user is a valid user.\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the cripto exixts.\n        if !self.criptomonedas.contains_key(\u0026criptomoneda.nombre) {\n            return Err(ErrorIntercambio::CriptoNoEncontrada);\n        }\n\n        //Check if the user has enough of that cripto to sell.\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        let monto_fiat = cotizacion * monto_criptomoneda;\n\n        //Actualizar datos del usuario.\n        usuario.balance_fiat += monto_fiat;\n        *usuario.balance_criptomoneda.entry(criptomoneda.nombre.clone()).or_insert(0.0) -= monto_criptomoneda; \n\n        //Creo la transaccion. \n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::VentaCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: None,\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n        //Modificar al usuario en el archivo de usuarios_balances. \n        self.cargar_usuarios_al_archivo();\n\n        Ok(())\n    }\n\n    pub fn retirar_criptomoneda_a_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, blockchain: \u0026Blockchain, usuario: \u0026mut Usuario) -\u003e Result\u003cString, ErrorIntercambio\u003e {\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        let balance_cripto = usuario.balance_criptomoneda.get(\u0026criptomoneda.nombre).or(Some(\u00260.0));\n        if balance_cripto \u003c Some(\u0026monto_criptomoneda) {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Verificar que la blockchain es soportada por la cripto.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?;\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n         //Generar hash simulado\n         let mut rng = rand::rng();\n         let hash = format!(\"{}{}\", blockchain.nombre, rng.random::\u003cu32\u003e());\n         \n         let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n\n         *usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre).unwrap() -= monto_criptomoneda; //Descuento la cantidad acorde de esa cripto.\n\n         //Generar transaccion.\n         let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroCripto,\n            usuario: usuario.clone(),\n            monto_fiat: None,\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: Some(hash.clone()),\n            medio: None,\n         };\n\n         self.transacciones.push(transaccion.clone());\n         //Modificar archivo transaccion (agregar transaccion)\n         self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n         //Modificar al usuario en el archivo de usuarios_balances. \n         self.cargar_usuarios_al_archivo();\n\n         Ok(hash)\n    }\n\n    pub fn recibir_criptomoneda_de_blockchain(\u0026mut self, monto_criptomoneda: f64, criptomoneda: \u0026Criptomoneda, usuario: \u0026mut Usuario, blockchain: \u0026Blockchain) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user data.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check cripto and blockchain.\n        let cripto = self.criptomonedas.get(\u0026criptomoneda.nombre)\n            .ok_or(ErrorIntercambio::CriptoNoEncontrada)?; //Si no existe se propaga el error y termina la función.\n        \n        let blockchain_soportada = cripto.listado_blockchains.iter()\n            .any(|b| b.nombre == blockchain.nombre); //Busco la blockchain dada en el listado de blockchains de la cripto.\n        \n        if !blockchain_soportada {\n            return Err(ErrorIntercambio::BlockchainNoDisponible);\n        }\n\n        //Acredito la cripto en el balance del usuario.\n        let cotizacion = obtener_cotizacion(\u0026criptomoneda.nombre);\n        if let Some(balance) = usuario.balance_criptomoneda.get_mut(\u0026criptomoneda.nombre) { //Busco si ya está la cripto en los balances del usuario.\n            *balance += monto_criptomoneda / cotizacion; \n        } else {\n            // Si la criptomoneda no existe en el balance, la inicializo con el monto dado.\n            usuario.balance_criptomoneda.insert(criptomoneda.nombre.clone(), monto_criptomoneda / cotizacion);\n        }\n\n        //Genero la transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RecepcionCripto,\n            usuario: usuario.clone(),\n            criptomoneda: Some(criptomoneda.clone()),\n            monto_fiat: None,\n            monto_criptomoneda: Some(monto_criptomoneda),\n            cotizacion: Some(cotizacion),\n            blockchain: Some(blockchain.clone()),\n            hash: None,\n            medio: None,\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n\n        //Modificar al usuario en el archivo de usuarios_balances. \\\n        self.cargar_usuarios_al_archivo();\n\n        Ok(())\n    }\n    \n    pub fn retirar_fiat_por_determinado_medio(\u0026mut self, monto_fiat: f64, usuario: \u0026mut Usuario, medio: \u0026Medio) -\u003e Result\u003c(), ErrorIntercambio\u003e {\n        //Check user.\n        let usuario = self.usuarios.get_mut(\u0026usuario.email)\n            .ok_or(ErrorIntercambio::UsuarioNoEncontrado)?;\n\n        if !usuario.identidad_validada {\n            return Err(ErrorIntercambio::UsuarioNoValido);\n        }\n\n        //Check if the user has enough money.\n        let balance_fiat = usuario.balance_fiat;\n        if balance_fiat \u003c monto_fiat {\n            return Err(ErrorIntercambio::BalanceInsuficiente);\n        }\n\n        //Descontar el monto fiat del monto del usuario.\n        usuario.balance_fiat -= monto_fiat;\n\n        //Generar transaccion.\n        let transaccion = Transaccion {\n            fecha: Utc::now(),\n            tipo: TipoTransaccion::RetiroFiat,\n            usuario: usuario.clone(),\n            monto_fiat: Some(monto_fiat),\n            criptomoneda: None,\n            monto_criptomoneda: None,\n            cotizacion: None,\n            blockchain: None,\n            hash: None,\n            medio: Some(medio.clone()),\n        };\n\n        self.transacciones.push(transaccion.clone());\n        //Modificar archivo transaccion (agregar transaccion)\n        self.cargar_transaccion_al_archivo(\u0026transaccion.clone());\n        \n        //Modificar al usuario en el archivo de usuarios_balances. \n        self.cargar_usuarios_al_archivo();\n\n        Ok(())\n    }\n\n\n\n\n    //Estadísticas.\n    pub fn criptomoneda_mas_vendida(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n\n        \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea VentaCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de ventas asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más ventas).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n\n        /*EXPLANATION: \n        Inside the map closure:\n\n        (nombre, cantidad) destructures the reference: nombre is \u0026String, cantidad is \u0026u32\n        nombre.clone() creates an owned String from the \u0026String\n        *cantidad dereferences the \u0026u32 to get an owned u32\n         */\n    }\n\n    pub fn criptomoneda_mas_comprada(\u0026self) -\u003e Option\u003c(String, u32)\u003e { //Return an option with the cripto and the amount of sales.\n        let mut auxiliar_vec: Vec\u003c(String, u32)\u003e = Vec::new();\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        //Solo me fijo en las transacciones cuyo tipo sea CompraCripto.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::CompraCripto)\n            .for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += 1; //Si existen, aumento el contador de compras asociado a esa cripto.\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), 1)); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by_key(|\u0026(_, cantidad)| cantidad)  //Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más compras).\n        .map(|(nombre, cantidad)| (nombre.clone(), *cantidad)) //El max_by_key me devuelve un Option\u003c\u0026(String, u32)\u003e, yo quiero un Option\u003c(String, u32)\u003e\n    }\n\n    pub fn crpitomoneda_mas_volumen_venta (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t| t.tipo == TipoTransaccion::VentaCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción VentaCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de venta).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    }\n\n\n    pub fn crpitomoneda_mas_volumen_compra (\u0026self) -\u003e Option\u003c(String, f64)\u003e {\n        let mut auxiliar_vec: Vec\u003c(String, f64)\u003e = Vec::new();\n\n    \n        if self.transacciones.is_empty() {\n            return None;\n        }\n\n        //Ir completando el vector.\n        self.transacciones.iter().filter(|t|t.tipo == TipoTransaccion::CompraCripto).\n            for_each(|t| { //Para cada una de ellas.\n                if let Some(entry) = auxiliar_vec.iter_mut().find(|(name, _)| *name == t.criptomoneda.as_ref().unwrap().nombre) { //Busco si existen en el vector auxiliar.\n                    entry.1 += t.monto_criptomoneda.unwrap(); //Si existen, aumento el contador asociado a esa cripto.\n                    //Sé que es seguro hacer el unwrap. (El tipo de transacción CompraCripto implica que haya algo (Some()) en el monto_criptomoneda).\n                } else {\n                    auxiliar_vec.push((t.criptomoneda.as_ref().unwrap().nombre.to_string(), t.monto_criptomoneda.unwrap())); //Si no existe, creo la 'posicion' en el vector.\n                }\n            });\n\n        auxiliar_vec.iter()\n        .max_by(|\u0026(_, volumen1), \u0026(_, volumen2)| volumen1.partial_cmp(\u0026volumen2).unwrap())//Tengo que ver cuál es el máximo de mi vector auxiliar. (Para así saber cuál fue la cripto con más volumen de compra).\n        .map(|(nombre, volumen)| (nombre.clone(), *volumen))\n    } \n}\n\n\n#[cfg(test)]\nmod test {\n    use core::hash;\n    use std::path;\n\n    use super::*;\n\n    fn crear_plataforma() -\u003e PlataformaXYZ {\n        let path_transacciones = \"src/tp05/archivo_transacciones.txt\";\n        let path_usuarios_balances = \"src/tp05/archivo_usuarios_transacciones.txt\";\n        let mut plataforma = PlataformaXYZ::new(String::from(path_transacciones), String::from(path_usuarios_balances));\n\n\n\n        //Crear usuarios.\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user2 = Usuario {\n            nombre: \"Rosita\".to_string(),\n            apellido: \"R\".to_string(),\n            email: \"emailRosita\".to_string(),\n            dni: 345,\n            identidad_validada: true,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        plataforma.registrar_usuario(user0);\n        plataforma.registrar_usuario(user1);\n        plataforma.registrar_usuario(user2);\n        plataforma.registrar_usuario(user3);\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        let litecoin_chain = Blockchain {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        let litecoin = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![litecoin_chain],\n        };\n\n        plataforma.registrar_criptomoneda(bitcoin);\n        plataforma.registrar_criptomoneda(ethereum);\n        plataforma.registrar_criptomoneda(litecoin);\n\n        plataforma\n    }\n\n\n    #[test]\n    fn test_ingresar_dinero() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user3 = Usuario {\n            nombre: \"Ana\".to_string(),\n            apellido: \"A\".to_string(),\n            email: \"emailAna\".to_string(),\n            dni: 456,\n            identidad_validada: false,\n            balance_fiat: 7000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Test with an user that is valid.\n        \n        //println!(\"Balance before: {}\", \u0026user0.balance_fiat);\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user0).is_ok());\n\n        //let usuario = plataforma.usuarios.get(\u0026user0.email);\n        //println!(\"From platform {}\", usuario.unwrap().balance_fiat); //Se modifica.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0.balance_fiat = updated_user.balance_fiat; // Synchronize user0 with the updated user\n\n        //println!(\"Balance after: {}\", user0.balance_fiat);\n        assert_eq!(user0.balance_fiat, 12000.0);\n\n\n        //Test with an user that is not valid.\n        assert!(plataforma.ingresar_dinero(2000.0, \u0026mut user3).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_comprar_determinada_moneda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let mut user1 = Usuario {\n            nombre: \"Juan\".to_string(),\n            apellido: \"J\".to_string(),\n            email: \"emailJuan\".to_string(),\n            dni: 234,\n            identidad_validada: true,\n            balance_fiat: 2000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { //Esta cripto sí está.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let pepecripto = Criptomoneda { //Esta cripto no.\n            nombre: \"PepeCripto\".to_string(),\n            prefijo: \"PC\".to_string(),\n            listado_blockchains: vec![],\n        };\n\n        //Compra de una cripto que existe desde un usario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Tiene la cripto.\n\n        //Compra de una cripto que no existe desde un usuario que sí puede(user0).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026pepecripto).is_err()); //Ok.\n\n        //Compra de una cripto que sí existe desde un usuario que NO puede(user1, por el balance).\n        assert!(plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user1, \u0026bitcoin).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_vender_determinada_criptomeda() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.01).is_ok());\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone();\n        assert_eq!(user0.balance_fiat, 8072.812); //Ok. Se le acreditó el balance fiat de su venta.\n    }\n\n    #[test]\n    fn test_retirar_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { //Blockchain válida.\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let bitcoin_unvalid_chain = Blockchain { //Blockchain NO válida.\n            nombre: \"bit\".to_string(),\n            prefijo: \"b\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n\n        plataforma.comprar_determinada_criptomoneda(3000.0, \u0026mut user0, \u0026bitcoin); //Le compro btc.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        //Ahora user0 tiene 7000 fiat. Y 0.027963893 btc.\n\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0).is_ok());\n\n        //let hash = plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_chain, \u0026mut user0);\n        //println!(\"{}\", hash.unwrap()); \n\n\n        //Probar con una blockchain que no existe.\n        assert!(plataforma.retirar_criptomoneda_a_blockchain(0.01, \u0026bitcoin, \u0026bitcoin_unvalid_chain, \u0026mut user0).is_err()); //Ok.\n    }\n\n    #[test]\n    fn test_recibir_criptomoneda_a_blockchain() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda { \n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain.clone()],\n        };\n\n        //Arranca user0 sin criptos. (HM len == 0).\n        //println!(\"Error: {:?}\",plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain) ); \n        assert!(plataforma.recibir_criptomoneda_de_blockchain(0.01, \u0026bitcoin, \u0026mut user0, \u0026bitcoin_chain).is_ok()); //Ok.\n\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n        assert_eq!(user0.balance_criptomoneda.len(), 1); //Ok.\n    }\n\n    #[test]\n    fn test_retirar_fiat() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 10000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        let medio = \u0026Medio::MercadoPago;\n\n        assert!(plataforma.retirar_fiat_por_determinado_medio(5000.0,\u0026mut user0, medio).is_ok()); //Ok.\n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n        assert_eq!(user0.balance_fiat, 5000.0); //Ok.\n    }\n\n    #[test]\n    fn test_estadisticas() {\n        let mut plataforma = crear_plataforma();\n\n        let mut user0 = Usuario {\n            nombre: \"Pepe\".to_string(),\n            apellido: \"P\".to_string(),\n            email: \"emailPepe\".to_string(),\n            dni: 123,\n            identidad_validada: true,\n            balance_fiat: 100000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        //Voy a usar a user0 para haga todas las transacciones.\n\n        // Crear blockchains\n        let bitcoin_chain = Blockchain {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n        };\n\n        let ethereum_chain = Blockchain {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n        };\n\n        let litecoin_chain = Blockchain {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LTC\".to_string(),\n        };\n\n        // Crear criptomonedas\n        let bitcoin = Criptomoneda {\n            nombre: \"Bitcoin\".to_string(),\n            prefijo: \"BTC\".to_string(),\n            listado_blockchains: vec![bitcoin_chain],\n        };\n\n        let ethereum = Criptomoneda {\n            nombre: \"Ethereum\".to_string(),\n            prefijo: \"ETH\".to_string(),\n            listado_blockchains: vec![ethereum_chain],\n        };\n\n        let litecoin = Criptomoneda {\n            nombre: \"Litecoin\".to_string(),\n            prefijo: \"LIC\".to_string(),\n            listado_blockchains: vec![litecoin_chain],\n        };\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026bitcoin);\n        \n\n        plataforma.comprar_determinada_criptomoneda(1000.0, \u0026mut user0, \u0026ethereum);\n\n        plataforma.comprar_determinada_criptomoneda(100.0, \u0026mut user0, \u0026litecoin);\n        \n        let updated_user = plataforma.usuarios.get(\u0026user0.email).unwrap();\n        user0 = updated_user.clone(); // Synchronize user0 with the updated user\n\n\n        //assert_eq!(user0.balance_criptomoneda.len(), 2);\n        //println!(\"{}\", plataforma.transacciones.len());\n        assert_eq!(plataforma.criptomoneda_mas_comprada(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_compra(), Some((\"Ethereum\".to_string(), 55.24861878453038))); //Ok.\n\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026bitcoin, 0.0001);\n        plataforma.vender_determinada_criptomoneda(\u0026mut user0, \u0026ethereum, 0.0001);\n\n        assert_eq!(plataforma.criptomoneda_mas_vendida(), Some((\"Bitcoin\".to_string(), 2))); //Ok.\n        assert_eq!(plataforma.crpitomoneda_mas_volumen_venta(), Some((\"Bitcoin\".to_string(), 0.0002))); //Ok.\n    }\n\n    #[test]\n    fn test_obtener_cotizacion() {\n        assert_eq!(obtener_cotizacion(\"Litecoin\"), 94.42);\n        assert_eq!(obtener_cotizacion(\"pepe\"), 50.0);\n\n    }\n\n    #[test]\n    fn test_cargar_usuarios_al_archivo() {\n        let mut plataforma = crear_plataforma();\n        \n        assert!(plataforma.cargar_usuarios_al_archivo().is_ok()); //Ok. El archivo de modifica bien.\n\n        let mut user_nuevo = Usuario {\n            nombre: \"Caca\".to_string(),\n            apellido: \"C\".to_string(),\n            email: \"caca@email\".to_string(),\n            dni: 666,\n            identidad_validada: true,\n            balance_fiat: 100000.0,\n            balance_criptomoneda: HashMap::new()\n        };\n\n        plataforma.registrar_usuario(user_nuevo.clone());\n        assert!(plataforma.cargar_usuarios_al_archivo().is_ok()); //Se agrega bien al final del archivo. Ok.\n    }\n\n\n}","traces":[{"line":48,"address":[3126608,3126662],"length":1,"stats":{"Line":1}},{"line":49,"address":[3126618,3126664],"length":1,"stats":{"Line":1}},{"line":102,"address":[3126816],"length":1,"stats":{"Line":1}},{"line":104,"address":[3126892,3126839],"length":1,"stats":{"Line":2}},{"line":105,"address":[3126869,3126940],"length":1,"stats":{"Line":2}},{"line":106,"address":[3126917,3126972],"length":1,"stats":{"Line":2}},{"line":107,"address":[3126956],"length":1,"stats":{"Line":1}},{"line":112,"address":[3127589,3127008],"length":1,"stats":{"Line":1}},{"line":113,"address":[3127030],"length":1,"stats":{"Line":2}},{"line":114,"address":[3127104],"length":1,"stats":{"Line":2}},{"line":115,"address":[3127189,3127242],"length":1,"stats":{"Line":3}},{"line":120,"address":[3128220,3127632,3128214],"length":1,"stats":{"Line":2}},{"line":121,"address":[3127823,3127657,3127748],"length":1,"stats":{"Line":4}},{"line":124,"address":[3127703],"length":1,"stats":{"Line":2}},{"line":125,"address":[3099673,3099664],"length":1,"stats":{"Line":2}},{"line":127,"address":[3127875,3127923],"length":1,"stats":{"Line":5}},{"line":129,"address":[3128020,3127955],"length":1,"stats":{"Line":4}},{"line":130,"address":[3128116],"length":1,"stats":{"Line":0}},{"line":131,"address":[3128170],"length":1,"stats":{"Line":5}},{"line":135,"address":[3128781,3128787,3128240],"length":1,"stats":{"Line":1}},{"line":137,"address":[3128263],"length":1,"stats":{"Line":1}},{"line":138,"address":[3128804,3128304,3128403],"length":1,"stats":{"Line":0}},{"line":139,"address":[3128365],"length":1,"stats":{"Line":1}},{"line":142,"address":[3128393],"length":1,"stats":{"Line":1}},{"line":144,"address":[3128600,3128764,3128714,3128644],"length":1,"stats":{"Line":2}},{"line":145,"address":[3099712,3099721],"length":1,"stats":{"Line":1}},{"line":147,"address":[3128732],"length":1,"stats":{"Line":1}},{"line":151,"address":[3129024,3128832,3129049],"length":1,"stats":{"Line":1}},{"line":152,"address":[3128852,3128939],"length":1,"stats":{"Line":3}},{"line":155,"address":[3129296,3129272,3129056],"length":1,"stats":{"Line":2}},{"line":156,"address":[3129166,3129075],"length":1,"stats":{"Line":4}},{"line":159,"address":[3130228,3129312,3130222],"length":1,"stats":{"Line":1}},{"line":161,"address":[3129434,3129355,3129391],"length":1,"stats":{"Line":2}},{"line":162,"address":[3129423,3129371],"length":1,"stats":{"Line":1}},{"line":164,"address":[3129476],"length":1,"stats":{"Line":1}},{"line":167,"address":[3129520],"length":1,"stats":{"Line":1}},{"line":171,"address":[3129534],"length":1,"stats":{"Line":1}},{"line":173,"address":[3129576],"length":1,"stats":{"Line":1}},{"line":174,"address":[3129591],"length":1,"stats":{"Line":1}},{"line":184,"address":[3130076,3130015],"length":1,"stats":{"Line":2}},{"line":186,"address":[3130111],"length":1,"stats":{"Line":1}},{"line":189,"address":[3130195],"length":1,"stats":{"Line":1}},{"line":191,"address":[3130202],"length":1,"stats":{"Line":1}},{"line":193,"address":[3129485],"length":1,"stats":{"Line":1}},{"line":197,"address":[3131570,3131576,3130256],"length":1,"stats":{"Line":1}},{"line":199,"address":[3130348,3130391,3130312],"length":1,"stats":{"Line":2}},{"line":200,"address":[3130328,3130380],"length":1,"stats":{"Line":1}},{"line":203,"address":[3130430],"length":1,"stats":{"Line":1}},{"line":204,"address":[3130439],"length":1,"stats":{"Line":0}},{"line":208,"address":[3130465],"length":1,"stats":{"Line":1}},{"line":209,"address":[3130511],"length":1,"stats":{"Line":1}},{"line":213,"address":[3130496],"length":1,"stats":{"Line":1}},{"line":214,"address":[3130526],"length":1,"stats":{"Line":1}},{"line":218,"address":[3130546],"length":1,"stats":{"Line":2}},{"line":219,"address":[3130598],"length":1,"stats":{"Line":2}},{"line":222,"address":[3130612],"length":1,"stats":{"Line":1}},{"line":224,"address":[3130631],"length":1,"stats":{"Line":2}},{"line":242,"address":[3130718],"length":1,"stats":{"Line":1}},{"line":243,"address":[3130748],"length":1,"stats":{"Line":2}},{"line":246,"address":[3130844,3130786],"length":1,"stats":{"Line":4}},{"line":247,"address":[3130924],"length":1,"stats":{"Line":2}},{"line":248,"address":[3130945],"length":1,"stats":{"Line":1}},{"line":254,"address":[3131366,3131418],"length":1,"stats":{"Line":3}},{"line":256,"address":[3131456],"length":1,"stats":{"Line":2}},{"line":259,"address":[3131540],"length":1,"stats":{"Line":4}},{"line":262,"address":[3131547],"length":1,"stats":{"Line":1}},{"line":265,"address":[3131600,3132979,3132985],"length":1,"stats":{"Line":1}},{"line":267,"address":[3131726,3131683,3131647],"length":1,"stats":{"Line":2}},{"line":268,"address":[3131663,3131715],"length":1,"stats":{"Line":1}},{"line":271,"address":[3131765],"length":1,"stats":{"Line":1}},{"line":272,"address":[3131774],"length":1,"stats":{"Line":0}},{"line":276,"address":[3131799],"length":1,"stats":{"Line":1}},{"line":277,"address":[3131826],"length":1,"stats":{"Line":0}},{"line":281,"address":[3131851],"length":1,"stats":{"Line":1}},{"line":282,"address":[3131890],"length":1,"stats":{"Line":1}},{"line":283,"address":[3132178],"length":1,"stats":{"Line":0}},{"line":286,"address":[3131934],"length":1,"stats":{"Line":1}},{"line":287,"address":[3131980],"length":1,"stats":{"Line":1}},{"line":290,"address":[3131999],"length":1,"stats":{"Line":1}},{"line":291,"address":[3132013],"length":1,"stats":{"Line":1}},{"line":295,"address":[3132103],"length":1,"stats":{"Line":1}},{"line":297,"address":[3132141],"length":1,"stats":{"Line":1}},{"line":299,"address":[3132171,3132247],"length":1,"stats":{"Line":2}},{"line":300,"address":[3132327],"length":1,"stats":{"Line":1}},{"line":301,"address":[3132354],"length":1,"stats":{"Line":1}},{"line":307,"address":[3132775,3132827],"length":1,"stats":{"Line":2}},{"line":309,"address":[3132865],"length":1,"stats":{"Line":1}},{"line":312,"address":[3132949],"length":1,"stats":{"Line":1}},{"line":314,"address":[3132956],"length":1,"stats":{"Line":1}},{"line":317,"address":[3133008,3135291,3135263],"length":1,"stats":{"Line":1}},{"line":318,"address":[3133099,3133152,3133203],"length":1,"stats":{"Line":2}},{"line":319,"address":[3133123,3133192],"length":1,"stats":{"Line":1}},{"line":321,"address":[3133241],"length":1,"stats":{"Line":1}},{"line":322,"address":[3133255],"length":1,"stats":{"Line":0}},{"line":325,"address":[3133298],"length":1,"stats":{"Line":1}},{"line":326,"address":[3133346],"length":1,"stats":{"Line":1}},{"line":327,"address":[3133498],"length":1,"stats":{"Line":0}},{"line":331,"address":[3133450,3133409,3133553],"length":1,"stats":{"Line":2}},{"line":332,"address":[3133539,3133421],"length":1,"stats":{"Line":1}},{"line":334,"address":[3133589],"length":1,"stats":{"Line":1}},{"line":335,"address":[3099760,3099785],"length":1,"stats":{"Line":3}},{"line":337,"address":[3133655],"length":1,"stats":{"Line":1}},{"line":338,"address":[3133664],"length":1,"stats":{"Line":1}},{"line":342,"address":[3133700],"length":1,"stats":{"Line":1}},{"line":343,"address":[3133722,3133793],"length":1,"stats":{"Line":2}},{"line":345,"address":[3134039,3133971],"length":1,"stats":{"Line":2}},{"line":347,"address":[3134077],"length":1,"stats":{"Line":1}},{"line":351,"address":[3134138],"length":1,"stats":{"Line":1}},{"line":353,"address":[3134178],"length":1,"stats":{"Line":1}},{"line":355,"address":[3134268,3134210],"length":1,"stats":{"Line":2}},{"line":356,"address":[3134348],"length":1,"stats":{"Line":1}},{"line":357,"address":[3134375],"length":1,"stats":{"Line":1}},{"line":358,"address":[3134404,3134451],"length":1,"stats":{"Line":2}},{"line":359,"address":[3134566,3134499],"length":1,"stats":{"Line":2}},{"line":363,"address":[3134972,3135024],"length":1,"stats":{"Line":2}},{"line":365,"address":[3135062],"length":1,"stats":{"Line":1}},{"line":368,"address":[3135146],"length":1,"stats":{"Line":1}},{"line":370,"address":[3135158],"length":1,"stats":{"Line":1}},{"line":373,"address":[3136938,3136932,3135312],"length":1,"stats":{"Line":1}},{"line":375,"address":[3135430,3135473,3135394],"length":1,"stats":{"Line":2}},{"line":376,"address":[3135410,3135462],"length":1,"stats":{"Line":1}},{"line":378,"address":[3135515],"length":1,"stats":{"Line":1}},{"line":379,"address":[3135524],"length":1,"stats":{"Line":0}},{"line":383,"address":[3135549,3135650,3135590],"length":1,"stats":{"Line":2}},{"line":384,"address":[3135639,3135561],"length":1,"stats":{"Line":1}},{"line":386,"address":[3135684],"length":1,"stats":{"Line":1}},{"line":387,"address":[3099833,3099808],"length":1,"stats":{"Line":3}},{"line":389,"address":[3135750],"length":1,"stats":{"Line":1}},{"line":390,"address":[3135754],"length":1,"stats":{"Line":0}},{"line":394,"address":[3135783],"length":1,"stats":{"Line":1}},{"line":395,"address":[3135824,3135912],"length":1,"stats":{"Line":1}},{"line":396,"address":[3135900],"length":1,"stats":{"Line":0}},{"line":399,"address":[3135924],"length":1,"stats":{"Line":1}},{"line":404,"address":[3135979],"length":1,"stats":{"Line":1}},{"line":406,"address":[3136017],"length":1,"stats":{"Line":1}},{"line":407,"address":[3136035,3136099],"length":1,"stats":{"Line":2}},{"line":409,"address":[3136191],"length":1,"stats":{"Line":1}},{"line":410,"address":[3136212],"length":1,"stats":{"Line":1}},{"line":411,"address":[3136288,3136241],"length":1,"stats":{"Line":2}},{"line":416,"address":[3136728,3136780],"length":1,"stats":{"Line":2}},{"line":418,"address":[3136818],"length":1,"stats":{"Line":1}},{"line":421,"address":[3136902],"length":1,"stats":{"Line":1}},{"line":423,"address":[3136909],"length":1,"stats":{"Line":1}},{"line":426,"address":[3138000,3137994,3136960],"length":1,"stats":{"Line":1}},{"line":428,"address":[3137095,3137016,3137052],"length":1,"stats":{"Line":2}},{"line":429,"address":[3137084,3137032],"length":1,"stats":{"Line":1}},{"line":431,"address":[3137134],"length":1,"stats":{"Line":1}},{"line":432,"address":[3137143],"length":1,"stats":{"Line":0}},{"line":436,"address":[3137169],"length":1,"stats":{"Line":1}},{"line":437,"address":[3137183],"length":1,"stats":{"Line":1}},{"line":438,"address":[3137376],"length":1,"stats":{"Line":0}},{"line":442,"address":[3137218],"length":1,"stats":{"Line":1}},{"line":446,"address":[3137232],"length":1,"stats":{"Line":1}},{"line":448,"address":[3137270],"length":1,"stats":{"Line":1}},{"line":449,"address":[3137286],"length":1,"stats":{"Line":1}},{"line":455,"address":[3137442,3137365],"length":1,"stats":{"Line":2}},{"line":458,"address":[3137799,3137848],"length":1,"stats":{"Line":2}},{"line":460,"address":[3137883],"length":1,"stats":{"Line":1}},{"line":463,"address":[3137967],"length":1,"stats":{"Line":1}},{"line":465,"address":[3137974],"length":1,"stats":{"Line":1}},{"line":472,"address":[3138407,3138413,3138064],"length":1,"stats":{"Line":1}},{"line":473,"address":[3138099],"length":1,"stats":{"Line":1}},{"line":476,"address":[3138161,3138109],"length":1,"stats":{"Line":2}},{"line":477,"address":[3138194],"length":1,"stats":{"Line":0}},{"line":482,"address":[3138232,3138172],"length":1,"stats":{"Line":4}},{"line":483,"address":[3099904],"length":1,"stats":{"Line":2}},{"line":484,"address":[3099937,3100208,3100222,3100185],"length":1,"stats":{"Line":4}},{"line":485,"address":[3100032,3100182,3100187],"length":1,"stats":{"Line":2}},{"line":487,"address":[3100063],"length":1,"stats":{"Line":1}},{"line":491,"address":[3138303],"length":1,"stats":{"Line":1}},{"line":492,"address":[3138357],"length":1,"stats":{"Line":3}},{"line":493,"address":[3100320,3100344],"length":1,"stats":{"Line":3}},{"line":504,"address":[3138781,3138432,3138775],"length":1,"stats":{"Line":1}},{"line":505,"address":[3138467],"length":1,"stats":{"Line":1}},{"line":507,"address":[3138529,3138477],"length":1,"stats":{"Line":2}},{"line":508,"address":[3138562],"length":1,"stats":{"Line":0}},{"line":513,"address":[3138600,3138540],"length":1,"stats":{"Line":4}},{"line":514,"address":[3100480],"length":1,"stats":{"Line":2}},{"line":515,"address":[3100761,3100513,3100784,3100798],"length":1,"stats":{"Line":4}},{"line":516,"address":[3100763,3100758,3100608],"length":1,"stats":{"Line":2}},{"line":518,"address":[3100639],"length":1,"stats":{"Line":1}},{"line":522,"address":[3138671],"length":1,"stats":{"Line":1}},{"line":523,"address":[3100874,3100864],"length":1,"stats":{"Line":3}},{"line":524,"address":[3100896,3100920],"length":1,"stats":{"Line":3}},{"line":527,"address":[3139149,3139143,3138800],"length":1,"stats":{"Line":1}},{"line":528,"address":[3138835],"length":1,"stats":{"Line":1}},{"line":531,"address":[3138845,3138897],"length":1,"stats":{"Line":2}},{"line":532,"address":[3138930],"length":1,"stats":{"Line":0}},{"line":536,"address":[3138908,3138968],"length":1,"stats":{"Line":4}},{"line":537,"address":[3101431,3101437,3101056],"length":1,"stats":{"Line":2}},{"line":538,"address":[3101225,3101089,3101470,3101456],"length":1,"stats":{"Line":4}},{"line":539,"address":[3101189],"length":1,"stats":{"Line":1}},{"line":542,"address":[3101237,3101327],"length":1,"stats":{"Line":1}},{"line":546,"address":[3139039],"length":1,"stats":{"Line":1}},{"line":547,"address":[3101536,3101555],"length":1,"stats":{"Line":3}},{"line":548,"address":[3139113],"length":1,"stats":{"Line":3}},{"line":552,"address":[3139517,3139511,3139168],"length":1,"stats":{"Line":1}},{"line":553,"address":[3139203],"length":1,"stats":{"Line":1}},{"line":556,"address":[3139213,3139265],"length":1,"stats":{"Line":2}},{"line":557,"address":[3139298],"length":1,"stats":{"Line":0}},{"line":561,"address":[3101742,3101728],"length":1,"stats":{"Line":4}},{"line":562,"address":[3101776,3102151,3102157],"length":1,"stats":{"Line":2}},{"line":563,"address":[3102190,3102176,3101809,3101945],"length":1,"stats":{"Line":4}},{"line":564,"address":[3101909],"length":1,"stats":{"Line":1}},{"line":567,"address":[3102047,3101957],"length":1,"stats":{"Line":1}},{"line":571,"address":[3139407],"length":1,"stats":{"Line":1}},{"line":572,"address":[3102275,3102256],"length":1,"stats":{"Line":3}},{"line":573,"address":[3102360,3102336],"length":1,"stats":{"Line":3}}],"covered":191,"coverable":208},{"path":["/","home","julieta-murias","repos","seminario-rust","src","tp05","mod.rs"],"content":"pub mod ej01;\npub mod ej02;\npub mod ej03;\npub mod ej04;\npub mod ej05;\npub mod ej06;","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>